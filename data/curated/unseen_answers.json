[
    {
        "id": "smp0086q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. use of temporarily valid tsaps\n[–] not applicable in most cases as tsap must be known to address the correct process\n[+] in case of always changing tsaps which are known to sender and receiver (i.e. through a known sequence) an attacker has a harder time tracing/interrupting the targeted traffic in case there are multiple senders/receivers\n2. identify connections individually by assigning new seqno\n[–] requires state / storing seqno (connection oriented system)\n[+] easy differentiation of connections\n3. identify pdus individually with seqno's\n[–] a notion of a \"lifetime\" of a packet in the network is needed\n[–] higher usage of bandwidth and memory\n[+] works with connectionless system",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0330q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "to use the piggybacking extension to the sliding window protocol, we have to be in a duplex mode.",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0021q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding as it is simple to implement and uses the bandwidth well. it's also easily doable as all parties have a perfect clock and therefore there is no problem receiving and differentiating multiple bits of the same type after another.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0044q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "λ = 9pkts/s\nµ = 10pkts/s\nρ = 9/10 = 0,9 = 90% utilization\ne[n] = (0,9/0,1) – ((11*0,9^11) / (1-0,9^11)) = 3,969 = 4 expected number of customers in the system.",
        "answer_feedback": "the response is incorrect because the question requirement is to find out the expected number of seconds where the system has less than 10 packets waiting in the queue while the response states the number of expected packets in the system, which is incorrect as well.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0324q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver. therefore, the ack for a data frame from a sender is sent in one frame with the next data frame issued by the receiver. thus, the requirement for piggybacking is a duplex connection (and the need of sending an ack).",
        "answer_feedback": "the response identifies the underlying requirement duplex connection correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0033q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding. because the binary encoding uses the least bandwidth among these three techniques. and the local network with 3 users is tolerant of frequency errors happened in binary encoding.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0182q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, because sometimes many users want to access the server at the same time, while at other times, only few request the server. for example a livestream of a football match: everybody sends requests to the server at kickoff, but only few do after the game (to watch the highlights). that means that the arrivals are not independent. they can depend on other events.",
        "answer_feedback": "the arrival depends on other events in such cases but the dependency can also be observed in the normal scenario when no such event is happening. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0074q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop1\n(a,b, forward)\n(a,c, forward)\n(a,d, forward)\n\nhop2\n(b,e,forward)\n(c,f,forward)\n\nhop3\n(e,g,forward)\n\nhop4\n(g,h,forward)",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0031q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding als non-return to zero-level (nrz-l) wäre zu empfehlen, da es hierbei eine gute ausnutzung der bandbreite (1 bit pro baud) bereitgestellt werden kann. des weiteren erfordert diese kodierung eine sehr akurate zeitmessung der teilnehmer, da kein self-clocking stattinden kann (bei einer abfolge gleicher werte verändert sich die kurve nicht), dies ist aber gegeben.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0269q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the diameter gets smaller by the same factor.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0190q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "at the start, the bridges table is empty, it uses flooding for an unknown destination. during the backward learning process, the bridge works in promiscuous mode as it receives any frame on any of its lans, then the bridge receives frames with sources address q on lan l, q can be reached over l and therefore create table entry accordingly.",
        "answer_feedback": "the response correctly describes how transparent bridges build their bridge table. however, the response does not provide information on how the table is used during the forwarding process and what benefits this brings.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0179q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption can not hold for real internet traffic because the underlying assumption of independence is false. over a higher timescale the behavior of the user is undergoing changes. for example a user checks his mails in the morning for which packets arrive but then he goes to work and in that time no packets arrive. another example disproving the assumption of independence is the on/off bursty traffic while watching videos. for some time packets arrive continuously and then if the buffer is full no packets arrive until the buffer is empty again and needs to be refilled.",
        "answer_feedback": "the first example in the response is partially correct because the arrival process' parameters can be time-dependent. that can model such intra-day variations like people going to work. knowing previous arrivals no longer has to capture this information for us, thus making the inter-arrival times independent in this regard. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0077q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)(a, c, forward)(a, d, forward)\nhop 2:\n(b, e, forward)(b, c, drop) <= not the minimal route / part of minimal spanning tree. c would use (c,a)(c, b, drop) <= not the minimal route / part of minimal spanning tree. b would use (b, a) (c, e, drop) <= not the minimal route / part of minimal spanning tree. e would use (e, b, a)(c, f, forward)(c, d, drop) <= not the minimal route / part of minimal spanning tree. d would use (d, a)(d, c, drop) <= not the minimal route / part of minimal spanning tree. c would use (c, a)(d, f, drop) <= not the minimal route / part of minimal spanning tree. f would use (f, c, a)\nhop 3:\n(e, c, drop) <= not the minimal route / part of minimal spanning tree. c would use (c, a)(e, f, drop) <= not the minimal route / part of minimal spanning tree. f would use (f, c, a)(e, g, forward)(f, d, drop) <= not the minimal route / part of minimal spanning tree. d would use (d, a)(f, e, drop) <= not the minimal route / part of minimal spanning tree. e would use (e, b, a)(f, g, drop) <= not the minimal route / part of minimal spanning tree. g would use (g, e, b, a)\nhop 4:\n(g, f, drop) <= not the minimal route / part of minimal spanning tree. f would use (f, c, a)(g, h, forward)\nhop 5:\nno further transmissions because no more routes except to g available.",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0142q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "data link layer service classes:\n- unconfirmed connectionless service\n- confirmed connectionless service \n- connection-oriented service\n\nin unconfirmed connectionless and confirmed connectionless services there is no established connection between the sender and the receiver, while in connection-oriented service, the data is only transferred when a connection is established between the sender and the receiver. in connection-oriented there is also a disconnect phase.\n\nin unconfirmed connectionless service when the sender sends a frame, it hopes the frame reachs the receiver without a problem. the sender does not receive any confirmation, from the receiver, that the frame was received. this is not what happens in confirmed connectionless and connection-oriented services. when a message is received on the receiver side, the receiver sends a confirmation message to the sender. so, in this two services the sender has the confirmation that the message reached the receiver.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0219q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "they are techniques to forward multicast packets in networks. they use information the is has about the network structure (derived from normal unicast packets) to guess where to send the multicast packets. if a packet in rpf arrives over the \"usual\" path over which the sender sends, the is will distribute(flood) the network with the packet. if the packet arrives not over the usual path, the packet will be dropped. in rpb, if the packet arrives over the \"usual\" path, the is will send it over the path that unicast packets \"usually\" take and not flood the network. if the packet arrives not over the usual path, the packet will be dropped.",
        "answer_feedback": "the response is partially correct because it lacks the purpose of both algorithms which is to minimize the number of duplicate packets during broadcasting. in both algorithms, the packet is also not forwarded to the edge from which it was received.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.7
    },
    {
        "id": "smp0357q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 to 0.255.255.255\n10.0.0.0 to 10.255.255.255\n127.0.0.0 to 127.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0023q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "character oriented encoding is used.",
        "answer_feedback": "the response is not related to the theme of the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0195q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "all bridges inspect all the traffic and build up tables (bridge tables), these tables hold information to manage the traffic and each entry contains an address and the lan that leads to that address.\n\nthe bridge table is initially empty and uses flooding for an unknown destination. \nduring the backward learning phase (learning process) the bridge works in promiscuous mode and receives any frame on any of its lans. if the bridge receives frames with source address q on lan l and q can be reached over l, then it will create table entry accordingly. \nthese tables are adapted to changes in topology. each entry is associated with a timestamp (frame arrival time), and the timestamp of an entry (z, lan, ts) is updated when the frame received from z. \nthe table scanned periodically and old entries purged if no update for some time, usually several minutes (e.g., because the system moved and reinserted at a different position, or flooding was used if the machine was quiet for some minutes).\n\nthe main benefit of bridge tables in the forwarding process is to increase reliability by connecting lans via various bridges in parallel.",
        "answer_feedback": "the response incorrectly mentions the benefit of using multiple transparent bridges but the question asked for the benefit of using bridging information in forwarding frames. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0070q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop): because d recognize that f and c won't receive packets via d.\n\n\nhop 2:\n(b, e, forward)\n(c, f, drop): because f recognize that e,d and g won't receive packets via f.\n\n\nhop 3:\n(e, g, forward)\n\n\nhop 4:\n(g, h, drop): there is only one possibility for  h to receive the packet (via g ) and it can't be send it anywhere else.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0232q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "1. there is no loop",
        "answer_feedback": "the response lacks the explanation of the link state's modification to construct spanning trees. to calculate the spanning trees for multicasting, you also have to know which nodes belong to which groups. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0080q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1)temporarily valid tsaps\nadvantage: easy to implement\ndisadvantage: doesn't work for connections that use a static and known tsap.(server addressing)\n\n\n2)identifying the connections individually with seqno\nadvantage: each connection gets its own seqno making it unique and easily idnetifiable.\ndisadvantage: the end systems has to remember already assigned seqno.\n\n\n\n3)identifying the packets individually with seqno\nadvantage: makes it easy to identify duplicates, as each packet has its own seqno.\ndisadvantage: requires a lot of bandwidth and memory.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0085q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps\nadv:simple\ndisadv:may cause some comflict with some \"well-known\" tsaps\n\n2. to identify connections individually\nadv: reliable\ndisadv: end systems must be able to store seqnos\n\n3. to identify pdus individually: individual seq num for each pdu\nadv: higher usage of bandwidth and memory\ndisadv: higher cost",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0328q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the connection has to be duplex and both sides have to have data to send (otherwise the frame is 0 characters + the acknowledgement, which would just be a confirmation and no piggybacking).",
        "answer_feedback": "the response answers the underlying requirement correctly. instead of sending the whole frame with no data, a separate acknowledgment can also be sent after a timeout.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0327q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "need to know the initial sequence number, aswell as the next sequence number and acknowledgement.",
        "answer_feedback": "the response is incorrect as the above points are not specific to piggybacking but hold for the sliding window protocol in general.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0220q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding and reverse path broadcast are used in broadcasting, to enable loop-free by verifying the reachability of the destination. that way each is will know its multicast tree rpf :  algorithm : check if the packet that arrived at the is entry port over which the packets for this source are usually also sent. if yes, an assumption can be made that the packet used the best route. then the packets will be resent over other edges (not including the incoming one) if no, assume the packet did not use the best route. then this packet will be discarded. rpb : algorithm :  check if the packet that arrived at the is entry port over which the packets fort this source are usually also sent. if yes, check if the packet used the best route. * if yes, select the edge at which the packets arrived and from which they are then rerouted to the source * if no, do not send over all the edges (without the incoming one) if no, the packet is discarded.",
        "answer_feedback": "the response correctly explains rpf and rpb and their purpose.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0047q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "we expect the system to be in a state where there are less than 10 packets in the queue roughly 57 seconds of the 1 minute we observe.\nfirst we need to calculate the mean load of the system (ro) as 9/10 as we can serve 10 packets while 9 arrive per sec.\nthen we can use the formulas from the lecture to compute with what percentage the system is in the state where 10 packets are waiting in the queue. \nthis is roughly 5% of the time, which means there are 10 packets waiting roughly 3 seconds of our observed minute.\nwhich means there are less than 10 packets waiting ~57 seconds of our minute.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0366q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0 to 127.255.255.255",
        "answer_feedback": "not all addresses in class a are reserved",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0020q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding.\n1.all users have perfect clocks, so good \"self-clocking\" feature is not necessary.\n2.it is mentioned that all users generate more traffic than the link’s capacities. but the utilization of the bandwidth of manchester encoding or differential manchester encoding is 0.5 bit/baud, only half of the utilization of binary encoding.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0084q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1) use a unique tsap from the beginning till the end of the connection\n+ ensures there won't be problem with misinterpreting connections at the same port\n- requires large name size of tsap\n- practically impossible, because there exist \"well-known\" tsap that exist always\n\n2) define unique connection sequence number, with end systems also remembering previous sequence numbers\n+ by remembering the previous connections too, the end systems can differentiate all the incoming data\n- can't work easily for connectionless services\n- end systems need enough space for storing this information\n\n3) use sequence numbers for packets\n+ you don't need to get bothered for resetting the sequence numbers, because for example (also stated in the lecture), a 48 bit number will practically never reach to an end\n- however, the bandwidth and the memory you need to send a packet gets increased, because the sequence numbers never get reset and need a number with many digits (e.g. 48 bits)",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0372q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "for each of the 2^7 = 128 networks the first and the last address are reserved.\n- network address (all zeros)\n- broadcast address (all ones)",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0145q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service (ucs), confirmed connectionless service (ccs) and connection-oriented service (cos). ucs doesn’t have correction mechanism and flow control. the data probably gets lost. ccs reply ack when receiving the correct data and it has timeout-and-retransmit mechanism. it is more reliable than ccs but probably incurs some sequence errors. cos has connection and disconnection mechanism. it can achieve flow control, no loss and no sequencing error.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0043q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "p = 9/10 = 0.9\nthe expected number of customers in the system are p/1-p = 0.9/0.1 = 9. i expect that the queue always has less than 10 packets waiting in it.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the spanning tree algorithm determines the packets for the broad and multicasting while the link state packets will be sent, the containing information will be expanded by information on multicast groups - every is calculate now its multicast tree",
        "answer_feedback": "though it is correct that a spanning tree determines the path in multi-/broadcast, it does not answer why they are used. the reason is no loops in the spanning tree leading to reduced unnecessary duplicates.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0042q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first we need to calculate the utilization. in this scenario the utilization is quite high with 90%. however we want to know the time that the buffer has less than 10 entries. this means that not the case if the buffer is full. we can calculate probability for that using the above-mentioned utilization. the probability is about 5%. so it’s likely that the system will most likely have the full minute less than 10 packets.",
        "answer_feedback": "the response is partially correct because calculating the probability when the buffer is full is correct. however, it lacks the step where the probability is multiplied with the time to get the expected number of seconds, that is 56.9512 seconds.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0186q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, it is not true for real time internet traffic. the arrivals of packet is not independent on time interval as while loading or streaming something the next video is loaded automatically if the previous video is about to end.eg. youtube,netflix etc.. this proves that it is not independent of the time interval.",
        "answer_feedback": "the response correctly associates the probability of arrivals at a node with previous arrivals. however, the example given does not illustrate this well because the next video's auto-load can be turned off in the application setting. a better example would be on-demand video streaming in general, as the traffic is bursty depending on the segment loading.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0373q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "xxx.xxx.xxx.0\n\nxxx.xxx.xxx.255",
        "answer_feedback": "missing: loopbacknetwork and broadcast are x.0.0.0 and x.255.255.255 with x between 0 and 127",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0036q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i would use binary encoding, since the premise is that all users have perfect clocks. this makes the \"self-clocking\" feature of the other two encoding methods not necessary. binary encoding also makes good utilization of the bandwidth (1bit per baud) which is good, since the 3 users generate lots of traffic.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0161q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "distributed queue dual buses have a fairness problem, meaning that dependent on the position of the node it will be advantaged or disadvantaged for certain comunications, as each bus only works in one direction and frames have to be requested.",
        "answer_feedback": "the response correctly states the problem in dqdb and gives an appropriate reason for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0169q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "udp: header consists of three mandatory and one optional header.\nsource-port, destination-port, packet length are mandatory, checksum is optional and just calculated for the header\n\ntcp: the checksum is calculated over header and user data, to ensure correct transmission.\nto ensure reliablity, the tcp-header has additionally fields for a sequence number, the acknowledgement number and certain flags to reduce/avoid congestion and enable flow control.\n\nthe tcp header is more complex but ensures reliable transmission at the cost of speed and use of bandwidth.\nthe udp header just contains necessary information, is very fast but unreliable.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0374q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.x.x.x -> network address\n127.x.x.x -> loopback\n(x.0.0.0 -> gateway in all types of network)\n(x.255.255.255 -> broadcast in all types of network)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0368q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "ip ranges:\n0.0.0.0 - 0.255.255.255\n127.0.0.0 - 127.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0228q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a spanning tree consists of a loop free topology including all nodes with minimum number of possible edges. it finds a minimal subnet and enables the network to minimize duplicates and reduce traffic. modification of link state routing: the link state packet which contains information about the distance to neighbors can be enhanced by adding information on multicast groups. as the link state packets are broadcasted to all other nodes, every node is able to calculate a local multicast tree due to the fact that all nodes have the complete state information locally available.  based on the multicast tree a node decides on which outgoing links a packet has to be forwarded.",
        "answer_feedback": "the response correctly identifies the spanning-tree property that makes it appealing for broadcast and multicast and how the link-state algorithm is modified to construct a  multicast spanning tree.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0027q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i would use binary encoding. it is efficient since it uses 1 bit per baud. it has no self-clocking feature but that is not needed since all user have perfect clocks.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0229q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning tree is known to the is as, generates a minimum number of packet copies , that is generates a copy of a packet for each required outgoing line and all spanning tree lines except incoming one have to be defined. it has to know the multicast basic principle, that all is have to know the multicast tree. so all is nodes send link state packets periodically.  the is defines the outgoing lines and which packets have to be transmitted.",
        "answer_feedback": "while it is correct that a spanning-tree generates minimum copies of the message, it is not clear from the answer what the response meant by \"is generates copy for each outgoing and spanning tree line\". the link-state modification for constructing spanning trees does not explain how each node shares its multicast information with others by adding it to the link state packet.  each node then has the complete information to build a multicast spanning tree.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0148q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service: no flow control\nconfirmed connectionless service: no flow control, duplication and sequencing error may happen\nconnection-oriented service: flow control, no loss, no duplication, no sequencing error",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0225q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "the purpose is to reduce that overall network usage, and not produce unneeded traffic. you only send out the gotten packet if it came from a router you would route through to the sender, otherwise the packet gets droped as it can not be the optimal path.",
        "answer_feedback": "while both algorithms reduce traffic, the main purpose is to minimize duplicate packets during broadcasting. also, it's unclear to which algorithm the given description is explaining.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0065q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(a, b, forward)(a, c, forward)(a, d, drop) // c and f do both not send packets to a over d hop 2:(b, e, forward)(c, f, drop) // e and g do both not send packets to a over d hop 3:(e, g, forward)hop 4:(g, h, drop) // no destination other than g is left for h",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0140q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "\"uncomfirmed conn.less service\", \"confirmed conn.less service\", \"connection-oriented service\"\n\"uncomfirmed conn.less service\":\ndata is just send, without any feedback, that it is received. both partys assume that no bit is missing. there is no flow control or a connect and disconnect feature. this way of sending data is only used on l1 communication channels with very low error rate.\n\n\"confirmed conn.less service\":\neverytime data is send, the receiver sends an ack flag, that he received it. if he doesnt send an ack flag in a given time frame, the transmission times out and the data is retransmitted. there also is no flow control or a connect and disconnect feature, duplicates and sequence errors can happen because of a retransmission. this service is used on l1 communication channels with high error rate.\n\n\"connection-oriented service\":\n3-phased communication: 1. connection(initializing the counters/variables of the sender and receiver) 2. data transfer 3. disconnect. the data sent in setp two of this class is bidirectional, sequentiell and acknowledged, which means no data loss, no duplicates and no errors.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0359q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "10.0.0.0 - 10.255.255.255172.16.0.0 - 172.31.255.255127.0.0.0 - 127.255.255.255",
        "answer_feedback": "172.x.y.z is not in class a anymore",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0329q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "both sides must send data to use piggybacking to be able to attach acks to data frames otherwise the sender will assume a frame loss.",
        "answer_feedback": "the response is incorrect as there will not always be data to send, in such cases a dedicated timer timeout is used to signal the absence of sufficient data and trigger the sending of separate acknowledgment.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0143q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service: you send data without a steady connection and without any feedback if the data arrived and if it arrived correctly.\n\nconfirmed connectionless service: you do not use a steady connection between sender and receiver, but you get a feedback whenever data is received.\n\nconnection-oriented service: you use a steady connection between sender and receiver. each transmission process consists of 3 phases, at first you establish a connection then you send the data and at the end you disconnect.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0274q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter will be reduced by the factor of 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0364q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "network addresses:    [0-127].0.0.0\nbroadcast addresses: [0-127].255.255.255",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0362q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "127.x.x.x (127.0.0.0～127.255.255.255)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0072q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1: \n(a, b, forward)(a, c, forward)(a, d, forward)\nhop 2:\n(b, c, dropped) c would not send packets to a via b, costs 4, direct path to b costs 2(b, e, forward)(c, b, dropped) same reason as before(c, d, dropped) c would not send packets to a via d, costs 4, direct path to d costs 2(c, e, dropped) e would send packet via b(c, f, forward)(d, c, dropped) same reason as (c, d)(d, f, dropped) f would send packet via c, costs of 1 instead of 3\nhop 3:\n(e, f, dropped) e would send packet via b, costs of 1 instead of 2 (over f and c)(e, g, forward)(f, e, dropped) same reason as before(f, g, dropped) g would send packet via e, because costs of 1 instead of 2\nhop 4:\n(g, h, forward)",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0067q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\n\nhop 2:\n(b, c, drop), c hat das paket bereits empfangen.\n(b, e, forward)\n(c, b, drop), b hat das paket bereits empfangen.\n(c, d, drop), d hat das paket bereits empfangen.\n(c, e, drop), e bekommt pakete von a normalerweise über b.\n(c, f, forward)\n(d, c, drop), c hat das paket bereits empfangen.\n(d, f, drop), f bekommt pakete von a normalerweise über c.\n\nhop 3:\n(e, c, drop), c hat das paket bereits empfangen.\n(e, f, drop), f hat das paket bereits empfangen.\n(e, g, forward)\n(f, d, drop), d hat das paket bereits empfangen.\n(f, e, drop), e hat das paket bereits empfangen.\n(f, g, drop), g bekommt pakete von a normalerweise über e.\n\nhop 4:\n(g, f, drop), f hat das paket bereits empfangen.\n(g, h, drop) h hat keine nachbar, an die das paket weitergereicht werden kann.",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop)  will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0017q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "because the network has a perfect clock, we don't need an encoding technique with the self-clocking feature.\nbecause the network is often congested we need a good utilization of the bandwidth (1 bit per baud).",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0279q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter will shrink, exactly by the same factor value we increase the speed of transmission.\n\ni.e .. when we have with transmission rate of 10 mbps and a distance of 3000m, then we gonna have by transmission rate of 100mbps just a distance of 300m between the locations the speed ist possible.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0144q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1.unconfirmed conn.less service\n2.confirmed conn.less service\n3.connection-oriented service\n\ndifferences: \n1.unconfirmed conn.less service and confirmed conn.less service have no flow control. but connection-oriented service has no flow control.\n2.confirmed conn.less service and confirmed conn.less service have no connect or disconnect. but connection-oriented service has connect or disconnect.\n3. connection-oriented service has no loss, no duplication, no sequencing error. but confirmed conn.less service has loss, duplication,sequencing. and unconfirmed conn.less service has more errors than confirmed conn.less service.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0275q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter = 412m, i.e., ca. 300m instead of ca. 3000m",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0071q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop1: \n(a, b, forward)\n(a, c, forward)\n(a, d, drop) // d will receive the packet and won't forward it \n\nhop 2: \n(b, e, forward)\n(c, f, drop) // f will receive the packet and won't forward it \n\nhop 3: \n(e, g, forward)\n\nhop 4: \n(g, h, drop) // h will receive the packet and won't forward it",
        "answer_feedback": "the reason should explain why it is not forwarded, for example, (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a.  for (g,h,drop), it has no other neighbor",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.8
    },
    {
        "id": "smp0356q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "(0.0.0.0/8 depends if 0 is countes as a class a network): current network\n10.0.0.0/8: private networks\n127.0.0.0/8: loopback\n\nquelle: rfc 5735",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0181q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "yes the assumption that time between packet arrivals are independent holds true for real internet traffic. packets transferred between one node to another suffer from various delays such as propagation delay, processing delay, queuing delay, transmission delay etc. each of these are independent of each other. hence the arrival interval of packets which is a function of these delays is also independent.",
        "answer_feedback": "the response is incorrect because the real traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0271q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter decreases by the factor 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0223q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding is an algorithm to allow loop free forwarding of packets (especially for multicast). the source ip of an incoming packet is looked up in the routing table. if the packet would be send on this interface if the source ip would be the destination, the packet is forwarded on all edges but the incoming one. packets that don't arrive via the shortest route may be ignored. reverse path broadcast is also used for loop free forwarding and works similar to rpf. though it does not send the packets out on all edged but selects those edges that are on the shortest path (in reverse) to the source of the multicast packet.",
        "answer_feedback": "the explanation of rpf is partially correct because the packets which did not use the best route will be discarded and not maybe discarded.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "smp0066q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward), (a, c, forward), (a, d, forward)\n\nhop 2:\n(b, e, forward)\n(c ,f, forward)\n\nhop 3:\n(e, g, forward)\n\nhop 4:\n(g, h, forward)",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop) .",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "smp0167q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "udp: sender and receiver port, packet length, checksum, data\ntcp headers are much longer than udp headers. there are some fields in the tcp header, which an udp header doesn't contain:\n- sequence number\n- acknowledge number\n- flags\n- advertised window size\n- options",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0325q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "requirement: the interval of two adjacent frames, which are sent by sender, is short.\nso that we can use piggybacking to response these two frames with one acknowledgement. \nthe communication has to be duplex (so the protocol must not be \"utopia\").\nand the receiving buffer from the sender must be ,so that it is able to store the ack plus the additional data!",
        "answer_feedback": "the response contains a duplex connection as one of the requirements, but having to send two frames within short intervals is incorrect. also, the same data and acknowledgments are tied together in piggybacking. therefore, the total buffer space requirement should ideally remain almost the same as when they are sent separately.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0019q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "recommended encoding technique: binary encoding (nrtz).\nreasons:\n1. of all the encoding techniques presented in the lecture, binary encoding offers the best use of bandwidth (1 bit per baud versus 0.5 bits per baud for (differential) manchester encoding) for the scenario described (heavy link utilization).\n2. since all participants have perfect clocks, there is no risk of clock drift/deviation.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0358q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0/8: current network adresses\n127.0.0.0/8: loopback adresses",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0371q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "all 0 -> 0-127.0.0.0:  network address (or excluding 0.0.0.0 and 127.0.0.0 in respect to reserved addresses according the ietf special-purpose ip address registries from rfc 6890)\nall 1 -> 0-127.255.255.255: broadcast address (or excluding 0.255.255.255 and 127.255.255.255 in respect to reserved addresses according the ietf special-purpose ip address registries from rfc 6890)\nadditionally the following class a network (parts) are reserved according to rfc 6890 https://datatracker.ietf.org/doc/html/rfc6890#section-2.2.2\n127.0.0.0/8 loopback adresses\n10.0.0.0/8 private-use\n0.0.0.0/8   \"this host on this network\"\n100.64.0.0/10 shared address space",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0028q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding can be used. it has the highest bandwidth (1 bit per baud) and is simple and cheap. the 'self-clocking' feature of the more complex manchester encoding and differential manchester encodings is not necessary since the users have perfect clocks.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0224q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding prevents multicast traffic from entering routing loops by looking up a table which holds all routers the multicast packet already visited. the packet is then forwarded to all routers that are not in the table. reverse path broadcast is an extension of rpf: in this case packets are only forwarded to this interfaces, where the next router is on the shortest path to data origin.",
        "answer_feedback": "the response correctly identifies the purpose of rpf but the provided explanation is incorrect. in rpf, the packet used the unicast information stored in the routing table to check whether the broadcasted packet took the same route that it would have taken to send a unicast packet in the reverse direction. no explanation is provided as to what forms the shortest route in rpb.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.4
    },
    {
        "id": "smp0277q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "with a speed increased by a factor of 10, the collision domain diameter does decrease by a factor of 1/10 when using the same minimum packet size (e.g. 64 byte with ethernet). this is because the send does finish much quicker (10 times as quick) while the time the electricity change needs to travel from sender to receiver and backwards remains the same.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0153q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "(1) “unconfirmed connectionless service”: transmission of isolated, independent units (loss of data units possible)\nis a good choice on communication medium with very low error rate\n\n(2) “confirmed connectionless service”: receipt of data units get acknowledged by receiver, therefore no loss, but duplicates and sequence errors may happen due to retransmit if no acknowledgement within a certain time.\nis a good choice on communication medium with high error rate e.g. wireless communication\n\n(3) \"connection-oriented service”: this service has flow control. consists of 3-phases of communication, with connection initialization, data transfer and disconnection. \nis a good choice if bi-directional communication is needed\nand is a good choice for an error free communication medium (therefore no loss, no duplication, no sequencing error)",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0032q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i would suggest to use binary encoding, because they are all interconnected and have perfect clocks, that is why they do not need a self-clocking encoding and it is simple and cheap, so it has a good utilization of the bandwidth ( 1 bit per baud), what helps against congestion.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0164q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "the udp header is a short header (only contains receiver port, packet length and optional sender port, checksum). \nthe header of the tcp is more complicated. additionally to sender port, receiver port and checksum, it has a sequence number (to identify the segment or the starting sequence number). it also has an acknowledgement number (which is needed i.a. for the connection setup). in the tcp header you can also set flags (like fin for the disconnection). you can also add further information in the options field.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers. also, note that the ack field is not just limited to connection setup.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0075q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop 2\n(b, e, forward)\n(c, f, forward)\nhop 3\n(e, g, forward)\nhop 4\n(g, h, forward)",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop) ).",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "smp0049q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "with a buffer of size 10, the probability of less than 10 packets in the queue is the probability that there is any other number of packets in the system than 10. with the utilization being 9 / 10, the probability for this case after reaching equilibrium is 1 - p(10) = 0,9492 (rounded).\nwhen monitoring the system for one minute (60 s), i would therefore expect the system to be in a state with less than 10 waiting packets for 0,9492 * 60 s = 56,952 s",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0150q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service:\n-sends data without establish a connection\n-if data units get lost, didn’t get any feedback\n-no flow control and no disconnect \n\nconfirmed connectionless service:\n-if data units get received, the receiver send an acknowledgement, so no loss\n-if sender does not receive an ack within a certain time, then retransmit, it can lead to duplicates and sequence errors\n-no flow controls\n-didn’t establish a connection or disconnection with the receiver\n\nconnection-oriented service:\n-3-phased communication: 1. establish a connection, 2. transfer data, 3. disconnect\n-flow control, no loss of data units, no duplication and no sequencing error",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0184q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, this assumption of the arrivals being “memoryless” does not hold for real internet traffic. \nif δt = 1ms, for example, that means every of these time intervals has to be considered independent from each other. so in each of these intervals it is a “coin flip” whether data is sent or not. \nobviously this is not true for real internet traffic because while streaming a movie or playing an online game, for example, the arrivals are connected and dependent on each other.",
        "answer_feedback": "the response is correct as it correctly associates the probability of an arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0139q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "- unconfirmed connectionless service \nthe unconfirmed connectionless service sends data to the receiver, without announcing it (building up a connection) first in data frames without any flow control. because of the missing connection and flow control, it is possible that complete data frames can get lost.  \n- confirmed connectionless service \nwheras the confirmed connectionless service sends the data frames and waits for an acknowledgement of the corresponding recipient. if the recipient confirms the data frame, the next data frame is being sent. if the recipient doesn’t answer for a long time, the data frame is being resent. if for some reason, the ackknowledgement gets lost, the recipient will eventually get a data frame twice, and will not be able to detect the duplication. the correction has to be made on a higher level. it is much slower than the unconfirmed, because of waittime for timeouts and ackknowledgement messages. \n- connection oriented service \nin the connection oriented service, the overhead is a lot higher, but the advantages are a detailed flow control, in which the recipient can detect duplicates, ask for a certain frame and can align the frames in the right order. and if the recipient reads slower than the sender transmit, it is possible to make a transmission. the participants first exchange a handshake and afterwards are transferring data. afterwards the connection is disconnected.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0083q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "temporarily valid tsaps\nidentify connections individually\nidentify pdus individually\npros\ntsap valid for one connection only\neach individual connection is assigned a new seqno and endsystems remember already assigned seqno\nseqno never gets reset\ncons\nserver is reached via a designated/known tsap\nendsystems must be capable of storing this information\nhigher usage of bandwidth and memory",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0175q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "a udp header has a length of 8 bytes whereas a tcp header has a length of 20 bytes. a udp header has a field for the packet length, unlike a tcp header. a udp header doesn’t contain a sequence number, while a tcp header does. a udp header neither contains an acknowledgement number but a tcp header has an extra field for that.",
        "answer_feedback": "the response correctly identifies and states the four differences between tcp and udp headers except that the tcp header can be between 20 and 60 bytes long.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0267q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter will shrink with the same factor,so when the original speed is 10mb/s and the collision domain diameter is 3km, an increase of the speed by the factor 10 to 100mb/s will decrease the collision domain diameter to 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0149q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "here are the 3 service classes the data link layer offers: \n\n1) unconfirmed connectionless service: there is no \"connect and disconnect\" between sender and receiver. there is no flow control or error management\n\n2) confirmed connectionless service: there is no \"connect and disconnect\", there is no flow control but there is an acknowledgment for each frame sent. \n\n3) connection oriented service: there is a flow control and a \"connect and disconnect\" protocol between the sender and the receiver",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0165q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "some additional features which are present in the tcp header are: sequence number, acknowledgement number, options, urgent pointer and flags (the tcp header contains possible additional information and has protocol specific services). the udp header has a size of 8 bytes, while the size of the tcp header is at least 20 bytes.",
        "answer_feedback": "the response correctly states four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0174q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp-header has the following information in his header that udp not have: \nsequence number (to identify the lost segments and maintain the sequencing in transmission), \nacknowledgment number (to send a verification of received segments and to ask for the next seg-ments), \nurgent (used to point any urgent data in segment), flags, window size (used to set the number of segments that can be sent before waiting for a confirmation from the destination), options",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers. however, there is a slight correction of urgent pointer instead of urgent.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0276q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the sender must still be able to detect collisions during simultaneous transmission and must also not exceed the maximum network extension. the collision domain diameter for 100 mb/s is 10 times smaller than for 10 mb/s if you use csma/cd => 3000m to 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0278q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "it is divided by the same factor of 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0038q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "a binary encoding would be most beneficial. since all clients have perfect clocks, it doesn't need a self clocking feature as used by manchester encoding and differential manchester encoding. it also can transmit a double of the data, effectively increasing the channels capacity",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0331q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "a receiver of a data frame has to send data frames the acks are piggybacked onto at a rate that is high enough so that the sender doesn't have to wait for too long for the acks to arrive. otherwise a timeout might occur and the sender sends the frame again.",
        "answer_feedback": "the response states duplex communication indirectly but a dedicated timer timeout can also be on the receiver side to send acknowledgment separately when sufficient data is not present.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0360q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 to 0.255.255.255: current network\n127.0.0.0 to 127.255.255.255: loopback adresses",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0088q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "unique tsap for each connection:\n + addresses duplicated across connections (e.g. after a crash) - usually limited number of tsaps - some tsaps are well known and therefore not usable (e.g. for http)- doesn't address duplicates within the same connection\n\nsequence number for each connection:\n + solves problems specific to unique tsaps - but also doesn't address duplicates within one connection - endsystems need to store sequence numbers, even after switching off\n\nsequence number for each pdu:\n + addresses duplicates between and within connections + only need info about last few used seqnrs - higher usage of bandwidth/memory - have to choose a range for seqnrs",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0365q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "just to note: originally i understood the task to mean reserved addresses within the network (i.e. concerning the host part), but then there was an official statement in the forum that the network part was meant. if it is indeed the host part, then *.0.0.0 and *.255.255.255 would be reserved within each class a network.\nreserved addresses in class a networks:\n0.0.0.0 - 0.255.255.255 (host at this network)10.0.0.0 - 10.255.255.255 (class a private network range)127.0.0.0 - 127.255.255.255 (local host)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0064q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(a, b, forward)(a, c, forward)(a, d, forward)\n\n\n\n\nhop 2:(b, e, forward) (b, c, drop) <= a->c is shorter\n\n(c, b, drop) <= a->b is shorter\n\n(c, e, drop) <= a->b->e is shorter\n(c, f, forward)\n\n(c, d, drop) <= a->d is shorter\n\n(d, c, drop) <= a->c is shorter\n\n(d, f, drop)  <= a->c->f is shorter \nhop 3: \n\n(e, c, drop) <= a->c shorter\n\n(e, f, drop) <= a -> c-> f is shorter\n\n(e, g, forward)\n\n(f, d, drop) => a->d is shorter\n\n(f, e, drop) => a -> b-> e is shorter\n\n(f, g, drop) => a -> b -> e -> g is shorter \nhop 4:\n\n(g, f, drop) => a->c->f is shorter\n\n(g, h, forward)",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0369q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "127.0.0.0~127.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0192q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "table holds infromation that a certain address can be reached by a certain lan. during backwards learning the bridge updates its table by the incoming traffic knowing that the source of the received packet is reachable over the lan form where the packet came. look if the address is in the table if yes then send it to the lan over which it is reachable if not use flooding. no longer need to flood if the path is known. another one would be that it is a rather simple approach.",
        "answer_feedback": "the response answers all the four requirements of the question correctly. also note that if the source and destination lan is the same, the packet is dropped.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0326q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "there must also be frames directed towards a (sender) in the transmission, so that b (receiver) sends frames back to a in a reasonable amount of time. in addition to that the amount of frames size of both parties must be similarly big, because the acknowledgement is added to frames directed at a. as a result there must be a certain balance of frames in both directions.",
        "answer_feedback": "the response correctly implies duplex operation. however, a balanced approach is difficult to achieve in real scenarios, so there are ways to overcome it, like a dedicated timer signaling a timeout in the absence of data to be sent.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0183q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no this assumption does not hold for real internet traffic. internet traffic is often very bursty, e.g. if we load a website we need to load a lot of resources at once, while we won't load nearly as much if we just look at the website. this means the probability that traffic arrives, if traffic arrived in the previous interval is greater than if there was no traffic in the previous interval.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0367q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "ip : 0.0.0.0\nip range: 127.0.0.1 to 127.255.255.255 are network testing addresses (also referred to as loop-back addresses)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0147q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "the three classes:\n\nunconfirmed connectionless service\n-transmits isolated independent units\n-data units may be lost\n-no flow control\n-no connecting or disconnecting\n\nconfirmed connectionless service\n-transmits independent data units \n-receiver acknowledges the reception of each single frame\n-timeout + retransmission if sender does not receive acknowledgment within a certain amount of time \n-thereby no loss of data, but duplicates and sequence errors may occur\n-no flow control\n-no connecting or disconnecting  \n\nconnection-orientated service \n-transmits data over error free channel (through acknowledgments)\n-no loss of data, no duplications, no sequencing errors\n-flow control\n-3-phased communication: connect, data transfer, disconnect",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0227q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "property: global knowledge of the multicast group’s spanning tree (multicast tree)  initially only local knowledge   all is send link state packets periodically  -containing information     distance to neighbors     expanded by information on multicast groups -by broadcast to all the others each is calculates a multicast tree -from the now locally available and complete state information based on the information about the multicast tree - is determines the outgoing lines - on which packets have to be transmitted",
        "answer_feedback": "the response is partially correct because it lacks the attractive property of spanning trees.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0176q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "it’s not realistic, because in the real-world the high traffic in the internet depends often on the day and the time of the day. for example, weekend or holiday and morning, afternoon or evening. so, it can be that in the morning there are many zeros in the time slots and the evening there much ones, because for example everyone is watching netflix in the end of working day or is doing some other internet things. so there can be more than one on’s in time interval delta t.",
        "answer_feedback": "one can use a function instead of a constant to model the arrival rate to reflect such large-scale behavioral patterns like having more traffic in the evening. the arrivals would not depend on previous arrivals then, only on the time of the day, which is known. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0370q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0-0.255.255.255\n10.0.0.0-10.255.255.255,\n100.64.0.0-100.127.255.255\n127.0.0.0-127.255.255.255,",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0076q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop) <= there is no edge over which it is the best route to send packets over d to a\n\nhop 2:\n(b, e, forward)\n(c, f, drop) <= there is no edge over which it is the best route to send packets over f to a\n\nhop 3:\n(e, g, foward)\n\nhop 4:\n(g, h, drop) <= h does not have any other neighbor to send the packet to",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0155q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem with dqdb is that if we have several participants in the network and they want to exchange data, the distance between them and the propagation delay causes a fairness issue. this is because when stations are closer together, they can communicate over the bus faster than stations further away, this would still be acceptable for normal data packets, but network control packets are also sent over the bus and so network changes can spread much slower than in other architectures.",
        "answer_feedback": "the response correctly states the fairness issue in dqdb and also provides an appropriate reason for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0151q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "the three classes: \nunconfirmed connectionless service\nconfirmed connectionless service\nconnection oriented service\n\nin unconfirmed connectionless no confirmation of data transmitted is received, loss of data units is possible and also no flow control is present.\nin confirmed connectionless  acknowledgement of data transmitted is received, no loss of data units because of retransfer and timeout mechanisms and also no flow control is present.\nin connection oriented data is transferred over an error free channel, no loss of data units possible and flow control is also present,",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0230q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "you use reverse path forwarding with pruning. after the tree is set up the broadcast tree you know who belongs to the multicast. - if all child nodes aren't part of the multicast tree the parent knows it itself isn't part of the multicast tree. (bottom up) you can modify link state routing by not only considering the \"distance\" between neighbors but also information on multicast groups.",
        "answer_feedback": "the desirable property is not because it makes reverse path forwarding possible. instead, it is loopless and thereby reduces duplicates when broadcast- and multicasting. we do need to add the information to which group each is belongs to in the link-state packet but it is not stated how it is propagated and used to construct the multicast spanning tree.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0046q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "λ = 9     less than equal to packets arriving per second\nµ = 10   less than equal to packets served per second\nn = 10   less than equal to buffer size\n\n=> ρ = 9/10\n\nthe probability that there less than 10 packets in the system is e(n less than 10).\n\ne(n less than 10) = 1- e(10) = 1 - blocking probability\n= 1 - 0.457324\n= 0.954276\n\nso in 60 seconds, there are less than 10 packets in the queue for e(n less than 10) * 60 = 57.2561 seconds.",
        "answer_feedback": "the steps stated are correct but the obtained blocking probability and the final time are not correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0141q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. unconfirmed connectionless service \n2. confirmed connectionless service\n3. connection-oriented service \n\nin the 1. service, transmission of the data happens isolated and independent. a loss of data is possible. \nwith service 2. if the receiver do not answer, the data is retransmit after a certain time, so there are no loss. in both is no connection or disconnection. \nin the 3. service, first a connection is initialized, data is transfered and then the connection is abort.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0152q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "the 3 service classes are: unconfirmed connectionless service (1), confirmed connectionless service (2) and connection-oriented service (3). the main difference between this services is the handling of the loss. while in (1) data packets are only send to the receiver, packets can get lost and loss is not being corrected. in service (2) data packets has to be acknowledged by the receiver and packets will be resend after a certain timeout. this leads to inefficient communication and can be done on a higher level. service (3) consists of 3 phases (connection establishment, data transfer, disconnect). just like in service (2) we have no loss, but flow control is possible in contrast to services (2) and (1).",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0233q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the advantage of using a spanning tree for broad-/multicasting is that no duplicate messages are sent. this reduces network load while providing the exact same performance, only at the cost of lower reliability. if we want to construct a spanning tree using link state routing, each node, after having received the link state packets from all other nodes, calculates a spanning tree using the received information. the node will then use the connections from the calculated spanning tree to distribute multicast packets efficiently.",
        "answer_feedback": "the response correctly answers why a spanning-tree usage is ideal in multicast and broadcast. the explanation for modifying the link-state algorithm to construct a  multicast spanning tree for nodes does not state how a node gets to know about the other members of the multicast group and how this information is propagated to other is.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0024q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding should be used in this network because all three end systems have perfect clocks wherefore a self-clock feature isn't necessary. it also provides better utilization of the bandwidth than manchester encoding or differential manchester encoding.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0026q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "bianry encoding, since it has good utilization of bandwidth which could solve the traffic problem. on the other hand, the 3 users have already perfect clocks, the no \"self-clocking\" feature of binary coding could be neglected.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0355q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "class a contains all ip addresses with first octet from 0 to 127 (ip address format is octet1.octet2.octet3.octet4)\n\naccording to slide 45 of internet protocols:\naddresses in range 127.0.0.0 to 127.255.255.255 are reserved, because they are used for loopback testing.\naddresses in range 0.0.0.0 to 0.255.255.255 are reserved, because they refer to hosts of the current network.\n\n(so, excluding these 2 groups, each network with starting octet x, 0<x<127 of class a has address x.0.0.0 for the network, x.255.255.255 for broadcasting and the rest addresses between these 2 for hosts).",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0078q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. tsaps\nad: tsaps only  for one connection \ndis: process server addressing method not possible\n\n2.identify connections individually\nad:each individual connection has a new seq\ndis: end system will be switched off\n\n3. identify pdus individually\nad: seq never gets reset\ndis:higher usage of bandwidth and memory",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0035q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "since we want to transmit with as high of a baud rate as possible we first look at binary encoding. for binary encoding we need perfectly synchronous clocks. since all our users have perfect clocks, binary encoding is better, since the baud rate is twice as high.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0178q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption does not hold true for the internet as when someone uses the internet he will continue using it for a certain time and not just have a single request and then nothing for a while. also a lot of traffic is in a burst like nature so some requests until a certain buffer is filled and then again when it is somewhat deplenished. so in general the previous state or states can hold information for future states.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0264q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter is reduced by the same factor, e.g. from 3km to 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0188q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption is a simplification, that makes it easier to work and calculate with. in reality, there is seldomly only one packet is send and then nothing happens afterwards, but communication consists of multiple packets. therefore, if there is one packet, then it is very propable, that there will be a lot following packets. i.e. if someone is streaming in the afternoon and causing a number of packets, the propability of the packets will concentrate on one timeframe. and this (and the behaviour of the other participants) causes the propability for a larger timeframe like the morning to be different then in the evening.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0160q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem that was discussed in the lecture is fairness. the nodes reserve slots on one bus and send on the other bus. one node might reserve a lot of the available slots which makes it hard for the following nodes to reserve the space they need.",
        "answer_feedback": "the response correctly identifies the problem associated with distributed queue dual buses based on the station location.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0041q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "we expect the system to be in a state with less than 10 packets in the queue for 56.94s during the measured interval of one minute. \nfirst we calculated the utilization: (9pkt/s)/(10pkt/s) = 0.9\nthen, we calculated the probability for the system to be in state 10, i.e. the probability that the system is full. p_10=((1-0.9)*0.9^10)/(1-0.9^11) = 0.051\nnext, we calculated the counter probability of p_10 as we actually want to know with which probability the system is not in state 10. 1-p_10 = 1-0.051 = 0.949\nto get the number of seconds the system is not in state 10, we calculated 60s * 0.949 = 56.94s as we measure the system for 60 seconds.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0073q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a,c,forward)(a,b,forward)(a,d,forward)\nhop 2:\n(b,e,forward)(c,f,forward)\nhop 3:\n(e,g,forward)\nhop 4:\n(g,h,drop) => dropped because the package arrived from the port with shortest path to s but there is no other port to forward the package to.",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.5 for reasoning (a,d, drop), (c, f, drop) ).",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.8
    },
    {
        "id": "smp0079q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps\nmethod: tsap only valid for one conntection, generates always a new tsap\nadvantage: complete unique connection\ndisadvantage: too many connections will be generated in worst case, in general not always applicable\n\n\n2. to identify connections individually\nmethod: each individual connection is assigned a new seqno\nadvantage: each connection relies on seqno and will be remembered from endsystems because of the assigned seqno\ndisadvantage: endsystem must be capable of storing this information\n\n\n3. to identify pdus individually\nmethod: individual sequential numbers for each pdu, seqno basically never gets reset\nadvantage: packets have a \"lifetime\" within the network\ndisadvantage: higher usage of bandwith and memory",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0168q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "udp-headers include:\n- source port\n- destination port\n- packet length\n- (optional to use) checksum\neach of the fields is 16 bit long (in sum 8 bytes). udp does not need much header-informations, since its a fast, connectionless protocol.\n\ntcp-headers also include a checksum, source and destination port, but also much more information, like:\n- a sequence number\n- an acknowledgement number\n- different control flags\n- the data offset\n- the window size\n- an urgent pointer\nthe much larger (min. 20 byte) header is needed since tcp is a connection-oriented protocol, which sets more on reliability than speed.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0158q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the distributed queue dual bus (dqdb) architecture uses two unidirectional buses for sending and receiving data. the main challenge here ist to guarentee fairness between all participating nodes as different nodes may have advantages (if at the beginning of the bus) or disadvantages (if at the end of the bus) in write access depending on their position in the bus.",
        "answer_feedback": "the response correctly states and explains the fairness problem of reserving transmission right in dqdb.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0226q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "in both,packet used the best route with specific selection of the outgoing links. reverse path forwarding:packet used the best route and resend over all adjacent edges (not including the incoming one). reverse path broadcast:packet uses the best route and sends packet to adjacent nodes but select the edge at which the packets arrived and from which they are then rerouted to source in reversed direction and include the arrival node.",
        "answer_feedback": "the response explains the difference between the two correctly. the response does not state the purpose behind using the algorithms, namely to reduce duplicates in the broadcast. while both use the best route, how these routes are known is not explained.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.4
    },
    {
        "id": "smp0029q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i would use the binary encoding in this network. the \"self-clocking\" feature of the manchester encoding isn't an advantage in this scenario since all users have perfect clocks. therefore the perfect clocks can even out the binary encoding's disadvantage of not having a \"self-clocking\" feature and only the advantages of being cheap, simple and the good utilization of the bandwidth remain.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0087q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps.\n pro: sure would solve the duplicate problem\n contra: some servers should be reached through a known tsap, which should not be discarded after single usage.\n2.to identify connections individually\npro: better than temporarily valid tsaps, at least can be used to solve duplicate problem in a connection-oriented system.\ncontra: in a connection-less system it does not work.\n3.to identify packets individually\npro:solve the duplicate problem with dexterity, man can choose the sequence number range for individual case.\ncontra: the usage of bandwidth and memory will be higher due to the packet sequence number.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0187q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption does not hold for real internet traffic. real traffic is for example dependent on the daytime. furthermore the application is relevant. some might use bursty traffic.",
        "answer_feedback": "the response is partially correct because the arrival process' parameters can be time-dependent. in this way, the arrival rate wouldn't depend on the previous arrivals, but instead on the time of the day.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0268q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter have to shrink (divided by 10)",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0048q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the system reaches equilibrium when the arriving packet rate is the same as the serving packet rate.\nthe system will never reach equilibrium because the arriving packet rate is less than the serving packet rate, thus the packets in the queue will always be less than 10 packets.",
        "answer_feedback": "the response states that the system will never reach equilibrium, but it is stated in the question as an assumption already. also, the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. instead of 60 seconds, the buffer is less than full for 56.9512 seconds on average.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0196q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table contains mappings of station to the output line that has to be used to reach the station. the bridge uses promiscuous mode to observe the sent frames and if a frame from a specific source station is sent over a connected lan the bridge knows that this station can be reached over that lan and the bridge table is updated. in the forwarding process the destination is looked up in the bridge table and the frame is rerouted to the correct output lan, if it differs from the current lan. if the station is not found, flooding is used. a benefit of this setup is that the stations can transparently reach other stations in a different network like they were in the same.",
        "answer_feedback": "the stated benefit is related to transparent bridges in general, but the question asked for the benefit of using bridge table information during forwarding, which is reducing duplicates. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0217q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding and reverse path broadcasting are both algorithms used for loop-free multi- and broadcast communication and therefore aim to be more efficient than simple attempts like flooding or individual sending of packets to every destination in the network. the idea of both algorithms is the use of so called “spanning trees” for each individual node in the network, which contain routes to every subnode in every subnetwork. since one intermediary system does only know his own spanning tree, but not the ones of the surrounding nodes, each router has to use its knowledge of optimal routing for certain destinations as a criterion for further transmission. for reverse path forwarding this means, that each node has to check the link on which an incoming packet is received. if this link is the optimal one, over which packets for this station are also usually sent, then node can assume that the packet has taken an optimal way up to it. as a consequence, it then re-sends the packet over all of its edges, but not the one on which the packet was received. if the packet on the other hand does not come over such an “optimal” link it gets discarded.  since re-sending over all edges seems not to be the most efficient way of multicast-routing, reverse path broadcast introduces a further check for packets that arrive over the optimal link as well as a limited re-transmission of packets: if a packet has taken the optimal path until this station, the station reroutes the packet over the optimal incoming link to the source in reversed direction. this means, that the receiving node looks up in its routing table over which link such a packet would normally be received. exactly this link is then used for rerouting the packet to the source instead of using all links as it is done before in reverse path forwarding. otherwise (so to say if the packet is not received on an optimal link or received on an optimal link, but has not taken an optimal path so far), the packet is not resent. this mechanism is implemented to limit the number of duplicates in the network - while reverse path forwarding retransmits over all edges (excluding the one on which the packet was received), reverse path broadcasting chooses the most suitable link for retransmission.",
        "answer_feedback": "the response correctly explains rpf and rpb and their purpose.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0197q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "this bridge table has mac addresses and ports of bridge in it. at the very beginning, the table is empty, then for example, bridge sees that a frame on port 1 coming from source address a, it knows that a must be reachable via port 1, then it makes an entry in its table.\n\nbridge receives a frame, then it looks up the corresponding destination on its table, if the destination is found, and source address and the destination is identical, the frame would be dropped, if not identical, the bridge will forward this frame to its destination. but if the destination is not found, it will flood.\n\nthis table increases the reliability.",
        "answer_feedback": "the response states reliability as the benefit but it is not mentioned how the table usage increases the reliability. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0191q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table stores the information, which station it can reach over which lan (output line). the bridge works in the promiscuous mode, which means that it receives every frame of each connected lan and during the backwards learning phase when the bridge receives frames with a source address s on a lan l it \"learns\" that s can be reached over l and creates a table entry accordingly. these entries are associated with timestamps and updated when new frames were received from the source (e.g. s). to forward a frame the bridge will look at the source and destination lans and drop the frame if they're identical (and therefore prevent unnecessary traffic) but if they are different the bridge can look up in the table to which lan the frame has to be rerouted. only if the destination is unknown the network will be flooded with the frame. because the bridge is not visible as such for the other components of the network, these other components are simplified and they don't have to deal with the forwarding process.",
        "answer_feedback": "the stated benefit is related to transparent bridges in general, but the question asked for the benefit of using bridge table information during forwarding, which is reducing duplicates. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0180q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, since the real internet traffic is complicated and there are dynamic behaviors of real-world service. for example, real internet tcp traffic has high burstiness and exhibits long range dependence properties at large time-scales. the arrivals for each interval are not independent and there are dependence and correlation of the traffic arrival process in the internet. meanwhile, the real internet traffic has self-similar characteristics, thus, this assumption cannot hold for real internet traffic.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node. take note that the burstiness is more a general nature of internet traffic, not just limited to tcp traffic.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0236q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "property: subnets of subnets can be displayed and addresses which enables more possibilities for multi-/broadcast for distribution of information\n\nmodification of link state routing for spanning tree multicast: \n\n- all is have to know the multicast tree. →which group belonging \n\n- information distribution via link stated routing.\n\n- all is send updates (link state packages) periodically\n\n→calculate the own tree\n\n→determine possibilities for transmission",
        "answer_feedback": "the desirable property is not correctly stated. yes, a spanning tree is a subnet of the subnet, but what makes it unique is that it does not contain loops and thereby reduces unnecessary duplicates during multicast and broadcast. additionally, the link-state packet needs to contain multicast group information so that each node can discover its fellow group member.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0214q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "the reverse path forwarding guarantees that the packet used the best route when this packet arrived at the is entry port. reverse path broadcast is based on rpf  to suitable reduce of overhead. rpf (for a packet arriving at an is)  -has this packet arrived at the is entry port   over which the packets for this station/source are usually also sent?    yes:  -assumption:   packet used the best route until now  -action:     resend over all edges (not including the incoming one)     no:  -assumption:   packet did not use this route (it is not the best route)  -action:     discard packet (most likely duplicate)  rpb: -has this packet arrived at the is entry port   over which the packets for this station/source are usually also sent?    yes:  -packet used the best route until now?    -yes: select the edge at which the packets arrived and from which they are then rerouted to source s (in reversed direction)  -no: do not send over all edges (without the incoming one),  i.e., not as in reverse path forwarding (rpf)     no:  -discard packet (most likely duplicate)",
        "answer_feedback": "the response correctly explains rpf and rpb but it lacks the purpose. the purpose of both algorithms is to minimize the number of duplicate packets during broadcasting.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "smp0068q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop) <= d can't forward packet further because costs would be higher than on other routes\nhop 2:\n(b, e, forward)\n(c, f, drop) <= f can't forward packet further because costs would be higher than on other routes\nhop 3:\n(e, g, forward)\nhop 4:\n\n(g, h, drop) <= h can't forward packet further, no further nodes there",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0221q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding: - purpose: reduce traffic in broadcasting compared to flooding. in reverse path forwarding, a sender only sends an incoming packet to all of its adjacent nodes if it has arrived over the edge that is considered to be part of the shortest path between that node and the source. otherwise, the packet is ignored. reverse path broadcasting: - purpose: further reduce traffic compared to reverse path forwarding. in reverse path broadcasting, if a packet has arrived over the edge which is usually used for sending packets to the source, it is only forwarded to those neighbors, which usually route unicast messages to the sender via that node. so a router only spreads packets to a neighbor if it is on the shortest path between that neighbor and the source.",
        "answer_feedback": "the response correctly answers all three parts of the question. however, the purpose of minimizing the number of duplicate packets in the network is not explicitly stated in the response.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0157q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem with the “distributed queue dual buses” is that it does not ensure fairness. the location of the node has an influence on its likelihood of gaining access to the data or acquiring the right to send, which results in an inequality between the nodes.\n\nat the beginning of a bus all frames generated by the frame generator are empty. so the first node can reserve however many frames it wants. at the end of the bus it can happen that all frames are already reserved so the last nodes may not be able to send anything.",
        "answer_feedback": "the response is correct as it correctly explains the fairness problem with distributed queue dual buses.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0037q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "in this local network with 3 users, the encoding technique binary encoding should be used.\nthis technique is simple, cheap, and has a good utilization of the bandwidth. the disadvantage of the no \"self-clocking\" feature is compensated through the fact that the users have perfect clocks.\nin contrast, the manchester and differential manchester encoding have a worse utilization of the bandwidth  (0.5 bit/baud) than binary encoding (1 bit/baud) and the \"self-clocking\" feature is unnecessary in this case.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0170q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "udp headers do not include the followings: 1. sequence number 2. acknowledgement number 3. hl/resv/flags 4. advertised window 5. urgent pointer",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers. however, the terms hl and resv should be properly named.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0030q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "because all users have a perfect clock, the binary encoding is best to be used. it is simple, cheap and the bandwith is with 1 bit/baud well utilized. (the manchester encodings in comparison have only 0.5 bit/baud.)",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0323q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirement that has to be met that you can use the piggybacking extension to the sliding window protocol is, that we need the ack field in the frame header that costs only a few bits. a seperate frame would need more costs: ack, header and a checksum.",
        "answer_feedback": "the response is correct, a duplex connection is also required.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0069q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop) because a sends to d, but d doesn't forward anywhere else (neither to c or f, because those nodes are reached over other links)\n\nhop 2:\n(b, e, forward)\n(c, f, drop) because f won't forward the packet anywhere else (f / e / g, because those nodes are )\nhop 3:\n(e, g, forward)\n\nhop 4:\n(g, h, drop) because h is only connected to g and receives the packet from g, so it doesn't need to forward it anywhere else",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0270q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the maximum distance has to shrink by the factor of 10 and the lan also has to get smaller which is not possible or at some point not feasible.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0172q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp has a error control. so the users can be sure, that all packages have been transmitted in the right order.\ntcp has an included flow control, to assure, that the two clients don't get an overflow of packages.\nmulitplexing: in udp you only have on port at the receiver, where to send the data. for tcp you have to, one at each side.\nconnections are established and torn down in tcp, with the three-way-handshake. for udp there is no guarantee the connection is established or closed.",
        "answer_feedback": "the response states general differences between udp and tcp while the question requirement is to identify tcp and udp header differences.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem with dqdb is that there is a difference in fairness depending on the location, as not everyone has the same access to data.",
        "answer_feedback": "the response correctly identifies the fairness issue in dqdb which is due to the location of station.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0215q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding: used for ensuring loop-free forwarding of multicast packets in multicast routing and to help prevent ip address spoofing in unicast routing.  checks if the packet arrived at the is entry port over which the packets for this station/source are usually sent. if packet is assumed taking the best route: resend over all edges (not including the incoming one). if packet is assumed not taking the best route: discard packet.  reverse path broadcast: used to check if the set of shortest paths to a node forms a tree that spans the network.  if the packet arrives at the is entry over which the packets for this station/source are usually sent: checks if packet used the best route until now: if yes, select the edge at which the packets arrived and from which they are then rerouted to source. if no, do not send over all edges (without the incoming one). if the packet is not for this station/source: discard packet.",
        "answer_feedback": "the purpose of the rpb algorithm is missing in the response. additionally, the purpose is not limited to unicast and multicast but instead used widely in broadcast too.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.9
    },
    {
        "id": "smp0234q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning trees have the following property, they connect all nodes in a graph with minimum possible edges. since all nodes in the network are addressed by the source node that builds the spanning tree, an is has to generate the minimum number of packet copies to broadcast or multicast to this sub-net. each is initially knows which multicast group it belongs to. this additional multicast information is added to the link state packets that are periodically sent out by the node. once the complete state information is obtained, each is calculates a spanning tree for multicast.",
        "answer_feedback": "the response correctly states the attractive spanning-tree property and explains how the link-state algorithm is modified to construct a  multicast spanning tree.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0034q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "we can use bit encoding - it has a good utilization of the bandwidth, and it can work because the users have perfect clocks. \nanother technique we can use is manchester encoding - is it not sensitive to  מoise on the line and therefore can deal with more users using the line.",
        "answer_feedback": "manchester encoding is not correct as we do not require self-clocking, also bandwidth utilization is less. (note: as per the notification in the quiz slide, an additional  incorrect answer will also be counted while providing grading )",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0154q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "before sending data from node a to node b, a has to reserve a frame in the bus where a comes after b. outer nodes are restricted to sending only in one direction, while nodes in the middle may make reservations in both directions and thus have a higher chance to get a reservation.",
        "answer_feedback": "the response is partially correct as the nodes located close to the generator have a higher chance of getting a reservation rather than the \"middle\" node. so unidirectional or bidirectional alone does not decide fairness.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0177q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption does not hold in real internet traffic. in case of a video streaming service for example the packages are send in big burst. so the arrival of the first package does indicate the arrival of more packages and the more packages are received in a short time the more likely it gets that no more package will arrive for some time because the buffer for the video stream is full and the streaming service stops sending.",
        "answer_feedback": "the response is correct as it associates the probability of a packet arrival happening at a node with previous arrivals at the node. the extent of the probability of receiving a packet after receiving several packets depends on many factors and may differ from client to client.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0039q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding should be used. \nperfeclty clocked users do not need any self-clocking encoding such as manchester.\nmore traffic would benefit from more efficient encoding technique.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0081q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to identify each connection, i.e., each connection is assigned  an unique number and endsystems remember already those number. \npro: + not complicate\ncon: - endsystems need largememory capacity to save this information.\n\n2. to identify pdus individually: assign individual seq number for each pdu.\npro: + higher usage of bandwidth and memory.\ncon: - hard to choose a suitable sequential number range because of different packet rate and the limited lifetime of a packet within the network.\n\n3. to use temporarily valid tsaps\npro: + high availiablity\ncon: - not always applicable , sometimes no possible to address method",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0189q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "yes. because internet traffic can be also modeled as a sequence of arrivals of discrete entities, such as packets, cells, etc. mathematically, this leads to the usage of two equivalent representations: counting processes and interarrival time processes.",
        "answer_feedback": "the correct answer is \"no\". in real internet, the arrival of the packet at a node is affected by previous arrivals.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0272q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "for doing so you have to shrink the maximal distance between two locations.\nin the given example the speed of the network should be increased by factor 10 from 10 mb/s to 100 mb/s. to achieve this without changing everything else, you have to reduce the collision domain diameter by factor 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0040q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "baudot time multiplex system.\n3 users have perfect clocks, so all channels can be processed in a fixed grid within a certain time. each channel is assigned a fixed time window (time slot).the time windows can be synchronized and of the same length or asynchronous and depending on requirements. this is time division multiplex.",
        "answer_feedback": "the question asks for the type of encoding rather the channel access type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0194q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the invisible bridge contains a table which holds information about which address can be reached in which of the connected lans around it. this table is initially empty, but then filled during the process of backward learning - when the bridge receives a packet from a lan l with the sender address a, it can be concluded that a is part of the lan l and therefore routable on this network. as the name clearly states, the bridge in the network is transparent as such, instead it is just addressed with the network receiver address by any senders in one lan, so that it then can use its table to figure out in which destination-lan the package should be sent. so one can conclude that the table prevents flooding from the transparent bridge and therefore unnecessary traffic. the other overall feature of the usage of a transparent bridge is the decreased complexity of transmission for all nodes in the combined lans, because they can just sent packages to all nodes in all connected lans without having to deal with the routing between the lans by itselves.",
        "answer_feedback": "the response does not mention how flooding is done when there is no entry for a packet destination in the table, so flooding can not be prevented completely. apart from that, the response is correct. it also additionally states the benefit of the transparent bridges in general, which was not required.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0216q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "-prevent routing loops/ cycles in the network   rpf: -each node has a route to every other node -each node only forwards a broadcast packet received from the same port used to send packets back towards the sender -so the packet is forwarded only if it comes from the same route that would be used to reply to the source   rpb: -improvement of rpf if the packet arrived at the is entry over which the packets for this station/source s are usually also sent and packet used the best route until, then select the edge at which the packets arrived and from which they are then rerouted to source s in reversed direction, if it’s not the best route then not send over all edges without the incoming one. -if not then discard packet.",
        "answer_feedback": "the response is partially correct as the explanation of rpf incorrectly states that \"each node has a route to every other node\" and also does not state over which links the packet are forwarded in rpf. the purpose and explanation for rpb are correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "smp0273q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter will decrease by a factor of 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0185q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, this assumption will most likely not hold true for real internet traffic. this has multiple reasons:\n\npackets on the internet are grouped into frames for sending, making lone packets being sent separately rather unlikely.  \nthe nature of data transfer on the internet also makes lone packets very unlikely. when making a request for data through the internet (for example loading a web page), the response includes a lot of data (markup, text, images) which are all sent in a short amount of time, and after the page has been loaded the user will most likely spend some time browsing the page before making another request.  \ntherefore we cannot treat arriving packets as independent from one another, because there is a very high chance that an arriving packet is related to the previous packet.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0025q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "they should use \"binary encoding\" because of the perfekt timed clocks and furtermore this mechanism has the best transfer rate (1 bit per baud).",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0193q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table holds the routing entries to forward packets to their destination. the table is initially empty and will be filled with the information of routes during the backwards learning phase. the table entries will be scanned and updated when receiving frames, thus it will adapt to changes in topology, which is a benefit.",
        "answer_feedback": "the response does not state which entries are present that are used for forwarding the packets. the backward learning process does not explain which packet information is inspected and used for building the table. the correct benefit is that there is less traffic because of selective forwarding, not just topological change adaption.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0235q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "property: -no cycles / minimal path / connect only needed path for the transmitting   all is send link state packets periodically, containing information about distance to neighbors and expanded by information on multicast groups and by broadcast to all the others. each is calculates a multicast tree from the now locally available and complete state information. based on the information about the multicast tree is determines the outgoing lines, on which packets have to be transmitted.",
        "answer_feedback": "the response correctly identifies the spanning-tree property that makes it appealing for broadcast and multicast and how the link-state algorithm is modified to construct a  multicast spanning tree.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0173q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "in tcp the ports are at both ends.\nin tcp it has error control, flow control, congestion avoidance while in udp has only checksum.",
        "answer_feedback": "the question requirement is to identify the difference between udp and tcp headers while the response states general differences between udp and tcp.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0022q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "in this scenario, the simple binary encoding technique should be used. that is, because it has the best utilization of the bandwidth among the presented techniques, which is important to use such a congested network as efficiently as possible. furthermore, the downside of the technique not having a self-clocking feature is not a problem here since all users are interconnected and have perfect clocks.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0162q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem with dqdb architecture is that the waiting time for a node to be allowed to send is heavily dependant on its location in the queue.if you are location on any far end of a bus (extrem right  or extrem left) then you will have to wait the most before you can send, if you want to send in the opposite direction.",
        "answer_feedback": "the response correctly explains the fairness problem with distributed queue dual buses.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0146q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1.unconfirmed conn.less service \n features\n   no flow control\n   no connect or disconnect \n 2.confirmed conn.less service\n features\n   no flow control\n   no connect or disconnect\n   duplicates and sequence errors may happen due to “retransmit”\n 3.connection-oriented service\nconnection over error free channel\n  no loss, no duplication, no sequencing error\n   flow control\n3-phased communication\nthey are different in features.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0082q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps,  tsap valid for one connection only,but process server addressing method not possible\n2. to identify connections individually,  each individual connection is assigned a new seqno and endsystems remember already assigned seqno, but endsystems must be capable of storing this information\n3. to identify pdus individually, individual sequential numbers for each pdu, seqno basically never gets reset, but higher usage of bandwidth and memory",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0222q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding (rpf) and reverse path broadcast (rpb) are algorithms that are used to distribute packets with more than one receiver in a network. simple approaches are individual sending to every destination or flooding. these simple approaches aren’t optimal for distributing packets to n receivers. in rpf each router has information which path it would use for unicast packets. if a router receives a package, it checks whether it received the package via the optimal route, and only forwards it to every other reachable router (except from the router it received the package from). in rpb however, packages are only forwarded according to the routing tables (via the best routes), thus reducing the load of the network.",
        "answer_feedback": "the response does not state why rpf and rpb are more optimal than flooding. the explanation for rpf is correct. the explanation for rpb is incomplete as the answer does not specify what \"according to the routing tables\" / \"via the best routes\" means.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.6
    },
    {
        "id": "smp0166q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "the udp header includes the packet length (header + data) whereas the tcp header only includes the header length. the tcp header includes an acknowledgement number, advertised window and a sequence number which you do not find in the udp header. the acknowledgement number states the sender which packets have arrived yet. the advertised window field gives the sender a feedback about how many more bytes the receiver will accept using the sliding window protocol. and the sequence number is necessary to be able to compute the packets in order.",
        "answer_feedback": "all the stated differences between a tcp header and a udp header are correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0265q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter decreases by a factor of 10. that means the maximum distance between two locations on the network has to be 10 times smaller.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0361q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "127.255.255.255 (broadcast)\n1.0.0.0 to 126.0.0.0 (network id)",
        "answer_feedback": "please watch your notation: 1.0.0.0 - 126.0.0.0 does not mean, only addresses with .0.0.0, but every address in this range, for example 13.8.255.4, toobroadcast is x.255.255.255 with x between 0 and 127missing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0159q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "depending on the stations location in the network, they might be able to more easily reserve bandwidth on the bus for sending data. stations which are farther back will have less opportunities for reserving a bus than stations at the front.\nthis can be fixed by introducing some formulas describing how often each station can reserve a bus.",
        "answer_feedback": "the response is correct as it correctly states the issue with distributed queue dual buses.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0363q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "10.0.0.0 bis 10.255.255.255 private netze",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0089q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps\nadvantages: tsap valid for one connection only(always newly generated)\ndisadvantages: in general not always applicable: \nprocess server addressing method not possible, because: \n- server is reached via a designated/known tsap\n- some tsaps always exist as “well-known”\n\n\n2. to identify connections individually\nadvantages: \neach individual connection is assigned a new seqno and endsystems remember already assigned seqno\n\ndisadvantages: endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed\n\n3.to identify pdus individually:\nindividual sequential numbers for each pdu\n\nadvantages: seqno basically never gets reset\ndisadvantage: higher usage of bandwidth and memory",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0163q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "distributed queue dual buses = 2 buses (transfer data in opposing directions), every node connected to both buses\n\ndistributed queue dual buses is an architecture whereby every node is connected to 2 buses (write and read access). these buses are responsible for data transmission in opposing directions. the problem is because of transmission of data:\n\nboth buses are connected to a frame generator which generate a fixed size frame every 125 milliseconds. depending on the position of the nodes in the bus they can reserve the bus for sending data with a higher probability. e.g. for a node in the middle we have a probability of 50% to successfully reserve a bus. as a consequence, fairness is a problem due to the bus topology: depending on the position of the node the node may be more or less successful in reserving a bus for data transmission.",
        "answer_feedback": "the response correctly explains the fairness problem of reserving transmission rights in dqdb.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0045q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "we need to calculate the probability that the system has 9 or less packets. to do that we calculate 1 – p_10.  p_10  is the blocking probability p_b which can be calculated using the formula on page 31 from the performance evaluation slides. \nwith a utilization of 9/10 we have a probability of around 1 – 0.05 = 0.95.\nwhich means we expect the system to spend around 0.95 * 60s = 57s seconds in a state with less than 10 packets.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0050q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "since the system reached an equilibrium the probabilities do not change anymore ( dp_n(t)/dt = 0 ). so it can be assumed that the queue is emptied by one package each second on average (10 served - 9 arrived).\n\nnow assuming that the queue is full at obvservation start, it will be empty after 10 seconds, from which 9 seconds the queue has less packets then 10.",
        "answer_feedback": "the response is incorrect because the stated number of expected seconds is incorrect as the correct number of seconds is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0171q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "in tcp there is a sequence number field to identify packets individually for reliability. there is no sequence number in udp. the udp header does not have an options field, while the tcp header does. in tcp there is an advertised window field for the sliding window protocol for flow control. there is no flow control and therefore no advertised window field in udp. in tcp there there is only a data offset field that specifies the header length. in udp the whole packet length is transmitted.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0218q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "the purpose of these two algorithms is the efficient (e.g. compared to flooding) execution of broadcast routing, i.e. the sending of packets to all other hosts in the subnet. mode of operation: both are based on the idea of the spanning tree to use the shortest possible paths from the sender to the receivers. _rpf_ forwards a broadcast packet arriving on one link over all other links only if it arrives over a link over which, according to its own routing table, packets are also routed to the sender of the broadcast (i.e. it is assumed that the packet arrived on the best path), otherwise the packet is discarded. _rpb_ differs from _rpf_ in the way it forwards packets: a packet is only forwarded to a direct neighbouring node if the forwarding node would also be located on a unicast path between the sender and that neighbouring node. for example, if a node b receives a broadcast packet from a and b has links with c and d, but has previously learned that no packets are routed from a to c via b, but to d via b, then it will not forward the packet to c (unlike _rpf_), but only to d. this further reduces the number of messages compared to _rpf_.",
        "answer_feedback": "the response correctly answers the purpose and the explanation for both broadcast types.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0018q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the network should use binary encoding:\n- because of the perfect clocks there is no need for a self-clocking encoding\n- binary encoding has better bandwith utilization than manchester/differential manchester encoding which is important because this network is often congested",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0266q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "this “ collision domain diameter” will decrease by a factor of 10",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    }
]
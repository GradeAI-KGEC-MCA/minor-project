[
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency shake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport layer\n\nobserve mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handshake protocol\n+\u00a0ds\n-\u00a0\n\nwatercourse control on conveyance layer\n\nmention mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handshake protocol\n+\u00a0ds\n-\u00a0\n\ncurrent control on transfer layer\n\nnote mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handshaking protocol\n+\u00a0ds\n-\u00a0\n\ncurrent control on ecstasy layer\n\nmention mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handclasp protocol\n+\u00a0ds\n-\u00a0\n\nwatercourse control on transport layer\n\ncite mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the constitution will be for the entire metro in a state, in which there are less than 10 packages waiting in the queue, because there are always more processed packages pro second than arriving. utilization = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packages in the constitution n = use / 1 - use giving = 9 packages we can also calculate the probability, that the constitution is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same in each m, the probability that the constitution is complete also persists.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the administration will be for the entire subway in a state, in which there are less than 10 packages waiting in the queue, because there are always more processed packages pro second than arriving. utilization = comer rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packages in the administration n = use / 1 - use giving = 9 packages we can also calculate the probability, that the administration is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same in each meter, the probability that the administration is complete also persists.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the system will be for the entire metro in a state, in which there are less than 10 packages waiting in the queue, because there are always more processed packages pro second than arriving. utilization = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packages in the system n = use / 1 - use giving = 9 packages we can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same in each beat, the probability that the system is complete also persists.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the formation will be for the entire metro in a state, in which there are less than 10 packages waiting in the queue, because there are always more processed packages pro second than arriving. utilization = comer pace / service pace = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packages in the formation n = use / 1 - use giving = 9 packages we can also calculate the probability, that the formation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same in each meter, the probability that the formation is complete also persists.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum diameter of the hit reason is calculated by the time it takes for the smallest package to travel at a sealed fastness. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the diameter of the hit reason is increase 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum diameter of the hit background is calculated by the time it takes for the smallest package to travel at a sealed speeding. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the diameter of the hit background is increase 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum diameter of the gain soil is calculated by the time it takes for the smallest package to travel at a sealed speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the diameter of the gain soil is increase 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum diameter of the hit reason is calculated by the time it takes for the smallest package to travel at a sealed amphetamine. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the diameter of the hit reason is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum diameter of the score earth is calculated by the time it takes for the smallest package to travel at a sealed speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the diameter of the score earth is increase 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something take to be sent in one focus, to be able to send some data back with the ack. it is basically using the default operation of sending the ack to also send some extra data back to the transmitter, rather of sending a new physique.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something involve to be sent in one focus, to be able to send some datum back with the ack. it is basically using the default operation of sending the ack to also send some extra datum back to the transmitter, instead of sending a new skeleton.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one focus, to be able to send some datum back with the ack. it is basically using the default operation of sending the ack to also send some extra datum back to the transmitter, rather of sending a new soma.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal agreement between agencies must be sign and filed with the county auditor or mail online;\n2. the original contracting agency has complied with all requirements and posts the collection online; and\n3. the vendor agrees to the transcription through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal agreement between agencies must be signalize and filed with the county auditor or mail online;\n2. the original contracting agency has complied with all requirements and posts the collection online; and\n3. the vendor agrees to the organization through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal harmony between agencies must be contract and filed with the county auditor or mail online;\n2. the original contracting bureau has complied with all requirements and posts the collection online; and\n3. the vendor agrees to the arrangement through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal harmony between agencies must be signed and filed with the county auditor or mail online;\n2. the original contracting delegacy has complied with all requirements and posts the collection online; and\n3. the vendor agrees to the placement through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal agreement between agencies must be signed and filed with the county auditor or mail online;\n2. the original contracting way has complied with all requirements and brand the collection online; and\n3. the vendor agrees to the arrangement through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an significant feature of the poisson dispersion is that the probability of x film a discrete value is independent of the above values, i.e. the probability is independent of the past. poisson dispersion is often used to mold the arrival of packets during a separation. the arrival times of packets molded by the poisson dispersion have an exponential dispersion and constitute an identical independent distribution process. however, in practice it has been shown that packet arrival times do not have an exponential dispersion, so the error introduced by molding them as poisson dispersion is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the provision of acknowledgement of reception to the next framework must correspond to the framework have so that it can be assigned to the related data. Otherwise it will not be able to distinguish which framework is confirmed by its acknowledgement of reception.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the supply of acknowledgement of reception to the next framework must correspond to the framework get so that it can be assigned to the related data. Otherwise it will not be able to identify which framework is confirmed by its acknowledgement of reception.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the proviso of acknowledgement of reception to the next framework must correspond to the framework received so that it can be assigned to the related data. Otherwise it will not be able to name which framework is confirmed by its acknowledgement of reception.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the proviso of acknowledgement of reception to the next framework must correspond to the framework received so that it can be assigned to the related data. Otherwise it will not be able to key which framework is confirmed by its acknowledgement of reception.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the preparation of acknowledgement of reception to the next framework must correspond to the framework find so that it can be assigned to the related data. Otherwise it will not be able to identify which framework is confirmed by its acknowledgement of reception.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Three-way shake protocol + ds - flow control in transport level quote mechanics + - multiplexation / demultiplexation + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Three-way handclasp protocol + ds - flow ascendancy in exaltation level citation mechanism + - multiplexation / demultiplexation + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Three-way shake protocol + ds - flow ascendancy in transport level acknowledgment mechanism + - multiplexation / demultiplexation + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Three-way handclasp protocol + ds - flow control in transport level quotation mechanics + - multiplexation / demultiplexation + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Three-way handshaking protocol + ds - flow dominance in transport level credit mechanism + - multiplexation / demultiplexation + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson scattering is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the past. the poisson scattering is often used to mold the arrival of packets over an interval. the arrival times of packets mold by the poisson scattering have an exponential scattering and constitute an identical sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential scattering, so the error introduced by molding them as poisson scattering is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson dissemination is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the past. the poisson dissemination is often used to mould the arrival of packets over an interval. the arrival times of packets moulded by the poisson dissemination have an exponential dissemination and constitute an identical sovereign dissemination process. however, in practice it has been shown that packet arrival times do not have an exponential dissemination, so the error introduced by moulding them as poisson dissemination is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson diffusion is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the past. the poisson diffusion is often used to sit the arrival of packets over an interval. the arrival times of packets sited by the poisson diffusion have an exponential diffusion and constitute an identical sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential diffusion, so the error introduced by siting them as poisson diffusion is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson dissemination is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the past. the poisson dissemination is often used to sit the arrival of packets over an interval. the arrival times of packets pose by the poisson dissemination have an exponential dissemination and constitute an identical sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential dissemination, so the error introduced by siting them as poisson dissemination is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson scattering is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the past. the poisson scattering is often used to pose the arrival of packets over an interval. the arrival times of packets mould by the poisson scattering have an exponential scattering and constitute an identical sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential scattering, so the error introduced by poseing them as poisson scattering is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-the acks or naks and datum are not sent separately. ack or nak are joined to the next datum stimulation and then sent with datum together to the other side. -the datum middleman bed of a station should get a new package from the top bed at the end of the waiting time interval. then the ack or nak is copied into the datum stimulation and sent together. otherwise, the datum middleman bed sends only ack or nak inning.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-the acks or naks and datum are not sent separately. ack or nak are joined to the next datum remark and then sent with datum together to the other side. -the datum striking bed of a station should get a new package from the top bed at the end of the waiting time interval. then the ack or nak is copied into the datum remark and sent together. otherwise, the datum striking bed sends only ack or nak inning.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-the acks or naks and datum are not sent separately. ack or nak are joined to the next datum stimulation and then sent with datum together to the other side. -the datum link bed of a station should get a new package from the top bed at the end of the waiting time interval. then the ack or nak is copied into the datum stimulation and sent together. otherwise, the datum link bed sends only ack or nak inning.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute\n10 * 60 = 600 bundle can be sueed in 1 minute\n\nbased on the assumption that the bundle arrive uniformly distributed in the minute (i.e. 9 bundle per second) and we can sue 10 bundle per second, this means that the organisation is busy in 90 % of the clip with sueing the bundle. in 10 % of the clip the organisation has no bundle to sue. \nsince the organisation can sue more bundle in a second than we expect to arrive in a second, the organisation will be in a state with less than 10 bundle look in the queue for the whole clip.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute\n10 * 60 = 600 bundle can be sueed in 1 minute\n\nbased on the assumption that the bundle arrive uniformly distributed in the minute (i.e. 9 bundle per second) and we can sue 10 bundle per second, this means that the organisation is busy in 90 % of the metre with sueing the bundle. in 10 % of the metre the organisation has no bundle to sue. \nsince the organisation can sue more bundle in a second than we expect to arrive in a second, the organisation will be in a state with less than 10 bundle wait in the queue for the whole metre.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frame can verify authentic jack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "figure can master authentic jacks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "framing can moderate veritable jacks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment numeral is 0 and the next installment numeral and the next installment numeral ack to be bear is give",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment bit is 0 and the next installment bit and the next installment bit ack to be bear is given",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment figure is 0 and the next installment figure and the next installment figure ack to be bear is given",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial instalment figure is 0 and the next instalment figure and the next instalment figure ack to be bear is devote",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment figure is 0 and the next installment figure and the next installment figure ack to be bear is given",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the extension of piggybacking admit the citation \"ack\". - contains the sequence-number ack(sec.no) and confirms the frame(sec.no). - here, the citation ack can be implicitly afford by the frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the extension of piggybacking includes the quotation \"ack\". - contains the episode-number ack(sec.no) and confirms the frame(sec.no). - here, the quotation ack can be implicitly pass by the frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the extension of piggybacking includes the quote \"ack\". - contains the episode-number ack(sec.no) and confirm the frame(sec.no). - here, the quote ack can be implicitly gift by the frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the extension of piggybacking includes the quotation \"ack\". - contains the episode-number ack(sec.no) and confirms the frame(sec.no). - here, the quotation ack can be implicitly generate by the frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the extension of piggybacking admit the citation \"ack\". - contains the successiveness-number ack(sec.no) and confirms the frame(sec.no). - here, the citation ack can be implicitly given by the frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson scattering is that the probability of x taking a discrete value is independent upon the previous values i.e. the probability is independent of the past. poisson scattering is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson scattering have an exponential scattering and constitute an independent identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential scattering, hence the error introduced by modeling them as poisson scattering is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson scattering is that the probability of x taking a discrete value is independent upon the previous values i.e. the probability is independent of the past. poisson scattering is often used to model arrival of packets during an interval. the packet arrival times modeled by the poisson scattering have an exponential scattering and constitute an independent identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential scattering, hence the error introduced by modeling them as poisson scattering is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson diffusion is that the probability of x taking a discrete value is independent upon the previous values i.e. the probability is independent of the past. poisson diffusion is often used to model arrival of packets during an interval. the packet arrival times modeled by the poisson diffusion have an exponential diffusion and constitute an independent identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential diffusion, hence the error introduced by modeling them as poisson diffusion is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson dissemination is that the probability of x taking a discrete value is independent upon the previous values i.e. the probability is independent of the past. poisson dissemination is often used to model arrival of packets during an breakup. the packet arrival times modeled by the poisson dissemination have an exponential dissemination and constitute an independent identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential dissemination, hence the error introduced by modeling them as poisson dissemination is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson dissemination is that the probability of x taking a discrete value is independent upon the previous values i.e. the probability is independent of the past. poisson dissemination is often used to model arrival of packets during an breakup. the packet arrival times modeled by the poisson dissemination have an exponential dissemination and constitute an independent identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential dissemination, hence the error introduced by modeling them as poisson dissemination is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in house a. except 0 and 127 are reserved for mesh and program",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all addresses in house a. except 0 and 127 are reserved for meshing and broadcast",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all destination in family a. except 0 and 127 are reserved for meshing and syllabus",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all reference in family a. except 0 and 127 are reserved for network and syllabus",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all reference in family a. except 0 and 127 are reserve for net and broadcast",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only imply to broadcast the datum as a package and do not have to broadcast a individual package for each receiver, also does not imply to hump all the receivers as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only imply to send the datum as a package and do not have to send a unmarried package for each receiver, also does not imply to know all the liquidator as the tree will wield the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only imply to air the datum as a package and do not have to air a exclusive package for each receiver, also does not imply to hump all the receivers as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only imply to send the datum as a package and do not have to send a unmarried package for each receiver, also does not imply to cognize all the liquidator as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only imply to send the datum as a package and do not have to send a exclusive package for each receiver, also does not imply to bang all the liquidator as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of sovereign arrivals of poisson has been justified by claiming that the aggregation of many processes of sovereign renewal and identically distributed tend to poisson process when the figure increases. poisson processes are conventional in dealings application scenarios that include a large figure of sovereign dealings catamenia. the theoretical background behind the use comes from the palm theorem (arrowsmith et al. 2015). it states that under appropriate but mild conditions, a large figure of multiplexed catamenia approaches a poisson process as the catamenia figure grows. still, the decrease of the unique rates to maintain the constant aggregate rate. but, the aggregation of dealings does not always have to result in a poisson process. so it maintains if the above criteria are applied.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamey-mogul in order to work very performant with a gamey amount of datum.\njob is that it is not that good, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamey-might in order to work very performant with a gamey amount of datum.\njob is that it is not that correct, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamey-mogul in order to work very performant with a gamey amount of datum.\njob is that it is not that right, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamey-power in order to work very performant with a gamey amount of datum.\njob is that it is not that veracious, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamey-mightiness in order to work very performant with a gamey amount of datum.\njob is that it is not that right, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -fault forwarding -end to end catamenia forwarding udp: -connectionless -no catamenia forwarding -no fail forwarding or transmission -maybe used with transmission/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection point -fault furtherance -end to end flow furtherance udp: -connectionless -no flow furtherance -no fail furtherance or contagion -maybe used with contagion/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection point -fault promotion -end to end menses promotion udp: -connectionless -no menses promotion -no fail promotion or contagion -maybe used with contagion/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection point -fault advancement -end to end period advancement udp: -connectionless -no period advancement -no fail advancement or transmission -maybe used with transmission/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection tailor -fault forwarding -end to end menstruum forwarding udp: -connectionless -no menstruum forwarding -no fail forwarding or transmission -maybe used with transmission/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest software is at least 64 bytes, the maximum tally land diameter is calculated by the time it takes for the smallest software to travel at a sealed speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the tally land diameter is increased 100 clip.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest parcel is at least 64 bytes, the maximum remove land diameter is calculated by the time it takes for the smallest parcel to travel at a sealed speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the remove land diameter is increased 100 meter.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest software is at least 64 byte, the maximum hit land diameter is calculated by the time it charter for the smallest software to travel at a sealed speed. thus, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit land diameter is increased 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest package is at least 64 bytes, the maximum tally land diameter is calculated by the time it train for the smallest package to travel at a sealed speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the tally land diameter is increased 100 time.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest software is at least 64 byte, the maximum stumble land diameter is calculated by the time it takes for the smallest software to travel at a sealed speed. thus, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the stumble land diameter is increased 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link seam of a post should get a new package from the top seam at the end of the waiting time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection layer of a station should get a new package from the top layer at the end of the wait time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link bed of a post should get a new package from the top bed at the end of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection bottom of a post should get a new package from the top bottom at the end of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection layer of a place should get a new package from the top layer at the end of the wait time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the job, the store datum does not depend on the location, some have more frame than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the trouble, the stored datum does not depend on the locating, some have more flesh than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the trouble, the stored datum does not depend on the locating, some have more physique than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the job, the store datum does not calculate on the location, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the job, the store datum does not reckon on the location, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only postulate to send the datum as a package and you don't have to send a unmarried package for each receiver, you also don't postulate to know all the receivers as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only ask to send the datum as a parcel and you don't have to send a unmarried parcel for each receiver, you also don't ask to know all the receivers as the tree will handle the transmitting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only take to send the datum as a package and you don't have to send a unmarried package for each receiver, you also don't take to know all the receivers as the tree will handle the infection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only ask to send the datum as a software and you don't have to send a undivided software for each receiver, you also don't ask to know all the receivers as the tree will handle the infection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes land when it is in equilibrium. however, the regular-state probability pk to find the process in state k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability menstruum, also called flux, into state k equals the probability menstruum out of state k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes land when it is in equilibrium. however, the unfaltering-commonwealth probability pk to find the process in commonwealth k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability flow, also called flux, into commonwealth k equals the probability flow out of commonwealth k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes land when it is in equilibrium. however, the steady-commonwealth probability pk to find the process in commonwealth k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability period, also called flux, into commonwealth k equals the probability period out of commonwealth k. this cede the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes land when it is in equilibrium. however, the regular-commonwealth probability pk to find the process in commonwealth k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability flow, also called flux, into commonwealth k equals the probability flow out of commonwealth k. this return the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, hereafter) skip 2: (g,f, hereafter), (g,e, hereafter) skip 3: (e,b, hereafter), (e,c, hereafter), (e,f, hereafter) < = because of the gemini (f,c, hereafter) < = because of the gemini, (f,d, hereafter) hop 4: (b,c, hereafter) < = bcusa of the gemini, (b,a, hereafter), (c, hereafter), (c, in a drop) < = because of the gemini, (d,a, hereafter) < < < bcasa of the gemini, < < < bcasa of the gemini",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hops 1: (h,g, hereafter) hops 2: (g,f, hereafter), (g,e, hereafter) hops 3: (e,b, hereafter), (e,c, hereafter), (e,f, hereafter) < = because of the similitude (f,c, hereafter) < = because of the similitude, (f,d, hereafter) hops 4: (b,c, hereafter) < = bcusa of the similitude, (b,a, hereafter), (c, hereafter), (c, in a drop) < = because of the similitude, (d,a, hereafter) < < < bcasa of the similitude, < < < bcasa of the similitude",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hops 1: (h,g, hereafter) hops 2: (g,f, hereafter), (g,e, hereafter) hops 3: (e,b, hereafter), (e,c, hereafter), (e,f, hereafter) < = because of the gemini (f,c, hereafter) < = because of the gemini, (f,d, hereafter) hop 4: (b,c, hereafter) < = bcusa of the gemini, (b,a, hereafter), (c, hereafter), (c, in a drop) < = because of the gemini, (d,a, hereafter) < < < bcasa of the gemini, < < < bcasa of the gemini",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hops 1: (h,g, hereafter) hops 2: (g,f, hereafter), (g,e, hereafter) hops 3: (e,b, hereafter), (e,c, hereafter), (e,f, hereafter) < = because of the similitude (f,c, hereafter) < = because of the similitude, (f,d, hereafter) hop 4: (b,c, hereafter) < = bcusa of the similitude, (b,a, hereafter), (c, hereafter), (c, in a drop) < = because of the similitude, (d,a, hereafter) < < < bcasa of the similitude, < < < bcasa of the similitude",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hops 1: (h,g, hereafter) hops 2: (g,f, hereafter), (g,e, hereafter) hops 3: (e,b, hereafter), (e,c, hereafter), (e,f, hereafter) < = because of the gemini (f,c, hereafter) < = because of the gemini, (f,d, hereafter) hop 4: (b,c, hereafter) < = bcusa of the gemini, (b,a, hereafter), (c, hereafter), (c, in a drop) < = because of the gemini, (d,a, hereafter) < < < bcasa of the gemini, < < < bcasa of the gemini",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -mistake ascterminateancy -terminate to terminate flux ascterminateancy udp: -connectionless -no flux ascterminateancy -no mistake ascterminateancy or retransmission -maybe used with programme/multicast and pour",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -fault ascterminateancy -terminate to terminate flux ascterminateancy udp: -connectionless -no flux ascterminateancy -no fault ascterminateancy or retransmission -maybe used with programme/multicast and pelt",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -fault ascterminateence -terminate to terminate flux ascterminateence udp: -connectionless -no flux ascterminateence -no fault ascterminateence or retransmission -maybe used with programme/multicast and streaming",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -misplay control -end to end flux control udp: -connectionless -no flux control -no misplay control or retransmission -maybe used with programme/multicast and teem",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hops 1: (h,g,forrader) hops 2: (g,f,forrader), (g,e,forrader) hops 3: (e,b,forrader), (e,c,forrader), (e,f,bead)$$$ = similitude (f,c,bead)= = similitude (f,d,forrader) hops 4: (b,c,bead)= similitude (b,a,forrader), (c,a bead)< = similitude (d,a,bead) = similitude (d,a,bead) = similitude (d,a,bead) = similitude (b,a,bead) = similitude (b,a,bead)< = similitude (d,a,bead)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g,forrader) skip 2: (g,f,forrader), (g,e,forrader) skip 3: (e,b,forrader), (e,c,forrader), (e,f,cliff)$$$ = twins (f,c,cliff)= = twins (f,d,forrader) skip 4: (b,c,cliff)= twins (b,a,forrader), (c,a cliff)< = twins (d,a,cliff) = twins (d,a,cliff) = twins (d,a,cliff) = twins (b,a,cliff) = twins (b,a,cliff)< = twins (d,a,cliff)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g,forrader) skip 2: (g,f,forrader), (g,e,forrader) skip 3: (e,b,forrader), (e,c,forrader), (e,f,driblet)$$$ = twins (f,c,driblet)= = twins (f,d,forrader) skip 4: (b,c,driblet)= twins (b,a,forrader), (c,a driblet)< = twins (d,a,driblet) = twins (d,a,driblet) = twins (d,a,driblet) = twins (b,a,driblet) = twins (b,a,driblet)< = twins (d,a,driblet)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g,forrader) skip 2: (g,f,forrader), (g,e,forrader) skip 3: (e,b,forrader), (e,c,forrader), (e,f,drib)$$$ = counterpart (f,c,drib)= = counterpart (f,d,forrader) skip 4: (b,c,drib)= counterpart (b,a,forrader), (c,a drib)< = counterpart (d,a,drib) = counterpart (d,a,drib) = counterpart (d,a,drib) = counterpart (b,a,drib) = counterpart (b,a,drib)< = counterpart (d,a,drib)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g,forrader) skip 2: (g,f,forrader), (g,e,forrader) skip 3: (e,b,forrader), (e,c,forrader), (e,f,bead)$$$ = twins (f,c,bead)= = twins (f,d,forrader) skip 4: (b,c,bead)= twins (b,a,forrader), (c,a bead)< = twins (d,a,bead) = twins (d,a,bead) = twins (d,a,bead) = twins (b,a,bead) = twins (b,a,bead)< = twins (d,a,bead)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 portion because we receive only 9 portion and answer 10 portion. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 bundle because we have only 9 bundle and reply 10 bundle. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 tract because we obtain only 9 tract and answer 10 tract. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the meter less than 10 packet because we meet only 9 packet and answer 10 packet. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 packet because we invite only 9 packet and serve 10 packet. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0102q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encryption is the best option because of its good ego-clocking lineament which is significant in a engorged mesh. it also provides error detection.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0102q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encryption is the best option because of its good ego-clocking feature which is authoritative in a engorged mesh. it also provides error catching.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0102q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encryption is the best option because of its safe ego-clocking lineament which is important in a engorged mesh. it also provides error detection.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0102q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encryption is the best option because of its good ego-clocking lineament which is authoritative in a engorged mesh. it also provides error detection.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0102q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encryption is the best option because of its good ego-clocking feature which is significant in a engorged mesh. it also provides error spying.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the fringe must be used, since the protocol oriented to the vitrine requires additional time due to the instauration of dles in the frame and convert to the true encoding. moreover, the protocol oriented to the account leads to desync in vitrine of a transmission error and therefore is not reliable enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the fringe must be used, since the protocol oriented to the fiber requires additional time due to the presentation of dles in the frame and convert to the true encoding. moreover, the protocol oriented to the account leads to desync in typeface of a transmission error and therefore is not reliable enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol orientate to the fringe must be used, since the protocol orientate to the grapheme requires additional time due to the origination of dles in the frame and convert to the true encoding. moreover, the protocol orientate to the account leads to desync in case of a transmission error and therefore is not reliable enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol orientate to the fringe must be used, since the protocol orientate to the eccentric requires additional time due to the introduction of dles in the frame and convert to the true encoding. moreover, the protocol orientate to the account leads to desync in typeface of a transmission error and therefore is not reliable enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the pillowcase, because the arriver pace (9) is lower than the service pace (10). \nso on modal the buffer is always below its maximal content of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the pillowcase, because the arriver pace (9) is lower than the serving pace (10). \nso on average the buffer is always below its maximal capacitance of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the pillowcase, because the arriver pace (9) is broken than the serve pace (10). \nso on middling the buffer is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a tallyer \n- because if recipient have no chassis to send, the sender will never get an ack for his sended chassiss\n- so when a chassis is received, the recipient have no chassis to send and the tally is ended, the recipient send a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a enumerationer \n- because if recipient have no form to maneuver, the maneuverer will never get an ack for his maneuvered forms\n- so when a form is find, the recipient have no form to maneuver and the enumeration is ended, the recipient maneuver a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if recipient have no flesh to manoeuvre, the manoeuvreer will never get an ack for his manoeuvreed fleshs\n- so when a flesh is obtain, the recipient have no flesh to manoeuvre and the count is ended, the recipient manoeuvre a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a enumerationer \n- because if recipient have no descriptor to steer, the steerer will never get an ack for his steered descriptors\n- so when a descriptor is received, the recipient have no descriptor to steer and the enumeration is ended, the recipient steer a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a numerationer \n- because if receiver have no form to direct, the directer will never get an ack for his directed forms\n- so when a form is ennumerationer, the receiver have no form to direct and the numeration is ended, the receiver direct a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 packet because we welcome only 9 packet and help 10 packet. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the metre less than 10 bundle because we receive only 9 bundle and help 10 bundle. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the meter less than 10 software because we receive only 9 software and help 10 software. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the metre less than 10 bundle because we receive only 9 bundle and help 10 bundle. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the meter less than 10 packet because we receive only 9 packet and help 10 packet. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the shell, because the reaching rate (9) is small than the service rate (10). \nso on mediocre the buffer is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the suit, because the reaching tread (9) is depleted than the service tread (10). \nso on mediocre the buffer is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the instance, because the reaching yard (9) is lower than the service yard (10). \nso on mediocre the buffer is always below its maximal capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the showcase, because the reaching step (9) is lower than the service step (10). \nso on mediocre the buff is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the reaching pace (9) is downcast than the service pace (10). \nso on mediocre the cowcatcher is always below its maximal capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all destination in form a. except 0 and 127 are record for network and plan",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all address in frame a. except 0 and 127 are script for network and programme",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in form a. except 0 and 127 are book for net and broadcast",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all addresses in variant a. except 0 and 127 are record for meshwork and programme",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all addresses in form a. except 0 and 127 are ledger for meshwork and curriculum",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum linkup stratum of one post must get a new packet from the upper stratum by the ending of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link stratum of one post must get a new packet from the upper stratum by the ending of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection stratum of one post must get a new packet from the upper stratum by the remnant of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link class of one place must get a new packet from the upper class by the oddment of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum nexus stratum of one place must get a new packet from the upper stratum by the end of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 plurality because we have only 9 plurality and dish 10 plurality.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the metre less than 10 pack because we obtain only 9 pack and serve 10 pack.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 ingroup because we experience only 9 ingroup and dish 10 ingroup.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the clip less than 10 pack because we experience only 9 pack and serve 10 pack.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the sentence less than 10 battalion because we receive only 9 battalion and dish 10 battalion.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 bundle come, the waiting time for the first packet w1 is not grant therefore assumed with 1second. there are now 9 bundle in the polisher. at second 1, 9 more bundle come. the polisher is completely filled with 10 bundle, 8 more are dropped.  the bundle are starting to be dish with an average service rate of 10. at second 2, there are no bundle left in the polisher. 9 new ones come and are directly dish. from now on the polisher won\u2019t fill up again. this means there are 58 seconds with less than 10 bundle waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 package come, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 package in the polisher. at second 1, 9 more package come. the polisher is completely filled with 10 package, 8 more are dropped.  the package are starting to be dish with an average help rate of 10. at second 2, there are no package left in the polisher. 9 new ones come and are straightaway dish. from now on the polisher won\u2019t fill up again. this means there are 58 seconds with less than 10 package waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 software come, the waiting time for the first packet w1 is not collapse therefore assumed with 1second. there are now 9 software in the pilot. at second 1, 9 more software come. the pilot is completely filled with 10 software, 8 more are dropped.  the software are starting to be dish with an average service rate of 10. at second 2, there are no software left in the pilot. 9 new ones come and are directly dish. from now on the pilot won\u2019t fill up again. this means there are 58 seconds with less than 10 software waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 packet come, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 packet in the fender. at second 1, 9 more packet come. the fender is completely filled with 10 packet, 8 more are dropped.  the packet are starting to be dish with an average service rate of 10. at second 2, there are no packet left in the fender. 9 new ones come and are direct dish. from now on the fender won\u2019t fill up again. this means there are 58 seconds with less than 10 packet waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 package come, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 package in the polisher. at second 1, 9 more package come. the polisher is completely filled with 10 package, 8 more are dropped.  the package are starting to be dish with an average servicing rate of 10. at second 2, there are no package left in the polisher. 9 new ones come and are straight dish. from now on the polisher won\u2019t fill up again. this means there are 58 seconds with less than 10 package waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency shake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transfer layer\n\ncite mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handclasp protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport layer\n\nacknowledgment mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handshaking protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport stratum\n\ncredit mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transferral stratum\n\ncredit mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handclasp protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport stratum\n\nquotation mechanic\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0 to 127.0.0 are all family destinations a. except 0 and 127 are keep for meshing and contagion",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0 to 127.0.0 are all family terminus a. except 0 and 127 are sustain for network and transmittance",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0 to 127.0.0 are all family address a. except 0 and 127 are defend for mesh and transmission",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0 to 127.0.0 are all kinsfolk finish a. except 0 and 127 are defend for network and transmission",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0 to 127.0.0 are all class destinations a. except 0 and 127 are conserve for mesh and transmission",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle come in 1 minute\n10 * 60 = 600 bundle can be processed in 1 minute\n\nbased on the assumption that the bundle come uniformly disperse in the minute (i.e. 9 bundle per second) and we can process 10 bundle per second, this means that the organisation is busy in 90 % of the metre with processing the bundle. in 10 % of the metre the organisation has no bundle to process. \nsince the organisation can process more bundle in a second than we expect to come in a second, the organisation will be in a state with less than 10 bundle waiting in the queue for the whole metre.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 pile arrive in 1 minute\n10 * 60 = 600 pile can be processed in 1 minute\n\nbased on the assumption that the pile arrive uniformly disperse in the minute (i.e. 9 pile per second) and we can process 10 pile per second, this means that the arrangement is busy in 90 % of the meter with processing the pile. in 10 % of the meter the arrangement has no pile to process. \nsince the arrangement can process more pile in a second than we expect to arrive in a second, the arrangement will be in a state with less than 10 pile waiting in the queue for the whole meter.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bunch come in 1 minute\n10 * 60 = 600 bunch can be processed in 1 minute\n\nbased on the assumption that the bunch come uniformly disperse in the minute (i.e. 9 bunch per second) and we can process 10 bunch per second, this means that the arrangement is busy in 90 % of the time with processing the bunch. in 10 % of the time the arrangement has no bunch to process. \nsince the arrangement can process more bunch in a second than we expect to come in a second, the arrangement will be in a state with less than 10 bunch waiting in the queue for the whole time.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bunch come in 1 minute\n10 * 60 = 600 bunch can be processed in 1 minute\n\nbased on the assumption that the bunch come uniformly disperse in the minute (i.e. 9 bunch per second) and we can process 10 bunch per second, this means that the organisation is busy in 90 % of the time with processing the bunch. in 10 % of the time the organisation has no bunch to process. \nsince the organisation can process more bunch in a second than we expect to come in a second, the organisation will be in a state with less than 10 bunch waiting in the queue for the whole time.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 cluster get in 1 minute\n10 * 60 = 600 cluster can be processed in 1 minute\n\nbased on the assumption that the cluster get uniformly disperse in the minute (i.e. 9 cluster per second) and we can process 10 cluster per second, this means that the arrangement is busy in 90 % of the sentence with processing the cluster. in 10 % of the sentence the arrangement has no cluster to process. \nsince the arrangement can process more cluster in a second than we expect to get in a second, the arrangement will be in a state with less than 10 cluster waiting in the queue for the whole sentence.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 bundle: 10 bundle 2. step: queue: 9 bundle: 10 bundle 3. step: queue: 9 bundle: 9 bundle 4. step: queue: 9 bundle: 9 bundle and so on. if you always come 9 bundle per second and the host can serve a maximum of 10 bundle per second, there will never be 10 bundle in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 portion: 10 portion 2. step: queue: 9 portion: 10 portion 3. step: queue: 9 portion: 9 portion 4. step: queue: 9 portion: 9 portion and so on. if you always get 9 portion per second and the host can serve a uttermost of 10 portion per second, there will never be 10 portion in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 bundle: 10 bundle 2. step: queue: 9 bundle: 10 bundle 3. step: queue: 9 bundle: 9 bundle 4. step: queue: 9 bundle: 9 bundle and so on. if you always come 9 bundle per second and the host can serve a utmost of 10 bundle per second, there will never be 10 bundle in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 package: 10 package 2. step: queue: 9 package: 10 package 3. step: queue: 9 package: 9 package 4. step: queue: 9 package: 9 package and so on. if you always come 9 package per second and the host can serve a uttermost of 10 package per second, there will never be 10 package in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footstep: queue: 10 bundle: 10 bundle 2. footstep: queue: 9 bundle: 10 bundle 3. footstep: queue: 9 bundle: 9 bundle 4. footstep: queue: 9 bundle: 9 bundle and so on. if you always arrive 9 bundle per second and the host can serve a maximum of 10 bundle per second, there will never be 10 bundle in the queue except in the first footstep.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -error control -end to end menstruate control udp: -connectionless -no menstruate control -no error control or retransmission -maybe used with broadcast/multicast and swarm",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -error control -stop to stop menstruate control udp: -connectionless -no menstruate control -no error control or retransmission -maybe used with program/multicast and pour",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest parcel is at least 64 bytes, the maximal impact sand diam is calculated by the time it takes for the smallest parcel to travel at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact sand diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum impact gumption diam is depend by the time it takes for the smallest package to travel at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact gumption diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest packet is at least 64 bytes, the maximum impact sand diam is calculate by the time it takes for the smallest packet to travel at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact sand diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest packet is at least 64 bytes, the maximal impact sand diam is calculated by the time it takes for the smallest packet to travel at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact sand diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the smallest package is at least 64 bytes, the maximum impact grit diam is calculate by the time it takes for the smallest package to travel at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact grit diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only involve to send out the datum as one packet and dont have to send a unmarried packet for each receiver, you also dont involve to know all the liquidator as the tree will palm the transmittance.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only involve to send out the datum as one packet and dont have to send a unmarried packet for each recipient, you also dont involve to know all the liquidator as the tree will handle the transmittance.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only involve to send out the datum as one packet and dont have to send a single packet for each liquidator, you also dont involve to cognise all the recipient as the tree will handle the transmittance.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only involve to send out the datum as one packet and dont have to send a single packet for each liquidator, you also dont involve to bang all the liquidators as the tree will deal the transmittance.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only involve to send out the datum as one packet and dont have to send a individual packet for each liquidator, you also dont involve to know all the liquidators as the tree will handle the transmittance.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer underframe have to be capable to curb datum + ack and not only ack or only datum. this room the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer skeleton have to be capable to curb datum + ack and not only ack or only datum. this room the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer bod have to be capable to conquer datum + ack and not only ack or only datum. this room the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer frames have to be open to inhibit datum + ack and not only ack or only datum. this room the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer anatomy have to be able to curb datum + ack and not only ack or only datum. this room the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge individually. ack or nak is attached to the next datum frame and then charge with datum together to the other side.\n\n-the datum tie bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggyback on the datum frame and charge together. otherwise, the datum tie bed sends only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge severally. ack or nak is attached to the next datum frame and then charge with datum together to the other side.\n\n-the datum tie bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and charge together. otherwise, the datum tie bed sends only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not beam separately. ack or nak is attached to the next datum frame and then beam with datum together to the other side.\n\n-the datum tie bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggyback on the datum frame and beam together. otherwise, the datum tie bed station only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge separately. ack or nak is attached to the next datum frame and then charge with datum together to the other side.\n\n-the datum tie bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and charge together. otherwise, the datum tie bed transport only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slew window, because they need goodish performance and goodish slot utilization. and they also have sodding watches for the cowboy.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "skid window, because they need tidy performance and tidy slot utilization. and they also have everlasting watches for the cowboy.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slip window, because they need healthy performance and healthy slot utilization. and they also have perfect lookout for the cowhand.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need goodish performance and goodish slot utilization. and they also have perfect lookout for the cowboy.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need goodly performance and goodly slot utilization. and they also have perfect watches for the cowhand.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester coding is the best selection because of its good ego-clocking function which is important in an engorged net. it also offer error detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester coding is the best alternative because of its good ego-clocking function which is important in an engorged interlock. it also leave error detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester coding is the best pick because of its skilful ego-clocking function which is important in an engorged interlock. it also provides error detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the constitution will be all the time in a state, in which there are less than 10 packets waiting in the queue, because there are always more pro-second process packets than arriving. utilization = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - mean number of packets in the constitution n = usage / 1 - use giving = 9 package we can also calculate the probability, that the constitution is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same at every moment, the probability that the constitution is full remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the arrangement will be all the time in a state, in which there are less than 10 packets waiting in the queue, because there are always more pro-second processed packets than arriving. utilization = reaching rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - mediocre number of packets in the arrangement n = usage / 1 - use giving = 9 package we can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same at every moment, the probability that the arrangement is full remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the formation will be all the time in a state, in which there are less than 10 packets waiting in the queue, because there are always more pro-second processed packets than arriving. exercise = comer rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packets in the formation n = usage / 1 - use giving = 9 package we can also calculate the probability, that the formation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same at every moment, the probability that the formation is full remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the arrangement will be all the time in a state, in which there are less than 10 packets waiting in the queue, because there are always more pro-second action packets than arriving. utilization = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - ordinary number of packets in the arrangement n = usage / 1 - use giving = 9 package we can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same at every moment, the probability that the arrangement is full remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the formation will be all the time in a state, in which there are less than 10 packets waiting in the queue, because there are always more pro-second processed packets than arriving. exercise = arriver rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packets in the formation n = usage / 1 - use giving = 9 package we can also calculate the probability, that the formation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is not the same at every moment, the probability that the formation is full remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking annexe includes the citation \"ack\".\n- it contains the sequence-bit ack(seq.no) and reassert the frame(seq.no). \n- here, the citation ack can be given by the frame implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking elongation include the citation \"ack\".\n- it contains the successiveness-number ack(seq.no) and confirms the frame(seq.no). \n- here, the citation ack can be given by the frame implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking extension includes the citation \"ack\".\n- it contains the episode-issue ack(seq.no) and confirm the frame(seq.no). \n- here, the citation ack can be given by the frame implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking lengthiness includes the citation \"ack\".\n- it contains the episode-bit ack(seq.no) and confirms the frame(seq.no). \n- here, the citation ack can be given by the frame implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking extension admit the citation \"ack\".\n- it contains the episode-number ack(seq.no) and confirm the frame(seq.no). \n- here, the citation ack can be given by the frame implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the organisation will be for the entire clip in a state, in which there are less than 10 packets waiting in the queue, because there is always more pro-second processed package than arriving. usability = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average package number in the organisation n = usage / 1 - use devote = 9 package we can also calculate the probability, that the organisation is complete: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilization is equal in each clip, the probability that the organisation is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the organization will be for the entire clip in a state, in which there are less than 10 packets waiting in the queue, because there is always more pro-second processed package than arriving. usability = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average package number in the organization n = usage / 1 - use giving = 9 package we can also calculate the probability, that the organization is complete: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation is equal in each clip, the probability that the organization is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the organization will be for the entire clip in a state, in which there are less than 10 packets waiting in the queue, because there is always more pro-second processed package than arriving. usability = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average package number in the organization n = usage / 1 - use open = 9 package we can also calculate the probability, that the organization is complete: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the usage is equal in each clip, the probability that the organization is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the organisation will be for the entire clip in a state, in which there are less than 10 packets waiting in the queue, because there is always more pro-second processed package than arriving. usability = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average package number in the organisation n = usage / 1 - use leave = 9 package we can also calculate the probability, that the organisation is complete: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation is equal in each clip, the probability that the organisation is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case, the agreement will be for the entire clip in a state, in which there are less than 10 packets waiting in the queue, because there is always more pro-second processed package than arriving. usability = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average package number in the agreement n = usage / 1 - use leave = 9 package we can also calculate the probability, that the agreement is complete: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the exercise is equal in each clip, the probability that the agreement is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "answer inning have to be able to carry datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with datum in a anatomy.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "answer frames have to be capable to convey datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent forms have to be able to transport datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with datum in a form.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solution fleshs have to be capable to carry datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with datum in a flesh.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "resolvent frames have to be capable to convey datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "Lambda = 9 t=1 p(less than 10 pack on the puncher) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "Lambda = 9 t=1 p(less than 10 clique on the cowman) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "Lambda = 9 t=1 p(less than 10 mob on the cowboy) = p(0 software) +...+ p(9) software = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "Lambda = 9 t=1 p(less than 10 multitude on the cowman) = p(0 packet) +...+ p(9) packet = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "Lambda = 9 t=1 p(less than 10 camp on the cowpuncher) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "chassis can contain unexplained jack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only demand to air out the datum as one parcel and dont have to air a single parcel for each receiver, you also dont demand to know all the receivers as the tree will manage the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only ask to post out the datum as one packet and dont have to post a single packet for each receiver, you also dont ask to know all the receivers as the tree will manage the contagion.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only demand to transmit out the datum as one parcel and dont have to transmit a single parcel for each receiver, you also dont demand to know all the receivers as the tree will manage the contagion.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only demand to transmit out the datum as one package and dont have to transmit a single package for each receiver, you also dont demand to know all the receivers as the tree will manage the infection.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only ask to send out the datum as one mailboat and dont have to send a single mailboat for each receiver, you also dont ask to know all the receivers as the tree will manage the infection.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i hint to practice the differential manchester encoding: this encoding technique is robust in clock recovery and hence offers synchronization adroitness at receiver becapractice a transition is warrant at least once every bite. in addition, it is less error-prone in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i hint to use the differential manchester encoding: this encoding technique is robust in clock recovery and hence offers synchronising adroitness at receiver because a transition is guaranteed at least once every bit. in addition, it is less error-prone in noisy surround.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i hint to practice the differential manchester encoding: this encoding technique is robust in clock recovery and hence offers synchronization adroitness at receiver becapractice a transition is guaranteed at least once every bit. in addition, it is less error-prone in noisy environs.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i hint to employ the differential manchester encoding: this encoding technique is robust in clock recovery and hence offers synchronicity adroitness at receiver becaemploy a transition is guaranteed at least once every bite. in addition, it is less error-prone in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i hint to use the differential manchester encoding: this encoding technique is robust in clock recovery and hence offers synchroneity adroitness at receiver because a transition is guaranteed at least once every bite. in addition, it is less error-prone in noisy surroundings.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 share\ndish: 10 share\n\n2. step:\nqueue: 9 share\ndish: 10 share\n\n3.step:\nqueue: 9 share\ndish: 9 share\n\n4. step:\nqueue: 9 share\ndish: 9 share\n\nand so on. if there will always arrive 9 share per second and the host can serve maximum 10 share per second, there will never be 10 share in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\nserving: 10 packet\n\n2. step:\nqueue: 9 packet\nserving: 10 packet\n\n3.step:\nqueue: 9 packet\nserving: 9 packet\n\n4. step:\nqueue: 9 packet\nserving: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the host can serve maximal 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 share\nserving: 10 share\n\n2. step:\nqueue: 9 share\nserving: 10 share\n\n3.step:\nqueue: 9 share\nserving: 9 share\n\n4. step:\nqueue: 9 share\nserving: 9 share\n\nand so on. if there will always arrive 9 share per second and the host can serve maximal 10 share per second, there will never be 10 share in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 tract\nserve: 10 tract\n\n2. step:\nqueue: 9 tract\nserve: 10 tract\n\n3.step:\nqueue: 9 tract\nserve: 9 tract\n\n4. step:\nqueue: 9 tract\nserve: 9 tract\n\nand so on. if there will always arrive 9 tract per second and the host can serve maximal 10 tract per second, there will never be 10 tract in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\nanswer: 10 packet\n\n2. step:\nqueue: 9 packet\nanswer: 10 packet\n\n3.step:\nqueue: 9 packet\nanswer: 9 packet\n\n4. step:\nqueue: 9 packet\nanswer: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the host can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the pillowcase, because the pace of arrival (9) is lower than the pace of service (10). so on average the cowcatcher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the pillowcase, because the pace of arrival (9) is lower than the pace of service (10). so on ordinary the fender is always below its maximum capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the pillowcase, because the pace of arrival (9) is lower than the pace of service (10). so on average the cowcatcher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the pillowcase, because the rate of arrival (9) is lower than the rate of service (10). so on intermediate the buff is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the pillowcase, because the pace of arrival (9) is lower than the pace of service (10). so on average the cowcatcher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the tot reference to the next fabric has to refer to the received fabric so that it can be assigned to the related data. Otherwise it cannot be distinguished which fabric is corroborate by its reference.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the tot reference to the next model has to refer to the obtain model so that it can be assigned to the related data. Otherwise it cannot be distinguished which model is corroborate by its reference.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the tot reference to the next fabric has to refer to the receive fabric so that it can be assigned to the related data. Otherwise it cannot be distinguished which fabric is confirmed by its reference.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes the area when it is in balance. however, the probability of stable area pk to find the process in area k no longer changes, so dpk (t )/dt = 0. in balance, is deduced from dpk (t )/dt = 0 that the probability flow, also called flow, in area k equal the probability flow outside area k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes the country when it is in balance. however, the chance of stable country pk to find the process in country k no longer changes, so dpk (t )/dt = 0. in balance, is deduced from dpk (t )/dt = 0 that the chance menstruum, also called menstruum, in country k rivals the chance menstruum outside country k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes the area when it is in balance. however, the probability of stable country pk to find the process in country k no longer changes, so dpk (t )/dt = 0. in balance, is deduced from dpk (t )/dt = 0 that the probability menstruum, also called menstruum, in country k touch the probability menstruum outside country k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes the area when it is in balance. however, the chance of stable commonwealth pk to find the process in commonwealth k no longer changes, so dpk (t )/dt = 0. in balance, is deduced from dpk (t )/dt = 0 that the chance flow, also called flow, in commonwealth k rivals the chance flow outside commonwealth k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes the commonwealth when it is in balance. however, the chance of stable area pk to find the process in area k no longer changes, so dpk (t )/dt = 0. in balance, is deduced from dpk (t )/dt = 0 that the chance flow, also called flow, in area k rivals the chance flow outside area k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On average, there are 9 parcels in the devotee per second. lambda = 9 t=1 p(less than 10 parcels in the devotee) = p(0 parcel) +...+ p(9) parcel = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On modal, there are 9 software in the caramel per second. lambda = 9 t=1 p(less than 10 software in the caramel) = p(0 package) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On average, there are 9 parcels in the devotee per second. lambda = 9 t=1 p(less than 10 parcels in the devotee) = p(0 parcel) +...+ p(9) parcel = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On intermediate, there are 9 bundles in the devotee per second. lambda = 9 t=1 p(less than 10 bundles in the devotee) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On middling, there are 9 bundle in the fan per second. lambda = 9 t=1 p(less than 10 bundle in the fan) = p(0 package) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belonging is that all is knowing the multicast tree. to build an extension tree for multicast, you also have to add the s of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the holding is that all is knowing the multicast tree. to build an extension tree for multicast, you also have to conduct the entropy of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is knowing the multicast tree. to build an wing tree for multicast, you also have to impart the entropy of the other is from the multicast grouping.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the holding is that all is knowing the multicast tree. to build an extension tree for multicast, you also have to impart the randomness of the other is from the multicast grouping.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is knowing the multicast tree. to build an wing tree for multicast, you also have to lend the entropy of the other is from the multicast grouping.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the summons still changes the earth when it is in equilibrium. however, the chance of the constant nation pk to find the summons in nation k no longer changes, so dpk (t )/dt = 0. in equilibrium, is deduced from dpk (t )/dt = 0 that the chance flow, also called flow, in nation k is equal to the chance flow out of nation k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the operation still changes the earth when it is in equilibrium. however, the probability of the constant commonwealth pk to rule the operation in commonwealth k no longer changes, so dpk (t )/dt = 0. in equilibrium, is deduced from dpk (t )/dt = 0 that the probability flow, also called flow, in commonwealth k is equal to the probability flow out of commonwealth k. this produces the equations of global equilibrium: (sum from k = 0 to eternity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own crossed tree, but it is not necessary to live the crossed trees each pathr has information that the path it would habituate for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own crossed tree, but it is not necessary to live the crossed trees each router has entropy that the route it would utilize for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own crossed tree, but it is not necessary to live the crossed trees each pathr has entropy that the path it would use for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own crossed tree, but it is not necessary to exist the crossed trees each itineraryr has information that the itinerary it would use for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own crossed tree, but it is not necessary to live the crossed trees each router has entropy that the route it would employ for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an inter-local agreement between the agencies must be marked and filed with the county auditor or issue online; 2. the original catching agency has met all requirements and meeting points online; and 3. the vendor accepts the agreement through the initial meeting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an inter-local agreement between the agencies must be stigmatise and filed with the county auditor or published online; 2. the original catching agency has met all requirements and meeting points online; and 3. the marketer accepts the agreement through the initial meeting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an inter-local agreement between the office must be punctuate and filed with the county auditor or published online; 2. the original contracting agency has met all requirements and meeting points online; and 3. the trafficker accepts the agreement through the initial meeting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an inter-local agreement between the agencies must be mark and filed with the county auditor or issue online; 2. the original catching agency has met all requirements and meeting points online; and 3. the seller accepts the agreement through the initial meeting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an inter-local agreement between the agencies must be nock and filed with the county auditor or published online; 2. the original catching agency has met all requirements and meeting points online; and 3. the vendor accepts the agreement through the initial meeting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no frame to aura, the auraer will never get an ack for his auraed frame\n- so when a frame is received, the receiver have no frame to aura and the count is terminate, the receiver aura a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if recipient have no underframe to air, the airer will never get an ack for his aired underframe\n- so when a underframe is received, the recipient have no underframe to air and the count is end, the recipient air a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if recipient have no frame to airwave, the airwaveer will never get an ack for his airwaveed frame\n- so when a frame is received, the recipient have no frame to airwave and the count is ended, the recipient airwave a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- involve a counter \n- because if liquidator have no frame to air, the airer will never get an ack for his aired frame\n- so when a frame is received, the liquidator have no frame to air and the count is ended, the liquidator air a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if recipient have no frame to zephyr, the zephyrer will never get an ack for his zephyred frame\n- so when a frame is received, the recipient have no frame to zephyr and the count is ended, the recipient zephyr a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference of class a. except 0 and 127 are suitable for network work and programme",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all addresses of grade a. except 0 and 127 are suitable for net work and programme",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all addresses of division a. except 0 and 127 are suitable for interlock work and curriculum",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all speech of family a. except 0 and 127 are suitable for mesh work and broadcast",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all speech of stratum a. except 0 and 127 are suitable for network work and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent blank receives each box on each connected side. the table of blanks contains the information about the components that are connected to the network. that involve the transparent blank receives from the component a model that has the information \"a can be reached over lan l.\" in the process of forwarding, the transparent blank floods the network with this information, so that other blanks also have the information about the component a. a flood welfare is that it apply the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent blank receives each box on each connected side. the table of blanks contains the information about the components that are connected to the network. that involve the transparent blank receives from the component a framework that has the information \"a can be reached over lan l.\" in the process of forwarding, the transparent blank floods the network with this information, so that other blanks also have the information about the component a. a flood welfare is that it utilise the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each box on each connected side. the table of infinite contains the information about the components that are connected to the network. that involve the transparent space receives from the component a framework that has the information \"a can be reached over lan l.\" in the process of forwarding, the transparent space floods the network with this information, so that other infinite also have the information about the component a. a flood eudaimonia is that it use the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent infinite receives each box on each connected side. the table of quad contains the information about the components that are connected to the network. that involve the transparent infinite receives from the component a framework that has the information \"a can be reached over lan l.\" in the process of forwarding, the transparent infinite floods the network with this information, so that other quad also have the information about the component a. a flood eudaemonia is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent blank receives each box on each connected side. the table of blanks contains the information about the components that are connected to the network. that involve the transparent blank receives from the component a framework that has the information \"a can be reached over lan l.\" in the process of forwarding, the transparent blank floods the network with this information, so that other blanks also have the information about the component a. a flood wellbeing is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-ack or naks and datum are not sent separately. ack or nak are joined to the next datum frame and then sent with datum together to the other side. -the datum liaison layer of a station must get a new package from the top layer before the ending of the waiting time interval. then the ack or nak is girded in the datum frame and sent together. otherwise, the datum liaison layer sendings only ack or nak frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the comer pace (9) is small than the service pace (10). \nso on median the pilot is always below its maximum content of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the comer footstep (9) is lower than the service footstep (10). \nso on median the fender is always below its maximum content of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the comer footstep (9) is lower than the service footstep (10). \nso on median the buff is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the comer gait (9) is downhearted than the service gait (10). \nso on median the buffer is always below its maximum capability of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the comer yard (9) is lower than the service yard (10). \nso on median the polisher is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-ack or naks and datum are not sent singly. ack or nak are joined to the next datum frame and then sent with datum together to the other side. -the datum draw layer of a station must get a new package from the top layer before the end of the waiting time interval. then the ack or nak is girded in the datum frame and sent together. otherwise, the datum draw layer sends only ack or nak frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-ack or naks and datum are not beam separately. ack or nak are joined to the next datum frame and then beam with datum together to the other side. -the datum crosstie seam of a station must get a new package from the top seam before the end of the waiting time interval. then the ack or nak is girded in the datum frame and beam together. otherwise, the datum crosstie seam sends only ack or nak frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-ack or naks and datum are not place separately. ack or nak are joined to the next datum frame and then place with datum together to the other side. -the datum draw layer of a station must get a new package from the top layer before the end of the waiting time interval. then the ack or nak is girded in the datum frame and place together. otherwise, the datum draw layer sends only ack or nak frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forward)\nhop 2:\n(g,f, forward), (g,e, forward)\nhop 3:\n(e,b, forward), (e,c, forward), (e,f, drop)<=\u00a0 because of pit\n(f,c, drop)<= because of pit, (f,d, forward)\nhop 4:\n(b,c, drop)<= becuase of pit, (b,a, forward), (c,a drop)<= becuase of pit, (d,a, drop)<= becuase of pit",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, off)\nhop 2:\n(g,f, off), (g,e, off)\nhop 3:\n(e,b, off), (e,c, off), (e,f, drop)<=\u00a0 because of couple\n(f,c, drop)<= because of couple, (f,d, off)\nhop 4:\n(b,c, drop)<= becuase of couple, (b,a, off), (c,a drop)<= becuase of couple, (d,a, drop)<= becuase of couple",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, away)\nhop 2:\n(g,f, away), (g,e, away)\nhop 3:\n(e,b, away), (e,c, away), (e,f, drop)<=\u00a0 because of pit\n(f,c, drop)<= because of pit, (f,d, away)\nhop 4:\n(b,c, drop)<= becuase of pit, (b,a, away), (c,a drop)<= becuase of pit, (d,a, drop)<= becuase of pit",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forward)\nhop 2:\n(g,f, forward), (g,e, forward)\nhop 3:\n(e,b, forward), (e,c, forward), (e,f, drop)<=\u00a0 because of meet\n(f,c, drop)<= because of meet, (f,d, forward)\nhop 4:\n(b,c, drop)<= becuase of meet, (b,a, forward), (c,a drop)<= becuase of meet, (d,a, drop)<= becuase of meet",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, onward)\nhop 2:\n(g,f, onward), (g,e, onward)\nhop 3:\n(e,b, onward), (e,c, onward), (e,f, drop)<=\u00a0 because of correspond\n(f,c, drop)<= because of correspond, (f,d, onward)\nhop 4:\n(b,c, drop)<= becuase of correspond, (b,a, onward), (c,a drop)<= becuase of correspond, (d,a, drop)<= becuase of correspond",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 packet, since more packet are avail than the packet get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 bundle, since more bundle are overhaul than the bundle come in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 parcel, since more parcel are serving than the parcel arriving in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 bundle, since more bundle are service than the bundle get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 software, since more software are overhaul than the software arriving in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum reserve is not count on the view, some have more build than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum backlog is not bet on the lieu, some have more build than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe data stockpile is not play on the locating, some have more build than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum taciturnity is not play on the position, some have more build than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum reserve is not look on the spot, some have more build than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment numeral is 0 and the next installment numeral and the next ack-installment numeral to be bear is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence act is 0 and the next sequence act and the next ack-sequence act to be bear is present",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment figure is 0 and the next installment figure and the next ack-installment figure to be bear is present",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial episode act is 0 and the next episode act and the next ack-episode act to be bear is contribute",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial instalment numeral is 0 and the next instalment numeral and the next ack-instalment numeral to be bear is afford",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -fault chasteness -finish to finish flux chasteness udp: -connectionless -no flux chasteness -no fault chasteness or retransmission -maybe used with broadcast/multicast and pullulate",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection orient -misplay constraint -end to end flux constraint udp: -connectionless -no flux constraint -no misplay constraint or retransmission -maybe used with broadcast/multicast and pullulate",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -fault simpleness -end to end flux simpleness udp: -connectionless -no flux simpleness -no fault simpleness or retransmission -maybe used with programme/multicast and pullulate",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection orient -mistake chasteness -end to end flux chasteness udp: -connectionless -no flux chasteness -no mistake chasteness or retransmission -maybe used with broadcast/multicast and pullulate",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection orient -error simplicity -terminate to terminate flux simplicity udp: -connectionless -no flux simplicity -no error simplicity or retransmission -maybe used with broadcast/multicast and pullulate",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the arrangement will be for the whole time in a state, in which there are less than 10 mailboat waiting in the queue, due to the fact that there are always more mailboat processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of mailboat in the arrangement\nn =  utilisation / 1 - utilisation which gives = 9 mailboat\nwe can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the arrangement is full remain equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the system will be for the whole time in a state, in which there are less than 10 packet waiting in the queue, due to the fact that there are always more packet processed pro second than arriving.\nutilisation = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - medium number of packet in the system\nn =  utilisation / 1 - utilisation which gives = 9 packet\nwe can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the system is full remain equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the arrangement will be for the whole time in a state, in which there are less than 10 mailboat waiting in the queue, due to the fact that there are always more mailboat processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of mailboat in the arrangement\nn =  utilisation / 1 - utilisation which gives = 9 mailboat\nwe can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the arrangement is full remain equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the system will be for the whole m in a state, in which there are less than 10 packet waiting in the queue, due to the fact that there are always more packet processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of packet in the system\nn =  utilisation / 1 - utilisation which gives = 9 packet\nwe can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every m, the probability that the system is full remain equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the system will be for the whole meter in a state, in which there are less than 10 packet waiting in the queue, due to the fact that there are always more packet processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - modal number of packet in the system\nn =  utilisation / 1 - utilisation which gives = 9 packet\nwe can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every meter, the probability that the system is full remain equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slither window, because they need a devout throughput and devout channel utilisation. and also they have consummate alfileria for buffer.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the constitution will be for the whole time in a state, in which there are less than 10 bundle waiting in the queue, due to the fact that there are always more bundle processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of bundle in the constitution\nn =  utilisation / 1 - utilisation which gives = 9 bundle\nwe can also reckon the probability, that the constitution is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the constitution is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the system will be for the whole time in a state, in which there are less than 10 bundle waiting in the queue, due to the fact that there are always more bundle sue pro second than arriving.\nutilisation = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of bundle in the system\nn =  utilisation / 1 - utilisation which gives = 9 bundle\nwe can also bet the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the system is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the system will be for the whole time in a state, in which there are less than 10 bundle waiting in the queue, due to the fact that there are always more bundle action pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of bundle in the system\nn =  utilisation / 1 - utilisation which gives = 9 bundle\nwe can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the system is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the formation will be for the whole time in a state, in which there are less than 10 packet waiting in the queue, due to the fact that there are always more packet processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of packet in the formation\nn =  utilisation / 1 - utilisation which gives = 9 packet\nwe can also calculate the probability, that the formation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the formation is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the formation will be for the whole time in a state, in which there are less than 10 bundle waiting in the queue, due to the fact that there are always more bundle action pro second than arriving.\nutilisation = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of bundle in the formation\nn =  utilisation / 1 - utilisation which gives = 9 bundle\nwe can also account the probability, that the formation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the formation is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to invest out the datum as one parcel and dont have to invest a single parcel for each receiver, you also dont need to recognize all the receivers as the tree will handle the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to commit out the datum as one package and dont have to commit a single package for each receiver, you also dont need to experience all the liquidator as the tree will handle the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to trust out the datum as one mailboat and dont have to trust a single mailboat for each receiver, you also dont need to know all the receivers as the tree will handle the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to trust out the datum as one bundle and dont have to trust a single bundle for each receiver, you also dont need to know all the receiver as the tree will handle the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to devote out the datum as one parcel and dont have to devote a single parcel for each receiver, you also dont need to know all the liquidator as the tree will handle the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal concord between agencies must be sign and filed with the county hearer or carry online;\n2. the original catching agency has complied with all requirements and posts the ingathering online; and\n3. the vendor agrees to the arrangement through the initial ingathering.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal concord between agencies must be sign and filed with the county hearer or carry online;\n2. the original catching agency has complied with all requirements and posts the allurement online; and\n3. the vendor agrees to the arrangement through the initial allurement.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need safe performance and safe duct use. and they also have utter pilot watches.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need safe performance and safe line use. and they also have gross fender watches.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need safe performance and safe channel use. and they also have gross polisher lookout.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need safe performance and safe canal use. and they also have sodding buffer sentry.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need safe performance and safe line use. and they also have thoroughgoing polisher watches.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1539q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the frame may quit implicit acks.",
        "answer_feedback": "the response does not answer the requirement correctly. implicit acks is the description of piggybacking rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1539q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the frame may intercept implicit acks.",
        "answer_feedback": "the response does not answer the requirement correctly. implicit acks is the description of piggybacking rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1539q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the frame may terminate implicit acks.",
        "answer_feedback": "the response does not answer the requirement correctly. implicit acks is the description of piggybacking rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1539q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the frame may end implicit acks.",
        "answer_feedback": "the response does not answer the requirement correctly. implicit acks is the description of piggybacking rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1539q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the frame may bar implicit acks.",
        "answer_feedback": "the response does not answer the requirement correctly. implicit acks is the description of piggybacking rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-ack or naks and datum are not sent separately. ack or nak are joined to the surveil datum figure and then sent with datum together to the other side. -the datum liaison seam of a post should get a new top seam package at the end of the waiting time interval. then the ack or nak is girded in the datum figure and sent together. otherwise, the datum liaison seam sends only ack or nak figure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data bank of a station must obtain a fresh software from the upper bed due to the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data camber of a station must obtain a young bundle from the upper bed due to the death of the waiting time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data camber of a station must obtain a raw package from the upper bed due to the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data camber of a station must obtain a new packet from the upper bed due to the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data camber of a station must obtain a new parcel from the upper bed due to the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference added to the next bod must refer to the bod experience so that it can be assigned to the related data. Otherwise, the bod asserted by its reference cannot be named.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference added to the next figure must refer to the figure received so that it can be depute to the related data. Otherwise, the figure maintain by its reference cannot be named.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference added to the next frame must refer to the frame incur so that it can be arrogate to the related data. Otherwise, the frame swan by its reference cannot be named.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference added to the next shape must refer to the shape receive so that it can be assigned to the related data. Otherwise, the shape asserted by its reference cannot be named.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference added to the next physique must refer to the physique receive so that it can be assigned to the related data. Otherwise, the physique asseverate by its reference cannot be named.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on medium, there are 9 sheaf in the polisher per second.\nlambda = 9\nt=1\n\np(less than 10 sheaf in the polisher) = p(0 sheaf) +...+ p(9 sheaf) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on average, there are 9 package in the polisher per second.\nlambda = 9\nt=1\n\np(less than 10 package in the polisher) = p(0 package) +...+ p(9 package) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on average, there are 9 parcel in the buffer per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the buffer) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on average, there are 9 megabucks in the polisher per second.\nlambda = 9\nt=1\n\np(less than 10 megabucks in the polisher) = p(0 megabucks) +...+ p(9 megabucks) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on average, there are 9 pile in the polisher per second.\nlambda = 9\nt=1\n\np(less than 10 pile in the polisher) = p(0 pile) +...+ p(9 pile) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the consultence tot to the next shape has to consult to the received shape so that it can be assigned to the related data. otherwise you cannot distinguish which shape is confirmed by your consultence.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the citation tot to the next build has to denote to the received build so that it can be assigned to the related data. otherwise you cannot distinguish which build is confirmed by your citation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the citeence tot to the next shape has to cite to the received shape so that it can be portion to the related data. otherwise you cannot distinguish which shape is confirmed by your citeence.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference tot to the next shape has to refer to the received shape so that it can be assign to the related data. otherwise you cannot distinguish which shape is confirmed by your reference.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -misplay ascceaseeence -cease to cease flow ascceaseeence udp: -connectionless -do not flow ascceaseeence -no misplay ascceaseeence or retransmission -maybe used with transmission/multicast and pour",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -wrongdoing ascterminateeence -terminate to terminate flow ascterminateeence udp: -connectionless -do not flow ascterminateeence -no wrongdoing ascterminateeence or retransmission -maybe used with transmission/multicast and pour",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection point -fault ascendeence -end to end flow ascendeence udp: -connectionless -do not flow ascendeence -no fault ascendeence or retransmission -maybe used with transmission/multicast and pour",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection point -error ascendeence -end to end flow ascendeence udp: -connectionless -do not flow ascendeence -no error ascendeence or reinfection -maybe used with infection/multicast and pour",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -error ascterminateeence -terminate to terminate flow ascterminateeence udp: -connectionless -do not flow ascterminateeence -no error ascterminateeence or retransmittance -maybe used with transmittance/multicast and pour",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footfall: queue: 10 serve package: 10 serve package 2. footfall: queue: 9 serve package: 10 serve package 3. footfall: queue: 9 serve package: 9 serve package 4: footfall: queue: 9 serve package: 9 serve package and so on. if you always arrive 9 parcels per second and the host can serve a maximum of 10 packets per second, there will never be 10 packets in queue except in first footfall.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footmark: queue: 10 suffice package: 10 suffice package 2. footmark: queue: 9 suffice package: 10 suffice package 3. footmark: queue: 9 suffice package: 9 suffice package 4: footmark: queue: 9 suffice package: 9 suffice package and so on. if you always arrive 9 parcels per second and the host can serve a maximum of 10 packets per second, there will never be 10 packets in queue except in first footmark.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. measure: queue: 10 suffice software: 10 suffice software 2. measure: queue: 9 suffice software: 10 suffice software 3. measure: queue: 9 suffice software: 9 suffice software 4: measure: queue: 9 suffice software: 9 suffice software and so on. if you always arrive 9 parcels per second and the host can serve a maximum of 10 packets per second, there will never be 10 packets in queue except in first measure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. stair: queue: 10 assist bundle: 10 assist bundle 2. stair: queue: 9 assist bundle: 10 assist bundle 3. stair: queue: 9 assist bundle: 9 assist bundle 4: stair: queue: 9 assist bundle: 9 assist bundle and so on. if you always arrive 9 parcels per second and the host can serve a maximum of 10 packets per second, there will never be 10 packets in queue except in first stair.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-direction shake protocol\n+\u00a0ds\n-\u00a0\n\nflow command on transport degree\n\ncitation mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-guidance handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport tier\n\nacknowledgment mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-focussing shake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport story\n\ncitation mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-counseling handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transport grade\n\nmention mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-direction handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow ascendence on transport tier\n\nmention mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1c, a, frontwards)\u00a0 (d, a, frontwards)\u00a0 (b, a, frontwards)\u00a0 (e, b, frontwards)\u00a0 (g, e, frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,frontwards)\u00a0 \u00a0(f,c,frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drib) c\u00a0is not situate on the unicast way from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drib)\u00a0c\u00a0is not situate on the unicast way from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drib)\u00a0c\u00a0is not situate on the unicast way from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drib)\u00a0d\u00a0is not situate on the unicast way from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drib)\u00a0f\u00a0is not situate on the unicast way from g to a\nhop 2e, a, frontwards)\u00a0(f, a, frontwards)\nhop 3g, a, frontwards)\u00a0 \u00a0 \u00a0\nhop 4h, a, frontwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, frontwards)\u00a0 (d, a, frontwards)\u00a0 (b, a, frontwards)\u00a0 (e, b, frontwards)\u00a0 (g, e, frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,frontwards)\u00a0 \u00a0(f,c,frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drib) c\u00a0is not settle on the unicast agency from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drib)\u00a0c\u00a0is not settle on the unicast agency from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drib)\u00a0c\u00a0is not settle on the unicast agency from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drib)\u00a0d\u00a0is not settle on the unicast agency from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drib)\u00a0f\u00a0is not settle on the unicast agency from g to a\nskip 2e, a, frontwards)\u00a0(f, a, frontwards)\nskip 3g, a, frontwards)\u00a0 \u00a0 \u00a0\nskip 4h, a, frontwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "vamoose 1c, a, frontwards)\u00a0 (d, a, frontwards)\u00a0 (b, a, frontwards)\u00a0 (e, b, frontwards)\u00a0 (g, e, frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,frontwards)\u00a0 \u00a0(f,c,frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not place on the unicast room from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not place on the unicast room from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not place on the unicast room from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not place on the unicast room from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not place on the unicast room from g to a\nvamoose 2e, a, frontwards)\u00a0(f, a, frontwards)\nvamoose 3g, a, frontwards)\u00a0 \u00a0 \u00a0\nvamoose 4h, a, frontwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "omission 1c, a, frontwards)\u00a0 (d, a, frontwards)\u00a0 (b, a, frontwards)\u00a0 (e, b, frontwards)\u00a0 (g, e, frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,frontwards)\u00a0 \u00a0(f,c,frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, fall) c\u00a0is not located on the unicast agency from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, fall)\u00a0c\u00a0is not located on the unicast agency from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, fall)\u00a0c\u00a0is not located on the unicast agency from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, fall)\u00a0d\u00a0is not located on the unicast agency from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, fall)\u00a0f\u00a0is not located on the unicast agency from g to a\nomission 2e, a, frontwards)\u00a0(f, a, frontwards)\nomission 3g, a, frontwards)\u00a0 \u00a0 \u00a0\nomission 4h, a, frontwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "decamp 1c, a, frontwards)\u00a0 (d, a, frontwards)\u00a0 (b, a, frontwards)\u00a0 (e, b, frontwards)\u00a0 (g, e, frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,frontwards)\u00a0 \u00a0(f,c,frontwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not situate on the unicast means from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not situate on the unicast means from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not situate on the unicast means from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not situate on the unicast means from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not situate on the unicast means from g to a\ndecamp 2e, a, frontwards)\u00a0(f, a, frontwards)\ndecamp 3g, a, frontwards)\u00a0 \u00a0 \u00a0\ndecamp 4h, a, frontwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are serviceable than the software that arrives in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 packets, as more packets are serviceable than the packet that get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are serviceable than the package that arrive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are serviceable than the package that get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcels, as more parcels are serviceable than the parcel that arrive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "The transparent nosepiece receives each frame on each side connected. the nosepiece table contains the entropy on which components are connected to the mesh. that means that the transparent nosepiece receives from the component a frame that has the entropy \"a can be reached over lan l.\" in the promotion process, the transparent nosepiece floods the mesh with this entropy, so that other nosepieces also have the entropy about the component a. An advantage of the flood component is that it uses the shortest way of the mesh.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "The transparent nosepiece receives each frame on each side connected. the nosepiece table contains the entropy on which components are connected to the meshwork. that means that the transparent nosepiece receives from the component a frame that has the entropy \"a can be reached over lan l.\" in the furtherance process, the transparent nosepiece floods the meshwork with this entropy, so that other nosepieces also have the entropy about the component a. An advantage of the flood component is that it uses the shortest way of the meshwork.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "The transparent nosepiece receives each frame on each side connected. the nosepiece table contains the entropy on which components are connected to the net. that means that the transparent nosepiece receives from the component a frame that has the entropy \"a can be reached over lan l.\" in the furtherance process, the transparent nosepiece floods the net with this entropy, so that other nosepieces also have the entropy about the component a. An advantage of the flood component is that it uses the shortest way of the net.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "The transparent nosepiece receives each frame on each side connected. the nosepiece table contains the entropy on which components are connected to the network. that means that the transparent nosepiece receives from the component a frame that has the entropy \"a can be reached over lan l.\" in the promotion process, the transparent nosepiece floods the network with this entropy, so that other nosepieces also have the entropy about the component a. An advantage of the flood component is that it utilize the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "The transparent nosepiece receives each frame on each side connected. the nosepiece table contains the entropy on which components are connected to the meshwork. that means that the transparent nosepiece receives from the component a frame that has the entropy \"a can be reached over lan l.\" in the furtherance process, the transparent nosepiece floods the meshwork with this entropy, so that other nosepieces also have the entropy about the component a. An advantage of the flood component is that it uses the shortest way of the meshwork.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking extension includes the acknowledgement \"ack\".\n- it contains the sequence-number ack(seq.no) and substantiate the frame(seq.no). \n- here, the acknowledgement ack can be given by the figure implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the piggybacking extension includes the acknowledgment \"ack\".\n- it contains the sequence-number ack(seq.no) and corroborate the frame(seq.no). \n- here, the acknowledgment ack can be given by the figure implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessity for the piggybacking extension includes the acknowledgment \"ack\".\n- it stop the sequence-number ack(seq.no) and reassert the frame(seq.no). \n- here, the acknowledgment ack can be given by the figure implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the necessary for the piggybacking extension includes the recognition \"ack\".\n- it contains the sequence-number ack(seq.no) and confirms the frame(seq.no). \n- here, the recognition ack can be given by the figure implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the piggybacking extension includes the acknowledgment \"ack\".\n- it contains the sequence-number ack(seq.no) and support the frame(seq.no). \n- here, the acknowledgment ack can be given by the figure implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footfall: Queue: 10 Service Package: 10 Service Package 2. footfall: Queue: 9 Service Package: 10 Service Package 3. footfall: 9 Service Package: 9 Service Package 4. footfall: Queue: 9 Service Package: 9 Package and so on. If you always arrive 9 Package per second and the host can process a maximum of 10 Package per second, there will never be 10 Package in Queue except in the first measure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Handshake protocol of three agencies + ds - menstruum controller in the credit mechanism of the ecstasy layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Handshake protocol of three agencies + ds - menstruum control in the quotation mechanism of the transfer bed + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Handshake protocol of three delegacy + ds - menstruum mastery in the reference mechanism of the exaltation layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Handshake protocol of three agencies + ds - menstruum command in the credit mechanism of the transport stratum + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "Handshake protocol of three delegacy + ds - menstruum ascendency in the reference mechanism of the ecstasy layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be process in 1 minute based on the assumption that the bundle arrives uniformly dispersed in the minute (i.e. 9 bundle per second) and we can process 10 bundle per second, this means that the agreement is occupied at 90% of the time with the processing of the bundle. in 10 % of the time the agreement does not have bundle to process. since the agreement can process more bundle in a second than we expect to arrive in a second, the agreement will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be march in 1 minute based on the assumption that the bundle arrives uniformly dispersed in the minute (i.e. 9 bundle per second) and we can process 10 bundle per second, this means that the arrangement is occupied at 90% of the meter with the processing of the bundle. in 10 % of the meter the arrangement does not have bundle to process. since the arrangement can process more bundle in a second than we expect to arrive in a second, the arrangement will be in a state with less than 10 bundle waiting in the queue all the meter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be serve in 1 minute based on the assumption that the bundle arrives uniformly dispersed in the minute (i.e. 9 bundle per second) and we can process 10 bundle per second, this means that the arrangement is occupied at 90% of the time with the processing of the bundle. in 10 % of the time the arrangement does not have bundle to process. since the arrangement can process more bundle in a second than we ask to arrive in a second, the arrangement will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be work in 1 minute based on the assumption that the bundle arrives uniformly dispersed in the minute (i.e. 9 bundle per second) and we can process 10 bundle per second, this means that the arrangement is occupied at 90% of the clip with the processing of the bundle. in 10 % of the clip the arrangement does not have bundle to process. since the arrangement can process more bundle in a second than we expect to arrive in a second, the arrangement will be in a state with less than 10 bundle waiting in the queue all the clip.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 parcel arrive in 1 minute 10 * 60 = 600 parcel can be processed in 1 minute based on the assumption that the parcel arrives uniformly dispersed in the minute (i.e. 9 parcel per second) and we can process 10 parcel per second, this means that the agreement is occupied at 90% of the sentence with the processing of the parcel. in 10 % of the sentence the agreement does not have parcel to process. since the agreement can process more parcel in a second than we expect to arrive in a second, the agreement will be in a state with less than 10 parcel waiting in the queue all the sentence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g,onwards) skip 2: (g,e,onwards) (g,f,driblet) = not the shortest skip 3: (e,c,onwards) (e,b,driblet) = not established in the unicat course of e a (e,f,driblet) = not established in the unicat course of e to skip 4: (c,a,onwards) (c,b,driblet) = not established in the unicat course of c a (c,d,driblet) = not established in the unicat course of c",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g,before) skip 2: (g,e,before) (g,f,drop) = not the shortest skip 3: (e,c,before) (e,b,drop) = not established in the unicat course of e a (e,f,drop) = not established in the unicat course of e to skip 4: (c,a,before) (c,b,drop) = not established in the unicat course of c a (c,d,drop) = not established in the unicat course of c",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1: (h,g,ahead) hop 2: (g,e,ahead) (g,f,bead) = not the shortest hop 3: (e,c,ahead) (e,b,bead) = not prove in the unicat course of e a (e,f,bead) = not prove in the unicat course of e to hop 4: (c,a,ahead) (c,b,bead) = not prove in the unicat course of c a (c,d,bead) = not prove in the unicat course of c",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hops 1: (h,g,forrader) hops 2: (g,e,forrader) (g,f,drib) = not the shortest hops 3: (e,c,forrader) (e,b,drib) = not launch in the unicat course of e a (e,f,drib) = not launch in the unicat course of e to hops 4: (c,a,forrader) (c,b,drib) = not launch in the unicat course of c a (c,d,drib) = not launch in the unicat course of c",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something has to be sent in one direction, in order to commit some data back with the ack. basically it is using the default operation of the station the ack to also commit some additional data back to the vector, instead of the station a new skeleton.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson dissemination is that the probability of x taking a discrete value is autonomous upon the previous values i.e. the probability is autonomous of the past. poisson dissemination is often used to model arrival of packets during an separation. the packet arrival meter modeled by the poisson dissemination have an exponential dissemination and constitute an autonomous identically distributed appendage. however, in practice it has been shown that the packet inter-arrival meter do not have an exponential dissemination, hence the error introduced by modeling them as poisson dissemination is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson distribution is that the probability of x taking a discrete value is independent upon the previous values i.e. the probability is independent of the past. poisson distribution is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson distribution have an exponential distribution and constitute an independent identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential distribution, hence the error introduced by modeling them as poisson distribution is significantly turgid.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson distribution is that the probability of x taking a discrete value is autonomous upon the previous values i.e. the probability is autonomous of the past. poisson distribution is often used to model arrival of packets during an separation. the packet arrival sentence modeled by the poisson distribution have an exponential distribution and constitute an autonomous identically distributed process. however, in practice it has been shown that the packet inter-arrival sentence do not have an exponential distribution, hence the error introduced by modeling them as poisson distribution is significantly bombastic.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson dispersal is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson dispersal is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson dispersal have an exponential dispersal and constitute an sovereign identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential dispersal, hence the error introduced by modeling them as poisson dispersal is significantly big.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson diffusion is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson diffusion is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson diffusion have an exponential diffusion and constitute an sovereign identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential diffusion, hence the error introduced by modeling them as poisson diffusion is significantly great.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if recipient have no chassis to beam, the beamer will never get an ack for his beamed inning\n- so when a chassis is obtain, the recipient have no chassis to beam and the count is ended, the recipient beam a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no build to beam, the beamer will never get an ack for his beamed builds\n- so when a build is receive, the receiver have no build to beam and the count is ended, the receiver beam a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no frame to transmit, the transmiter will never get an ack for his transmited flesh\n- so when a frame is received, the receiver have no frame to transmit and the count is ended, the receiver transmit a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no anatomy to beam, the beamer will never get an ack for his beamed framing\n- so when a anatomy is received, the receiver have no anatomy to beam and the count is ended, the receiver beam a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no frame to glow, the glower will never get an ack for his glowed frames\n- so when a frame is encounter, the receiver have no frame to glow and the count is ended, the receiver glow a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "response figure have to be able to contain datum + ack and not just ack or just datum. in this way the ack can be detain and beam along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "response form have to be capable to contain datum + ack and not just ack or just datum. in this way the ack can be detain and sent along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "response skeleton have to be able to contain datum + ack and not just ack or just datum. in this fashion the ack can be delayed and charge along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "response figure have to be able to contain datum + ack and not just ack or just datum. in this manner the ack can be check and sent along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "response flesh have to be able to contain datum + ack and not just ack or just datum. in this way the ack can be check and station along with datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in second 0, 9 packet arrive, the waiting time for the first w1 package is not given therefore supposes with 1 second. now there are 9 packet on the buff. in second 1, 9 packet more arrive. the buff is completely full of 10 packet, 8 more get off. the packet are starting to be enough with an average service rate of 10. in second 2, there is no packet will on the buff. 9 new arrive and are directly sufficient. from now on the buff will not be satisfy again. this means that there are 58 seconds with less than 10 packet waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in second 0, 9 packet arrive, the wait time for the first w1 package is not given therefore supposes with 1 second. now there are 9 packet on the buff. in second 1, 9 packet more arrive. the buff is completely full of 10 packet, 8 more get off. the packet are starting to be enough with an average service rate of 10. in second 2, there is no packet left on the buff. 9 new arrive and are directly sufficient. from now on the buff will not be fill again. this means that there are 58 seconds with less than 10 packet wait in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in second 0, 9 packet arrive, the wait meter for the first w1 package is not given therefore supposes with 1 second. now there are 9 packet on the buff. in second 1, 9 packet more arrive. the buff is completely full of 10 packet, 8 more get off. the packet are starting to be enough with an average service rate of 10. in second 2, there is no packet left on the buff. 9 new arrive and are directly sufficient. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 packet wait in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in second 0, 9 packet arrive, the await metre for the first w1 package is not given therefore supposes with 1 second. now there are 9 packet on the buff. in second 1, 9 packet more arrive. the buff is completely full of 10 packet, 8 more get off. the packet are starting to be enough with an average service rate of 10. in second 2, there is no packet left on the buff. 9 new arrive and are directly sufficient. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 packet await in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in second 0, 9 packet arrive, the expect time for the first w1 package is not given therefore supposes with 1 second. now there are 9 packet on the buff. in second 1, 9 packet more arrive. the buff is completely full of 10 packet, 8 more get off. the packet are starting to be enough with an average service rate of 10. in second 2, there is no packet depart on the buff. 9 new arrive and are directly sufficient. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 packet expect in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because clocks and immix data signals to form an single contemporize data stream of 1 and 0 plants.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because clocks and immix data signals to form an undivided contemporize data stream of 1 and 0 works.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester technique. this is because clocks and immix datum signals to form an exclusive synchronized datum stream of 1 and 0 works.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because clocks and immix data signals to form an exclusive synchronized data stream of 1 and 0 plant.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because clocks and immix data signals to form an single contemporize data stream of 1 and 0 plants.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on intermediate, there are 9 packet in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 packet in the buff) = p(0 packet) +...+ p(9 packet) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on median, there are 9 parcel in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the buff) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on middling, there are 9 parcel in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the buff) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on medium, there are 9 bundle in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 bundle in the buff) = p(0 bundle) +...+ p(9 bundle) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on intermediate, there are 9 packet in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 packet in the buff) = p(0 packet) +...+ p(9 packet) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 software arrive in 1 minute 10 * 60 = 600 software can be litigated in 1 minute based on the assumption that software arrive equally distributed in the minute (i.e. 9 software per second) and we can litigate 10 software per second, this means that the organization is fill with 90% of the time by litigating the software.In 10 % of the time the organization does not have software to litigate. as the organization can litigate more software in a second than we expect to arrive in a second, the organization will be in a state with less than 10 software waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 packet arrive in 1 minute 10 * 60 = 600 packet can be litigated in 1 minute based on the assumption that packet arrive equally distributed in the minute (i.e. 9 packet per second) and we can litigate 10 packet per second, this means that the organization is concern with 90% of the time by litigating the packet.In 10 % of the time the organization does not have packet to litigate. as the organization can litigate more packet in a second than we expect to arrive in a second, the organization will be in a state with less than 10 packet waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be litigated in 1 minute based on the presumption that bundle arrive evenly distributed in the minute (i.e. 9 bundle per second) and we can litigate 10 bundle per second, this means that the organization is occupied with 90% of the time by litigating the bundle.In 10 % of the time the organization does not have bundle to litigate. as the organization can litigate more bundle in a second than we expect to arrive in a second, the organization will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 packet arrive in 1 minute 10 * 60 = 600 packet can be litigated in 1 minute based on the supposition that packet arrive equally distributed in the minute (i.e. 9 packet per second) and we can litigate 10 packet per second, this means that the organization is occupied with 90% of the time by litigating the packet.In 10 % of the time the organization does not have packet to litigate. as the organization can litigate more packet in a second than we expect to arrive in a second, the organization will be in a state with less than 10 packet waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be litigated in 1 minute based on the assumption that bundle arrive equally distributed in the minute (i.e. 9 bundle per second) and we can litigate 10 bundle per second, this means that the organization is engage with 90% of the time by litigating the bundle.In 10 % of the time the organization does not have bundle to litigate. as the organization can litigate more bundle in a second than we expect to arrive in a second, the organization will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forward)\nhop 2:\n(g,f, forward), (g,e, forward)\nhop 3:\n(e,b, forward), (e,c, forward), (e,f, drop)<=\u00a0 because of touch\n(f,c, drop)<= because of touch, (f,d, forward)\nhop 4:\n(b,c, drop)<= becuase of touch, (b,a, forward), (c,a drop)<= becuase of touch, (d,a, drop)<= becuase of touch",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of gibe\n(f,c, drop)<= because of gibe, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of gibe, (b,a, forrader), (c,a drop)<= becuase of gibe, (d,a, drop)<= becuase of gibe",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, before)\nhop 2:\n(g,f, before), (g,e, before)\nhop 3:\n(e,b, before), (e,c, before), (e,f, drop)<=\u00a0 because of meet\n(f,c, drop)<= because of meet, (f,d, before)\nhop 4:\n(b,c, drop)<= becuase of meet, (b,a, before), (c,a drop)<= becuase of meet, (d,a, drop)<= becuase of meet",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, beforehand)\nhop 2:\n(g,f, beforehand), (g,e, beforehand)\nhop 3:\n(e,b, beforehand), (e,c, beforehand), (e,f, drop)<=\u00a0 because of twin\n(f,c, drop)<= because of twin, (f,d, beforehand)\nhop 4:\n(b,c, drop)<= becuase of twin, (b,a, beforehand), (c,a drop)<= becuase of twin, (d,a, drop)<= becuase of twin",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The figure can terminate wonder acks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The underframe can finish oppugn acks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The framing can block interrogate acks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The shape can halt interview acks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The underframe can contain wonder acks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the prop is that all is know the multicast tree. to retrace a hybridizing tree for multicasting, you also have to add the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is know the multicast tree. to construct a hybridizing tree for multicasting, you also have to add the entropy of the other is of the multicast grouping.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the holding is that all is know the multicast tree. to rebuild a cross tree for multicasting, you also have to bestow the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the place is that all is know the multicast tree. to reconstruct a cross tree for multicasting, you also have to supply the entropy of the other is of the multicast radical.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is know the multicast tree. to reconstruct a cross tree for multicasting, you also have to summate the entropy of the other is of the multicast radical.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forrader), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forrader), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forrader), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forrader), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forrader), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it make with high-exponent in ordering to work very performant with a high amount of data.\njob is that it is not that good, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it make with high-king in ordering to work very performant with a high amount of data.\njob is that it is not that good, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it make with mellowed-force in order to work very performant with a mellowed amount of data.\njob is that it is not that good, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it make with mellowed-power in lodge to work very performant with a mellowed amount of data.\njob is that it is not that good, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it make with high-power in rescript to work very performant with a high amount of datum.\njob is that it is not that good, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the ego-clocking there is no motive to have specific pedigree to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the ego-clocking there is no need to have specific pedigree to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific bloodline to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no indigence to have specific pedigree to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific stock to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the quotation added to the next fabric has to refer to the fabric incur so that it can be allocated to the related data. Otherwise, you cannot detect what fabric is reaffirmed with your quote.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the quotation added to the next fabric has to refer to the fabric received so that it can be allocated to the related datum. Otherwise, you cannot observe what fabric is reaffirmed with your quote.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the quotation summate to the next model has to refer to the model get so that it can be allocated to the related data. Otherwise, you cannot discover what model is reaffirmed with your quote.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the quotation added to the next model has to refer to the model received so that it can be allocated to the related datum. Otherwise, you cannot reveal what model is reaffirmed with your quote.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the quotation summate to the next framework has to refer to the framework received so that it can be allocated to the related datum. Otherwise, you cannot reveal what framework is reaffirmed with your quote.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need honorable performance and honorable channel utilization. and they also have perfect watches for polisher.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need adept performance and adept channel utilization. and they also have perfect watches for fender.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need good performance and good line utilization. and they also have perfect watches for cowcatcher.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need adept performance and adept groove utilization. and they also have perfect watches for buffer.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need good performance and good line utilization. and they also have perfect watches for fender.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness numeral is 0 and the next successiveness numeral and the next ack-successiveness numeral to be expected is yield",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession numerical is 0 and the next succession numerical and the next ack-succession numerical to be expected is break",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence numerical is 0 and the next sequence numerical and the next ack-sequence numerical to be expected is apply",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence numeral is 0 and the next sequence numeral and the next ack-sequence numeral to be expected is feed",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness numeric is 0 and the next successiveness numeric and the next ack-successiveness numeric to be expected is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only demand to broadcast out the datum as one bundle and dont have to broadcast a exclusive bundle for each receiver, you also dont demand to know all the receivers as the tree will address the transmission.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only demand to send out the datum as one mailboat and dont have to send a undivided mailboat for each receiver, you also dont demand to know all the receivers as the tree will handle the transmission.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only postulate to air out the datum as one mailboat and dont have to air a single mailboat for each receiver, you also dont postulate to know all the receivers as the tree will address the transmission.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the tip is that all is knowing the multicast tree. to progress a tree that spans for multicasting, you also have to numerate the s of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the crown is that all is bed the multicast tree. to build a tree that spans for multicasting, you also have to matter the entropy of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the baksheesh is that all is jazz the multicast tree. to make a tree that spans for multicasting, you also have to count the entropy of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the pourboire is that all is bang the multicast tree. to build a tree that spans for multicasting, you also have to count the randomness of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the tip is that all is eff the multicast tree. to progress a tree that spans for multicasting, you also have to count the information of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\navail: 10 packet\n\n2. step:\nqueue: 9 packet\navail: 10 packet\n\n3.step:\nqueue: 9 packet\navail: 9 packet\n\n4. step:\nqueue: 9 packet\navail: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the waiter can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\navail: 10 packet\n\n2. step:\nqueue: 9 packet\navail: 10 packet\n\n3.step:\nqueue: 9 packet\navail: 9 packet\n\n4. step:\nqueue: 9 packet\navail: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the server can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\navail: 10 packet\n\n2. step:\nqueue: 9 packet\navail: 10 packet\n\n3.step:\nqueue: 9 packet\navail: 9 packet\n\n4. step:\nqueue: 9 packet\navail: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the server can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\navail: 10 packet\n\n2. step:\nqueue: 9 packet\navail: 10 packet\n\n3.step:\nqueue: 9 packet\navail: 9 packet\n\n4. step:\nqueue: 9 packet\navail: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the waiter can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\navail: 10 packet\n\n2. step:\nqueue: 9 packet\navail: 10 packet\n\n3.step:\nqueue: 9 packet\navail: 9 packet\n\n4. step:\nqueue: 9 packet\navail: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the server can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one overture, in order to be able to send some data back with the ack. basically it is using the default operation of charge the ack to also send some additional data back to the transmitter, rather of charge a new frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one advance, in order to be able to send some data back with the ack. basically it is using the default operation of air the ack to also send some additional data back to the transmitter, instead of air a new chassis.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one approach, in order to be able to send some data back with the ack. basically it is using the default operation of broadcast the ack to also send some additional data back to the transmitter, rather of broadcast a new shape.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only specify the optimal route from the other knobs to this knob, but also the optimal routes from this knob to the other knobs. link land routing can be used to construct multicast traverse tree by first running the link land routing procedure to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any route between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only specify the optimal route from the other knobs to this knob, but also the optimal road from this knob to the other knobs. link land routing can be used to construct multicast traverse tree by first running the link land routing procedure to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any route between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only condition the optimal route from the other knobs to this knob, but also the optimal road from this knob to the other knobs. link land routing can be used to construct multicast traverse trees by first running the link land routing procedure to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any route between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the diminished package is at least 64 bytes, the maximum diam of the impact orbit is calculated by the time it takes for the diminished package to conciliate at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact orbit diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the modest package is at least 64 bytes, the maximum diam of the impact orbit is calculated by the time it takes for the modest package to accommodate at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact orbit diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the belittled package is at least 64 bytes, the maximum diam of the impact orbit is calculated by the time it takes for the belittled package to accommodate at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact orbit diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the modest package is at least 64 byte, the maximum diam of the impact orbit is calculated by the time it takes for the modest package to accommodate at a certain speed. therefore, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact orbit diam is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "Since the humble package is at least 64 bytes, the maximum diameter of the impact orbit is calculated by the time it takes for the humble package to conciliate at a certain speed. therefore, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while at 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. therefore, the impact orbit diameter is increased 100 times.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 software because we receive only 9 software and answer 10 software. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 software because we find only 9 software and resolve 10 software. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 software because we receive only 9 software and suffice 10 software. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 parcel because we have only 9 parcel and suffice 10 parcel. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 software because we have only 9 software and answer 10 software. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes nation when it is in equipoise. however, the probability of land pk to find the process on ground k no longer changes, so dpk (t )/dt = 0. in equipoise, is deduced from dpk (t )/dt = 0 that the probability period, also call period, on earth k is equal to the probability period off earth k. this generates the equations of global equipoise: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes nation when it is in equipoise. however, the chance of land pk to find the process on ground k no longer changes, so dpk (t )/dt = 0. in equipoise, is deduced from dpk (t )/dt = 0 that the chance flow, also squall flow, on earth k is equal to the chance flow off earth k. this generates the equations of global equipoise: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes nation when it is in counterbalance. however, the chance of land pk to find the process on ground k no longer changes, so dpk (t )/dt = 0. in counterbalance, is deduced from dpk (t )/dt = 0 that the chance menses, also called menses, on earth k is equal to the chance menses off earth k. this generates the equations of global counterbalance: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes nation when it is in balance. however, the chance of land pk to find the process on ground k no longer changes, so dpk (t )/dt = 0. in balance, is deduced from dpk (t )/dt = 0 that the chance flow, also phone flow, on earth k is equal to the chance flow off earth k. this generates the equations of global balance: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes nation when it is in equipoise. however, the chance of land pk to observe the process on ground k no longer changes, so dpk (t )/dt = 0. in equipoise, is deduced from dpk (t )/dt = 0 that the chance flow, also called flow, on earth k is equal to the chance flow off earth k. this generates the equations of global equipoise: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the prerequisite are listed below 1. an interlocal agreement between the agencies must be blessed and filed with the county auditor or published online; 2. the original catching agency has complied with all the prerequisite and publishes the collection online; and 3. the trafficker agrees with the agreement through the initial collection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requisite are listed below 1. an interlocal agreement between the agencies must be blessed and filed with the county auditor or published online; 2. the original catching agency has complied with all the requisite and publishes the collection online; and 3. the seller agrees with the agreement through the initial collection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the demand are listed below 1. an interlocal agreement between the agencies must be blessed and filed with the county auditor or published online; 2. the original catching agency has complied with all the demand and publishes the collection online; and 3. the seller agrees with the agreement through the initial collection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the essential are listed below 1. an interlocal agreement between the agencies must be blessed and filed with the county auditor or published online; 2. the original contracting agency has complied with all the essential and publishes the appeal online; and 3. the trafficker agrees with the agreement through the initial appeal.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the demand are listed below 1. an interlocal agreement between the agencies must be blessed and filed with the county auditor or published online; 2. the original contracting agency has complied with all the demand and publishes the ingathering online; and 3. the vendor agrees with the agreement through the initial ingathering.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial number of the installment is 0 and the next installment number and the next installment number ack to be wait is afford",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial number of the instalment is 0 and the next instalment number and the next instalment number ack to be expected is reach",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial act of the episode is 0 and the next episode act and the next episode act ack to be await is render",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial turn of the installment is 0 and the next installment turn and the next installment turn ack to be expected is break",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial bit of the episode is 0 and the next episode bit and the next episode bit ack to be ask is dedicate",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each box on each connected side. the table of infinite contains the information about the portions that are connected to the network. that pretend that the transparent space receives from the portion a fabric that has the information \"a can be reached on lan l.\" in the process of forwarding, the transparent space floods the network with this information, so that other infinite also have the information about the portion a. a flood welfare is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space encounter each box on each connected side. the table of quad contains the information about the components that are connected to the network. that pretend that the transparent space encounter from the component a framework that has the information \"a can be reached on lan l.\" in the process of forwarding, the transparent space floods the network with this information, so that other quad also have the information about the component a. a flood welfare is that it expend the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented connection - error ascfinishant - finish to finish upward current udp: -no connection -no current ascfinisher -no error ascfinishing or retransmission -maybe used with program/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented association - error ascendant - end to end upward catamenia udp: -no association -no catamenia ascender -no error ascending or retransmission -maybe used with program/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented connexion - error ascceaseant - cease to cease upward menstruum udp: -no connexion -no menstruum ascceaseer -no error ascent or retransmission -maybe used with program/multicast and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, forward) (d, a, forward) (b, a, forward) (e, b, forward) (g, e, upwards) (h, g, forrard) (f, c, forrard) (c, b, forrard) c is not on the unicast itinerary from b to (c, d, onwards) c is not on the unicast itinerary from d to (c, e, forrard) c is not on the unicat itinerary from e to (d, f, forrard) d is not on the unicast itinerary from f to (f, g, onwards) f is not on the unicast itinerary from g to a leap 2e, a, forrard) (f, forrard) skip 3g, a, hereafter) skip 4h, a, forrard)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requisite for the piggybacking elongation include the acknowledgment \"ack\".\n- it contains the episode-number ack(seq.no) and sustain the frame(seq.no). \n- here, the acknowledgment ack can be given by the underframe implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requisite for the piggybacking elongation includes the acknowledgment \"ack\".\n- it comprise the episode-number ack(seq.no) and confirm the frame(seq.no). \n- here, the acknowledgment ack can be given by the underframe implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all destination in kinsperson a. except 0 and 127 are detainment for network and programme",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all finish in home a. except 0 and 127 are hold for network and program",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all finish in house a. except 0 and 127 are handle for network and broadcast",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all address in fellowship a. except 0 and 127 are hold for network and programme",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all destination in fellowship a. except 0 and 127 are hold for mesh and programme",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum reserve is not depending on the position, some have more inning than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum relief is not depending on the position, some have more inning than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum substitute is not reckon on the locating, some have more inning than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum replacement is not look on the positioning, some have more inning than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "candor is the problem\uff0cthe data substitute is not count on the emplacement, some have more inning than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own hybridizing tree but is do not ask to dwell the hybridizing trees each router has information which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own mark tree but is do not need to go the mark tree each router has information which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own mark tree but is do not demand to know the mark trees each router has information which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own hybridizing tree but is do not ask to be the hybridizing trees each router has information which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own mark tree but is do not take to live the mark tree each router has information which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the hesitation to datum is not calculated in positioning, some have more form than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the hesitancy to datum is not calculated in place, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the indisposition to data is not count in positioning, some have more physique than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the hesitancy to data is not forecast in place, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the reluctance to datum is not look in positioning, some have more bod than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is know the multicast tree. to construct a crisscross tree for multicasting, you also have to add the information of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is live the multicast tree. to construct a cross tree for multicasting, you also have to add the randomness of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is recognise the multicast tree. to construct a cross tree for multicasting, you also have to add the information of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is cognize the multicast tree. to construct a cross tree for multicasting, you also have to impart the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is bed the multicast tree. to construct a cross tree for multicasting, you also have to sum the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no demand to have a specific line to transmit the synchronization signaling. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no demand to have a specific lineage to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no need to have a specific line to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no demand to have a specific line to transmit the synchronization sign. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no demand to have a specific line to transmit the synchronization sign. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the typeface, because the arriver step (9) is lower than the service step (10). \nso on median the buffer is always below its maximum capacitance of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the typeface, because the comer yard (9) is lower than the servicing yard (10). \nso on median the buffer is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the typeface, because the arrival footstep (9) is lower than the overhaul footstep (10). \nso on median the buffer is always below its maximum capability of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 package, since more package are service than the package arriving in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 share, since more share are serve than the share arriving in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 tract, since more tract are suffice than the tract arriving in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 portion, since more portion are attend than the portion arrive in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 tract, since more tract are dish than the tract arriving in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be ask in 1 minute based on the assumption that the bundle arrives evenly dispense in the minute (i.e. 9 bundle per second) and we can sue 10 bundle per second, this means that the system is occupied in 90% of the time with demanding the bundle. in 10 % of the time the system does not have bundle to sue. since the system can demand more bundle in a second than we hope to arrive in a second, the system will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be necessitate in 1 minute based on the assumption that the bundle arrives evenly broadcast in the minute (i.e. 9 bundle per second) and we can sue 10 bundle per second, this means that the system is occupied in 90% of the time with demanding the bundle. in 10 % of the time the system does not have bundle to sue. since the system can demand more bundle in a second than we hope to arrive in a second, the system will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be require in 1 minute based on the assumption that the bundle arrives evenly allot in the minute (i.e. 9 bundle per second) and we can sue 10 bundle per second, this means that the system is occupied in 90% of the time with demanding the bundle. in 10 % of the time the system does not have bundle to sue. since the system can demand more bundle in a second than we hope to arrive in a second, the system will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 software arrive in 1 minute 10 * 60 = 600 software can be demanded in 1 minute based on the assumption that the software arrives evenly stagger in the minute (i.e. 9 software per second) and we can sue 10 software per second, this intend that the system is occupied in 90% of the time with demanding the software. in 10 % of the time the system does not have software to sue. since the system can demand more software in a second than we hope to arrive in a second, the system will be in a state with less than 10 software waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 software arrive in 1 minute 10 * 60 = 600 software can be demanded in 1 minute based on the assumption that the software arrives evenly distributed in the minute (i.e. 9 software per second) and we can sue 10 software per second, this signify that the arrangement is occupied in 90% of the time with demanding the software. in 10 % of the time the arrangement does not have software to sue. since the arrangement can demand more software in a second than we hope to arrive in a second, the arrangement will be in a state with less than 10 software waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented to the connection -proceeding of error -from cease to cease to the raise of udp menstruum: -no connection -no menstruum ascceaseer -no error raise or retransmission -perhaps used with transmission/multitransmission and streaming",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, forrader) (f, c, forrader) (c, b, forrader) c is not determine on the unicast track from b to a (c, d, onwards) c is not determine on the unicast track from d to (c, e, forrader) c is not determine on the unicast track from e to (d, f, forrader) d is not determine on the unicast track from f to (f, g, forrader) f is not determine on the unicast track from g to a leap 2e, a, onwards) (f, a, forrader) jump 3g, a, forrader) jump 4h, a, forrader)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, onwards) (f, c, onwards) (c, b, onwards) c is not constitute on the unicast itinerary from b to a (c, d, onwards) c is not constitute on the unicast itinerary from d to (c, e, onwards) c is not constitute on the unicast itinerary from e to (d, f, onwards) d is not constitute on the unicast itinerary from f to (f, g, onwards) f is not constitute on the unicast itinerary from g to a leap 2e, a, onwards) (f, a, onwards) jump 3g, a, onwards) jump 4h, a, onwards)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, forrader) (f, c, forrader) (c, b, forrader) c is not discover on the unicast track from b to a (c, d, onwards) c is not discover on the unicast track from d to (c, e, forrader) c is not discover on the unicast track from e to (d, f, forrader) d is not discover on the unicast track from f to (f, g, forrader) f is not discover on the unicast track from g to a leap 2e, a, onwards) (f, a, forrader) jump 3g, a, forrader) jump 4h, a, forrader)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, onwards) (f, c, onwards) (c, b, onwards) c is not encounter on the unicast track from b to a (c, d, onwards) c is not encounter on the unicast track from d to (c, e, onwards) c is not encounter on the unicast track from e to (d, f, onwards) d is not encounter on the unicast track from f to (f, g, onwards) f is not encounter on the unicast track from g to a leap 2e, a, onwards) (f, a, onwards) jump 3g, a, onwards) jump 4h, a, onwards)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the piggybacking indication admit the acknowledgement \"ack\".\n- it contains the episode-number ack(seq.no) and confirms the frame(seq.no). \n- here, the acknowledgement ack can be given by the inning implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 parcel\nhelp: 10 parcel\n\n2. step:\nqueue: 9 parcel\nhelp: 10 parcel\n\n3.step:\nqueue: 9 parcel\nhelp: 9 parcel\n\n4. step:\nqueue: 9 parcel\nhelp: 9 parcel\n\nand so on. if there will always arrive 9 parcel per second and the server can serve maximum 10 parcel per second, there will never be 10 parcel in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\navail: 10 packet\n\n2. step:\nqueue: 9 packet\navail: 10 packet\n\n3.step:\nqueue: 9 packet\navail: 9 packet\n\n4. step:\nqueue: 9 packet\navail: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the server can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 parcel\nservice: 10 parcel\n\n2. step:\nqueue: 9 parcel\nservice: 10 parcel\n\n3.step:\nqueue: 9 parcel\nservice: 9 parcel\n\n4. step:\nqueue: 9 parcel\nservice: 9 parcel\n\nand so on. if there will always arrive 9 parcel per second and the server can serve maximum 10 parcel per second, there will never be 10 parcel in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 bundle\navail: 10 bundle\n\n2. step:\nqueue: 9 bundle\navail: 10 bundle\n\n3.step:\nqueue: 9 bundle\navail: 9 bundle\n\n4. step:\nqueue: 9 bundle\navail: 9 bundle\n\nand so on. if there will always arrive 9 bundle per second and the server can serve maximum 10 bundle per second, there will never be 10 bundle in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 bundle\nhelp: 10 bundle\n\n2. step:\nqueue: 9 bundle\nhelp: 10 bundle\n\n3.step:\nqueue: 9 bundle\nhelp: 9 bundle\n\n4. step:\nqueue: 9 bundle\nhelp: 9 bundle\n\nand so on. if there will always arrive 9 bundle per second and the server can serve maximum 10 bundle per second, there will never be 10 bundle in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window gore size of 1, the sequence should always be right. if the window gore size is clean that 1, there are no requirements, but the size is restrict by the window gore size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window venire size of 1, the sequence should always be right. if the window venire size is clean that 1, there are no requirements, but the size is determine by the window venire size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window board size of 1, the succession should always be correct. if the window board size is clean that 1, there are no requirements, but the size is fix by the window board size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window jury size of 1, the episode should always be right. if the window jury size is clean that 1, there are no requirements, but the size is limited by the window jury size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window venire size of 1, the episode should always be correct. if the window venire size is clean that 1, there are no requirements, but the size is bound by the window venire size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you just need to send the datum as a bundle and you don't have to send a single bundle for each receiver, you also don't need to bed all the receivers as the tree will handle the contagion.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you just need to send the datum as a parcel and you don't have to send a single parcel for each receiver, you also don't need to bonk all the receivers as the tree will handle the infection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you just need to air the datum as a bundle and you don't have to air a single bundle for each receiver, you also don't need to fuck all the receivers as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you just need to send the datum as a parcel and you don't have to send a single parcel for each receiver, you also don't need to eff all the liquidator as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence subroutine is 0 and the next sequence subroutine is devote and the next ack sequence subroutine is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence routine is 0 and the next sequence routine is founder and the next ack sequence routine is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness routine is 0 and the next successiveness routine is establish and the next ack successiveness routine is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence subroutine is 0 and the next sequence subroutine is pass and the next ack sequence subroutine is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence number is 0 and the next sequence number is given and the next ack sequence number is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in stratum a. except 0 and 127 are appropriate for meshwork and syllabus",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all reference in stratum a. except 0 and 127 are appropriate for meshwork and broadcast",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all destination in category a. except 0 and 127 are appropriate for meshwork and curriculum",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in division a. except 0 and 127 are appropriate for net and programme",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in class a. except 0 and 127 are appropriate for net and plan",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the moment orient protocol should be used, as the character orient protocol requires additional time due to the insertion of dles into the frame and convert to the proper encoding. in addition, the enumeration orient protocol leads to desynchronisation in the event of a infection error and is therefore not authentic enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the moment orient protocol should be used, as the character orient protocol requires accessional time due to the insertion of dles into the frame and convert to the proper encoding. in accession, the enumeration orient protocol leads to desynchronisation in the event of a transmission error and is therefore not honest enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the moment orientate protocol should be used, as the character orientate protocol requires additional time due to the insertion of dles into the frame and convert to the proper encoding. in addition, the enumeration orientate protocol leads to desynchronisation in the event of a transmittal error and is therefore not reliable enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the moment orientate protocol should be used, as the character orientate protocol requires gainal time due to the insertion of dles into the frame and convert to the proper encoding. in gain, the enumeration orientate protocol leads to desynchronisation in the event of a transmission error and is therefore not authentic enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the moment tailor protocol should be used, as the character tailor protocol requires plusal time due to the insertion of dles into the frame and convert to the proper encoding. in plus, the enumeration tailor protocol leads to desynchronisation in the event of a transmission error and is therefore not honest enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the distich tree for a certain node is that it does not only specify the optimal route from the other nodes to this node, but also the optimal routes from this node to the other nodes. link province routing can be used to fabricate multicast distich trees by first running the link province routing procedure to get the distich tree for a certain node x. this distich tree could already be used as the multicast distich tree for node x, but it can be optimized by dispatch all edges that are not part of any route between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the duo tree for a certain node is that it does not only specify the optimal route from the other nodes to this node, but also the optimal routes from this node to the other nodes. link province routing can be used to retrace multicast duo trees by first running the link province routing procedure to get the duo tree for a certain node x. this duo tree could already be used as the multicast duo tree for node x, but it can be optimized by removing all edges that are not part of any route between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the duad tree for a certain node is that it does not only specify the optimal route from the other nodes to this node, but also the optimal routes from this node to the other nodes. link province routing can be used to reconstruct multicast duad trees by first running the link province routing procedure to get the duad tree for a certain node x. this duad tree could already be used as the multicast duad tree for node x, but it can be optimized by removing all edges that are not part of any route between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the dyad tree for a certain node is that it does not only specify the optimal route from the other nodes to this node, but also the optimal routes from this node to the other nodes. link province routing can be used to construct multicast dyad trees by first running the link province routing procedure to get the dyad tree for a certain node x. this dyad tree could already be used as the multicast dyad tree for node x, but it can be optimized by murder all edges that are not part of any route between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the bridge tree for a certain node is that it does not only specify the optimal route from the other nodes to this node, but also the optimal routes from this node to the other nodes. link province routing can be used to fabricate multicast bridge trees by first running the link province routing procedure to get the bridge tree for a certain node x. this bridge tree could already be used as the multicast bridge tree for node x, but it can be optimized by off all edges that are not part of any route between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the result frames have to be capable to carry data + ack and not only ack or only data. this agency the ack can be delayed and commit along with data in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the settlement frames have to be capable to carry data + ack and not only ack or only data. this means the ack can be detain and sent along with data in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the resolution somas have to be capable to carry data + ack and not only ack or only data. this way the ack can be detain and charge along with data in one soma.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the closure frames have to be capable to carry data + ack and not only ack or only data. this way the ack can be check and direct along with data in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the resolve bods have to be capable to carry data + ack and not only ack or only data. this direction the ack can be delayed and sent along with data in one bod.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection oriented -mistake ascstopence -stop to stop flux ascstopence udp: -connectionless -no flux ascstopence -no mistake ascstopence or retransmission -maybe used with broadcast/multicast and pullulate",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 parcel because we find only 9 parcel and avail 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the metre less than 10 software because we receive only 9 software and assist 10 software.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 parcel because we meet only 9 parcel and avail 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the meter less than 10 package because we incur only 9 package and aid 10 package.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the metre less than 10 parcel because we receive only 9 parcel and aid 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "There must be the whole sentence less than 10 packet because we receive only 9 packet and reply to 10 packet.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "There must be the whole sentence less than 10 parcel because we receive only 9 parcel and answer to 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "There must be the whole sentence less than 10 packet because we obtain only 9 packet and respond to 10 packet.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "There must be the whole sentence less than 10 software because we receive only 9 software and respond to 10 software.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "There must be the whole sentence less than 10 bundle because we receive only 9 bundle and respond to 10 bundle.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, forrad) skip 2: (g,f, forrad), (g,e, forrad) skip 3: (e,b, forrad), (e,c, forrad), (e,f, fall)======================================================================================================================================================================================================================================================================= =====================================================================================================================================================================================================",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, onwards) skip 2: (g,f, onwards), (g,e, onwards) skip 3: (e,b, onwards), (e,c, onwards), (e,f, fall)======================================================================================================================================================================================================================================================================= =====================================================================================================================================================================================================",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, ahead) skip 2: (g,f, ahead), (g,e, ahead) skip 3: (e,b, ahead), (e,c, ahead), (e,f, fall)======================================================================================================================================================================================================================================================================= =====================================================================================================================================================================================================",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, frontward) skip 2: (g,f, frontward), (g,e, frontward) skip 3: (e,b, frontward), (e,c, frontward), (e,f, fall)======================================================================================================================================================================================================================================================================= =====================================================================================================================================================================================================",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, forth) skip 2: (g,f, forth), (g,e, forth) skip 3: (e,b, forth), (e,c, forth), (e,f, fall)======================================================================================================================================================================================================================================================================= =====================================================================================================================================================================================================",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "runs with gamey-power in order to run very performant with a quantity of gamey datum. run is that it is not that right, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "wreak with gamey-power in order to employment very performant with a quantity of gamey data. employment is that it is not that right, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "run with gamey-power in order to influence very performant with a quantity of gamey data. influence is that it is not that right, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "form with gamey-power in order to crop very performant with a quantity of gamey data. crop is that it is not that right, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "run with gamey-power in order to act very performant with a quantity of gamey data. act is that it is not that correct, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the outgrowth still changes lands when it is in equilibrium. however, the probability of land pk to find the outgrowth on ground k no longer changes, so dpk (t )/dt = 0. in equilibrium, is deduced from dpk (t )/dt = 0 that the probability menses, also called menses, on world k equals the probability menses off world k. this makes the equations of global equilibrium: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane size of 1, the sequence must always be correct.\nif the windowpane size is keen than 1, there are no requirements, but the size is trammel by the windowpane size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane size of 1, the sequence must always be correct.\nif the windowpane size is keen than 1, there are no necessary, but the size is trammel by the windowpane size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane size of 1, the sequence must always be correct.\nif the windowpane size is keen than 1, there are no requirements, but the size is trammel by the windowpane size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the sentence less than 10 bundle because we meet only 9 bundle and function 10 bundle.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the meter less than 10 parcel because we receive only 9 parcel and function 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the sentence less than 10 package because we encounter only 9 package and run 10 package.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the clip less than 10 parcel because we experience only 9 parcel and function 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 parcel because we find only 9 parcel and function 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented association - wrongdoing restriction -terminal-to-terminal flow restriction udp: -no association -no flow restriction -no wrongdoing restriction or retransmission -perhaps used with transmission/multicast and pull",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented connecter - fault confinement -end-to-end flow confinement udp: -no connecter -no flow confinement -no fault confinement or retransmission -perhaps used with transmission/multicast and pull",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -oriented connector - mistake confinement -end-to-end flow confinement udp: -no connector -no flow confinement -no mistake confinement or retransmission -perhaps used with transmission/multicast and pull",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slither window, because they need a honorable throughput and honorable duct utilisation. and also they have perfect alfilaria for buffer.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slither window, because they postulate a sound throughput and sound canal utilisation. and also they have perfect filaria for buffer.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 packet arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 packet in the buff. at second 1, 9 more packet arrive. the buff is completely filled with 10 packet, 8 more are dropped.  the packet are starting to be suffice with an average service rate of 10. at second 2, there are no packet left in the buff. 9 new ace arrive and are directly suffice. from now on the buff won\u2019t fill up again. this means there are 58 seconds with less than 10 packet waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 packet arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 packet in the buff. at second 1, 9 more packet arrive. the buff is completely filled with 10 packet, 8 more are dropped.  the packet are starting to be suffice with an average service rate of 10. at second 2, there are no packet left in the buff. 9 new ones arrive and are directly suffice. from now on the buff won\u2019t fill up again. this mean there are 58 seconds with less than 10 packet waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 packet arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 packet in the buff. at second 1, 9 more packet arrive. the buff is completely fulfilled with 10 packet, 8 more are dropped.  the packet are starting to be suffice with an average service rate of 10. at second 2, there are no packet left in the buff. 9 new i arrive and are directly suffice. from now on the buff won\u2019t fulfill up again. this means there are 58 seconds with less than 10 packet waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 packet arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 packet in the buff. at second 1, 9 more packet arrive. the buff is completely fulfilled with 10 packet, 8 more are dropped.  the packet are starting to be suffice with an average service rate of 10. at second 2, there are no packet left in the buff. 9 new ones arrive and are directly suffice. from now on the buff won\u2019t fulfill up again. this entail there are 58 seconds with less than 10 packet waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 packet arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 packet in the buff. at second 1, 9 more packet arrive. the buff is completely filled with 10 packet, 8 more are dropped.  the packet are starting to be suffice with an average service rate of 10. at second 2, there are no packet left in the buff. 9 new ones arrive and are directly suffice. from now on the buff won\u2019t fill up again. this entail there are 58 seconds with less than 10 packet waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "cipher manchester differential is the estimable choice due to its good auto-clocking function which is important in a congested mesh. it also provides misplay sensing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme arrivals of poisson has been justified on the grounds that the aggregation of many processes of supreme renewal and identically distributed tends to poisson process when the turn increases. the poisson processes are conventional in traffic application scenarios that include a large turn of supreme traffic watercourses. the theoretical background behind the use comes from the palm theorem (arrowsmith and others 2015). it states that under appropriate but mild conditions, a large turn of multiplexed water courses approach a poisson process as the turn of watercourses grows. still, private tariffs decrease to keep the aggregate rate constant. but, the aggregation of traffic does not always have to result in a poisson process. so it fence if the above criteria are applied.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme arrivals of poisson has been justified on the grounds that the aggregation of many processes of supreme renewal and identically distributed tends to poisson process when the numeral increases. the poisson processes are conventional in traffic application scenarios that include a large numeral of supreme traffic watercourses. the theoretical background behind the use comes from the palm theorem (arrowsmith and others 2015). it states that under appropriate but mild conditions, a large numeral of multiplexed water courses approach a poisson process as the numeral of watercourses grows. still, private tariffs decrease to keep the aggregate rate constant. but, the aggregation of traffic does not always have to result in a poisson process. so it argues if the above criteria are applied.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of independent arrivals of poisson has been justified on the grounds that the aggregation of many processes of independent renewal and identically distributed tends to poisson process when the routine increases. the poisson processes are conventional in traffic application scenarios that include a large routine of independent traffic watercourses. the theoretical background behind the use comes from the palm theorem (arrowsmith and others 2015). it states that under appropriate but mild conditions, a large routine of multiplexed water courses approach a poisson process as the routine of watercourses grows. still, private tariffs decrease to keep the aggregate rate constant. but, the aggregation of traffic does not always have to result in a poisson process. so it argues if the above touchstone are applied.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme arrivals of poisson has been justified on the grounds that the aggregation of many processes of supreme renewal and identically distributed tends to poisson process when the number increases. the poisson processes are conventional in traffic application scenarios that include a large number of supreme traffic watercourses. the theoretical background behind the use comes from the palm theorem (arrowsmith and others 2015). it states that under appropriate but mild conditions, a large number of multiplexed water courses approach a poisson process as the number of watercourses grows. still, private tariffs decrease to keep the aggregate rate constant. but, the aggregation of traffic does not always have to result in a poisson process. so it reason if the above standard are applied.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of independent arrivals of poisson has been justified on the grounds that the aggregation of many processes of independent renewal and identically distributed tends to poisson process when the numeral increases. the poisson processes are conventional in traffic application scenarios that include a large numeral of independent traffic watercourses. the theoretical background behind the use comes from the palm theorem (arrowsmith and others 2015). it states that under appropriate but mild conditions, a large numeral of multiplexed water courses approach a poisson process as the numeral of watercourses grows. still, private tariffs decrease to keep the aggregate rate constant. but, the aggregation of traffic does not always have to result in a poisson process. so it argues if the above criterion are applied.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane sizing of 1, the successiveness must always be right.\nif the windowpane sizing is neat than 1, there are no requirements, but the sizing is fix by the windowpane sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane sizing of 1, the episode must always be right.\nif the windowpane sizing is neat than 1, there are no requirements, but the sizing is limited by the windowpane sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane sizing of 1, the episode must always be right.\nif the windowpane sizing is neat than 1, there are no requirements, but the sizing is set by the windowpane sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane sizing of 1, the succession must always be right.\nif the windowpane sizing is neat than 1, there are no requirements, but the sizing is limited by the windowpane sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane sizing of 1, the successiveness must always be right.\nif the windowpane sizing is neat than 1, there are no requirements, but the sizing is determine by the windowpane sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "decamp 1c, a, onwards)\u00a0 (d, a, onwards)\u00a0 (b, a, onwards)\u00a0 (e, b, onwards)\u00a0 (g, e, onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onwards)\u00a0 \u00a0(f,c,onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, fall) c\u00a0is not located on the unicast track from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, fall)\u00a0c\u00a0is not located on the unicast track from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, fall)\u00a0c\u00a0is not located on the unicast track from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, fall)\u00a0d\u00a0is not located on the unicast track from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, fall)\u00a0f\u00a0is not located on the unicast track from g to a\ndecamp 2e, a, onwards)\u00a0(f, a, onwards)\ndecamp 3g, a, onwards)\u00a0 \u00a0 \u00a0\ndecamp 4h, a, onwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1c, a, onwards)\u00a0 (d, a, onwards)\u00a0 (b, a, onwards)\u00a0 (e, b, onwards)\u00a0 (g, e, onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onwards)\u00a0 \u00a0(f,c,onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, pearl) c\u00a0is not located on the unicast itinerary from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, pearl)\u00a0c\u00a0is not located on the unicast itinerary from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, pearl)\u00a0c\u00a0is not located on the unicast itinerary from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, pearl)\u00a0d\u00a0is not located on the unicast itinerary from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, pearl)\u00a0f\u00a0is not located on the unicast itinerary from g to a\nhop 2e, a, onwards)\u00a0(f, a, onwards)\nhop 3g, a, onwards)\u00a0 \u00a0 \u00a0\nhop 4h, a, onwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1c, a, onwards)\u00a0 (d, a, onwards)\u00a0 (b, a, onwards)\u00a0 (e, b, onwards)\u00a0 (g, e, onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onwards)\u00a0 \u00a0(f,c,onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, dip) c\u00a0is not located on the unicast path from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, dip)\u00a0c\u00a0is not located on the unicast path from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, dip)\u00a0c\u00a0is not located on the unicast path from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, dip)\u00a0d\u00a0is not located on the unicast path from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, dip)\u00a0f\u00a0is not located on the unicast path from g to a\nhop 2e, a, onwards)\u00a0(f, a, onwards)\nhop 3g, a, onwards)\u00a0 \u00a0 \u00a0\nhop 4h, a, onwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, onwards)\u00a0 (d, a, onwards)\u00a0 (b, a, onwards)\u00a0 (e, b, onwards)\u00a0 (g, e, onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onwards)\u00a0 \u00a0(f,c,onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, driblet) c\u00a0is not site on the unicast itinerary from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, driblet)\u00a0c\u00a0is not site on the unicast itinerary from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, driblet)\u00a0c\u00a0is not site on the unicast itinerary from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, driblet)\u00a0d\u00a0is not site on the unicast itinerary from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, driblet)\u00a0f\u00a0is not site on the unicast itinerary from g to a\nskip 2e, a, onwards)\u00a0(f, a, onwards)\nskip 3g, a, onwards)\u00a0 \u00a0 \u00a0\nskip 4h, a, onwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, a, onwards)\u00a0 (d, a, onwards)\u00a0 (b, a, onwards)\u00a0 (e, b, onwards)\u00a0 (g, e, onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onwards)\u00a0 \u00a0(f,c,onwards)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not site on the unicast course from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not site on the unicast course from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not site on the unicast course from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not site on the unicast course from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not site on the unicast course from g to a\njump 2e, a, onwards)\u00a0(f, a, onwards)\njump 3g, a, onwards)\u00a0 \u00a0 \u00a0\njump 4h, a, onwards)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the consultation added to the next frame has to refer to the experience frame so that it can be impute to the related data. otherwise you cannot name which frame is affirm by your consultation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the acknowledgment lend to the next frame has to refer to the received frame so that it can be delegate to the related data. otherwise you cannot name which frame is affirm by your acknowledgment.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the citation supply to the next frame has to refer to the incur frame so that it can be assigned to the related data. otherwise you cannot name which frame is affirm by your citation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the citation tot to the next frame has to refer to the meet frame so that it can be assigned to the related data. otherwise you cannot name which frame is affirm by your citation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the mention added to the next frame has to refer to the received frame so that it can be attribute to the related datum. otherwise you cannot name which frame is affirm by your mention.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane trash size of 1, the sequence should always be correct. if the windowpane trash size is majuscule than 1, there are no requirements, but the size is limited by the windowpane trash size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane crank size of 1, the sequence should always be correct. if the windowpane crank size is greater than 1, there are no requirements, but the size is limited by the windowpane crank size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass size of 1, the succession should always be correct. if the windowpane glass size is greater than 1, there are no requirements, but the size is limited by the windowpane glass size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass size of 1, the succession should always be correct. if the windowpane glass size is greater than 1, there are no requirements, but the size is limited by the windowpane glass size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass size of 1, the succession should always be correct. if the windowpane glass size is greater than 1, there are no requirements, but the size is limited by the windowpane glass size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own bilk tree, but it is not necessary to screw the bilk trees each router has entropy that the path it would practice for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own crossbreed tree, but it is not necessary to screw the crossbreed trees each router has entropy that the course it would use for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own sweep tree, but it is not necessary to screw the sweep tree each router has information that the route it would use for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own sweep tree, but it is not necessary to screw the sweep trees each router has entropy that the path it would expend for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own thwart tree, but it is not necessary to screw the thwart trees each router has entropy that the path it would utilise for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "A utile property for mark-tree multicasting/extend for a given node is that it not only specifies the optimal route from the other nodes to this node, but also the optimal route from this node to the other nodes.Link country routing can be used to build multicast mark-trees by first running the link country routing procedure to obtain the mark-tree for a given x node.This mark-tree could already be used as the multicast mark-tree for the x node, but it can be optimized by removing all edges that are not part of any route between two nodes of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "A utile property for hybrid-tree multicasting/widening for a given node is that it not only specifies the optimal route from the other nodes to this node, but also the optimal route from this node to the other nodes.Link country routing can be used to build multicast hybrid-trees by first running the link country routing subprogram to obtain the hybrid-tree for a given x node.This hybrid-tree could already be used as the multicast hybrid-tree for the x node, but it can be optimized by removing all edges that are not part of any route between two nodes of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "A utilitarian property for hybridizing-tree multicasting/broaden for a given node is that it not only specifies the optimal route from the other nodes to this node, but also the optimal route from this node to the other nodes.Link country routing can be used to build multicast hybridizing-trees by first running the link country routing procedure to obtain the hybridizing-tree for a given x node.This hybridizing-tree could already be used as the multicast hybridizing-tree for the x node, but it can be optimized by removing all edges that are not part of any route between two nodes of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is to know the multicast tree. to build a cross tree for multicasting, you also have to summate the entropy of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is to know the multicast tree. to build a cross tree for multicasting, you also have to add the randomness of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is to hump the multicast tree. to build a cross tree for multicasting, you also have to impart the entropy of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is to know the multicast tree. to build a cross tree for multicasting, you also have to add the randomness of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is to live the multicast tree. to build a cross tree for multicasting, you also have to add the information of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the act orientate protocol should be used, as the character orientate protocol requires additional time due to the insertion of dles into the frame and convert to the good encoding. in addition, the tally orientate protocol leads to desynchronisation in the upshot of a transmission error and is therefore not authentic enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the act point protocol should be used, as the character point protocol requires additional time due to the insertion of dles into the inning and convert to the good encoding. in addition, the tally point protocol leads to desynchronisation in the upshot of a transmission error and is therefore not reliable enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the act point protocol should be used, as the character point protocol requires additional time due to the insertion of dles into the frame and convert to the good encoding. in addition, the tally point protocol leads to desynchronisation in the issue of a transmission error and is therefore not honest enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the act orientate protocol should be used, as the character orientate protocol requires additional time due to the insertion of dles into the physique and convert to the good encoding. in addition, the tally orientate protocol leads to desynchronisation in the effect of a transmission error and is therefore not reliable enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the act tailor protocol should be used, as the character tailor protocol requires additional time due to the insertion of dles into the frame and convert to the good encoding. in addition, the tally tailor protocol leads to desynchronisation in the effect of a transmission error and is therefore not authentic enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data nexus level of one station must get a new packet from the upper level by the balance of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data nexus class of one station must get a new packet from the upper class by the balance of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data nexus class of one station must get a new mailboat from the upper class by the residual of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data nexus layer of one station must get a new packet from the upper layer by the residue of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data nexus stratum of one station must get a new mailboat from the upper stratum by the end of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connector bed of one place must get a new bundle from the upper bed by the end of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection bed of one place must get a new bundle from the upper bed by the end of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection bed of one post must get a raw packet from the upper bed by the end of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connective bed of one station must get a new package from the upper bed by the end of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum connection bed of one station must get a raw mailboat from the upper bed by the end of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The chassis can pack authentic cks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The chassis can run authentic cks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The physique can dribble veritable cks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The physique can extend authentic cks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "The chassis can post veritable cks.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0136q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester technique. this is because the clocks and data signals immix to form a single synchronize data stream of both 1 and 0 story.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0136q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because the clocks and data signals immix to form a exclusive synchronise data stream of both 1 and 0 storey.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0136q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because the clocks and datum signals immix to form a single synchronizing datum stream of both 1 and 0 storey.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0136q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester proficiency. this is because the clocks and datum signals immix to form a undivided synchronise datum stream of both 1 and 0 storey.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0136q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester technique. this is because the clocks and datum signals immix to form a exclusive synchronizing datum stream of both 1 and 0 level.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encryption (Me) would be applicable in this post. it has a good feature of ego-clocking that reserve a good way to identify bits. plus it has a low susceptibility to noise because dme only records the polarity of signals. this is cork when there is a lot of traffic in a link.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encoding (Me) would be applicable in this billet. it has a good feature of ego-clocking that leave a good way to identify bits. plus it has a low susceptibility to noise because dme only records the polarity of signals. this is cork when there is a lot of traffic in a nexus.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encryption (Me) would be applicable in this situation. it has a good feature of ego-clocking that admit a good way to identify bits. plus it has a low susceptibility to noise because dme only records the polarity of signals. this is cork when there is a flock of traffic in a link.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encryption (Me) would be applicable in this site. it has a good feature of ego-clocking that reserve a good way to identify bits. plus it has a low susceptibility to noise because dme only records the polarity of signals. this is cork when there is a lot of traffic in a link.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encryption (Me) would be applicable in this place. it has a good feature of ego-clocking that allows a good way to identify bits. plus it has a low susceptibility to noise because dme only records the polarity of signals. this is cork when there is a lot of traffic in a linkup.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, onwards) skip 2: (g,f, onwards), (g,e, onwards) skip 3: (e,b, onwards), (e,c, onwards), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, ahead) skip 2: (g,f, ahead), (g,e, ahead) skip 3: (e,b, ahead), (e,c, ahead), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, onwards) skip 2: (g,f, onwards), (g,e, onwards) skip 3: (e,b, onwards), (e,c, onwards), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, fore) skip 2: (g,f, fore), (g,e, fore) skip 3: (e,b, fore), (e,c, fore), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, ahead) skip 2: (g,f, ahead), (g,e, ahead) skip 3: (e,b, ahead), (e,c, ahead), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference in form a. except 0 and 127 are leger for network and programme",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all destination in form a. except 0 and 127 are book for net and broadcast",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all addresses in mannikin a. except 0 and 127 are script for web and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all speech in form a. except 0 and 127 are record for network and plan",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference in form a. except 0 and 127 are bible for net and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this network I suggest using differential manchester encryption: this coding technique is robust in clock recovery and therefore offers ease of synchronization in the recipient because a transition is guaranteed at least once every scrap. In addition, it is less prone to fault in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this network I suggest using differential manchester encoding: this coding technique is robust in clock recovery and therefore propose ease of synchronization in the liquidator because a transition is guaranteed at least once every scrap. In addition, it is less prone to errors in noisy environs.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this network I suggest using differential manchester encryption: this coding technique is robust in clock recovery and therefore offers ease of synchronization in the receiver because a transition is guaranteed at least once every scrap. In addition, it is less prone to error in noisy surround.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need an estimated performance and usage of the desired channel. and they also have perfect watches for fender.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither window, because they need an gauge performance and employment of the desired channel. and they also have perfect watches for fender.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need an gauge performance and utilization of the desired channel. and they also have perfect watches for buff.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Slither windowpane, because they need an estimate performance and utilization of the desired channel. and they also have perfect watches for pilot.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encoding (Me) would be applicable in this berth. it has a good feature of self-clocking that allows a good way to identify bits. it also has a low susceptibility to noise because dme only records the polarity of signals. this is majuscule when there is a mint of traffic in a link.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the use of differential manchester encoding (Me) would be applicable in this berth. it has a good feature of self-clocking that allows a good way to identify bits. it also has a low susceptibility to noise because dme only records the polarity of signals. this is majuscule when there is a circle of traffic in a link.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the extension of the piggy includes the acknowledgement \"ack\". - contains the successiveness-number ack(seq.no) and confirms the frame(seq.no). - here, the ack acknowledgement can be implicitly given by the subframe.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the extension of the piggy includes the identification \"ack\". - contains the episode-number ack(seq.no) and confirms the frame(seq.no). - here, the ack identification can be implicitly given by the subframe.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the extension of the piggy includes the acknowledgment \"ack\". - contains the episode-number ack(seq.no) and confirms the frame(seq.no). - here, the ack acknowledgment can be implicitly given by the subframe.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the extension of the piggy includes the acknowledgement \"ack\". - contains the succession-number ack(seq.no) and confirms the frame(seq.no). - here, the ack acknowledgement can be implicitly given by the subframe.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the requirement for the extension of the piggy includes the acknowledgement \"ack\". - contains the sequence-number ack(seq.no) and affirm the frame(seq.no). - here, the ack acknowledgement can be implicitly given by the subframe.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, off)\u00a0 (d, a, off)\u00a0 (b, a, off)\u00a0 (e, b, off)\u00a0 (g, e, off)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,off)\u00a0 \u00a0(f,c,off)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not site on the unicast route from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not site on the unicast route from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not site on the unicast route from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not site on the unicast route from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not site on the unicast route from g to a\nskip 2e, a, off)\u00a0(f, a, off)\nskip 3g, a, off)\u00a0 \u00a0 \u00a0\nskip 4h, a, off)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, forward)\u00a0 (d, a, forward)\u00a0 (b, a, forward)\u00a0 (e, b, forward)\u00a0 (g, e, forward)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,forward)\u00a0 \u00a0(f,c,forward)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not site on the unicast track from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not site on the unicast track from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not site on the unicast track from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not site on the unicast track from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not site on the unicast track from g to a\nskip 2e, a, forward)\u00a0(f, a, forward)\nskip 3g, a, forward)\u00a0 \u00a0 \u00a0\nskip 4h, a, forward)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, off)\u00a0 (d, a, off)\u00a0 (b, a, off)\u00a0 (e, b, off)\u00a0 (g, e, off)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,off)\u00a0 \u00a0(f,c,off)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not settle on the unicast track from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not settle on the unicast track from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not settle on the unicast track from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not settle on the unicast track from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not settle on the unicast track from g to a\nskip 2e, a, off)\u00a0(f, a, off)\nskip 3g, a, off)\u00a0 \u00a0 \u00a0\nskip 4h, a, off)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, onward)\u00a0 (d, a, onward)\u00a0 (b, a, onward)\u00a0 (e, b, onward)\u00a0 (g, e, onward)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onward)\u00a0 \u00a0(f,c,onward)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not settle on the unicast itinerary from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not settle on the unicast itinerary from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not settle on the unicast itinerary from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not settle on the unicast itinerary from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not settle on the unicast itinerary from g to a\nskip 2e, a, onward)\u00a0(f, a, onward)\nskip 3g, a, onward)\u00a0 \u00a0 \u00a0\nskip 4h, a, onward)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, onward)\u00a0 (d, a, onward)\u00a0 (b, a, onward)\u00a0 (e, b, onward)\u00a0 (g, e, onward)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,onward)\u00a0 \u00a0(f,c,onward)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not locate on the unicast route from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not locate on the unicast route from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not locate on the unicast route from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not locate on the unicast route from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not locate on the unicast route from g to a\nskip 2e, a, onward)\u00a0(f, a, onward)\nskip 3g, a, onward)\u00a0 \u00a0 \u00a0\nskip 4h, a, onward)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one focusing, to be able to send some datum back with the ack. it is basically using the default operation of commit the ack to also send some extra datum back to the transmitter, instead of commit a new skeleton.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, fore) skip 2: (g,f, fore), (g,e, fore) skip 3: (e,b, fore), (e,c, fore), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, forth) skip 2: (g,f, forth), (g,e, forth) skip 3: (e,b, forth), (e,c, forth), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, forrader) skip 2: (g,f, forrader), (g,e, forrader) skip 3: (e,b, forrader), (e,c, forrader), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, frontward) skip 2: (g,f, frontward), (g,e, frontward) skip 3: (e,b, frontward), (e,c, frontward), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1: (h,g, fore) skip 2: (g,f, fore), (g,e, fore) skip 3: (e,b, fore), (e,c, fore), (e,f, fall)= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the mention added to the next frame has to relate to the received frame so that it can be assigned to the related datum. otherwise you cannot discover which frame is reassert by your mention.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the cite added to the next frame has to mention to the received frame so that it can be assigned to the related datum. otherwise you cannot discover which frame is reassert by your cite.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the credit added to the next frame has to relate to the received frame so that it can be assigned to the related data. otherwise you cannot attain which frame is reassert by your credit.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference added to the next frame has to touch to the received frame so that it can be assigned to the related datum. otherwise you cannot discover which frame is reassert by your reference.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the quotation added to the next inning has to refer to the received inning so that it can be assigned to the related datum. otherwise you cannot learn which inning is reassert by your quotation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes earths when it is in equilibrium. however, the steady-earth probability pk to find the process in earth k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability menstruum, also called flux, into earth k equalise the probability menstruum out of earth k. this render the global balance par:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes states when it is in equilibrium. however, the steady-state probability pk to find the process in state k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability catamenia, also called flux, into state k equalise the probability catamenia out of state k. this picture the global balance equations:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes states when it is in equilibrium. however, the steady-state probability pk to find the process in state k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability menstruum, also called flux, into state k equalise the probability menstruum out of state k. this render the global balance par:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes demesnes when it is in equilibrium. however, the steady-demesne probability pk to find the process in demesne k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability flowing, also called flux, into demesne k equalise the probability flowing out of demesne k. this translate the global balance equations:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes farmings when it is in equilibrium. however, the steady-farming probability pk to find the process in farming k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability menstruum, also called flux, into farming k equalise the probability menstruum out of farming k. this render the global balance equivalence:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no form to direct, the directer will never get an ack for his directed forms\n- so when a form is received, the receiver have no form to direct and the count is finish, the receiver direct a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counterpunch \n- because if recipient have no build to direct, the directer will never get an ack for his directed builds\n- so when a build is received, the recipient have no build to direct and the count is end, the recipient direct a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a retort \n- because if recipient have no soma to direct, the directer will never get an ack for his lead somas\n- so when a soma is received, the recipient have no soma to direct and the count is ended, the recipient direct a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a comeback \n- because if recipient have no anatomy to direct, the directer will never get an ack for his manoeuvre anatomys\n- so when a anatomy is received, the recipient have no anatomy to direct and the count is ended, the recipient direct a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if recipient have no chassis to direct, the directer will never get an ack for his manoeuver chassiss\n- so when a chassis is received, the recipient have no chassis to direct and the count is stop, the recipient direct a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frame can ascertain veritable acks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frame can contain veritable acks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frame can manipulate veritable acks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frame can ascertain authentic acks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frame can master veritable acks",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1:(h,g,forrard) skip 2: (g,e,forrard) (g,f,drop)$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial bout of the sequence is 0 and the next bout of the sequence and the next bout of ack-sequence to be looked at is given",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial turn of the successiveness is 0 and the next turn of the successiveness and the next turn of ack-successiveness to be see at is have",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial turn of the successiveness is 0 and the next turn of the successiveness and the next turn of ack-successiveness to be depend at is given",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial tour of the successiveness is 0 and the next tour of the successiveness and the next tour of ack-successiveness to be looked at is throw",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial act of the sequence is 0 and the next act of the sequence and the next act of ack-sequence to be attend at is given",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "gyrate with high ability in order to work very performant with a muckle of data. work is that it is not so skillful, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "spin with high power in order to go very performant with a stack of datum. go is that it is not so skillful, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "spin with high superpower in order to make very performant with a stack of data. make is that it is not so skillful, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "gyrate with high ability in order to work very performant with a wad of data. work is that it is not so skillful, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "spin with high index in order to exploit very performant with a pile of data. exploit is that it is not so skillful, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 software\nanswer: 10 software\n\n2. step:\nqueue: 9 software\nanswer: 10 software\n\n3.step:\nqueue: 9 software\nanswer: 9 software\n\n4. step:\nqueue: 9 software\nanswer: 9 software\n\nand so on. if there will always arrive 9 software per second and the host can serve maximum 10 software per second, there will never be 10 software in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. gradation:\nqueue: 10 packet\ndish: 10 packet\n\n2. gradation:\nqueue: 9 packet\ndish: 10 packet\n\n3.gradation:\nqueue: 9 packet\ndish: 9 packet\n\n4. gradation:\nqueue: 9 packet\ndish: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the host can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first gradation.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footmark:\nqueue: 10 parcel\ndo: 10 parcel\n\n2. footmark:\nqueue: 9 parcel\ndo: 10 parcel\n\n3.footmark:\nqueue: 9 parcel\ndo: 9 parcel\n\n4. footmark:\nqueue: 9 parcel\ndo: 9 parcel\n\nand so on. if there will always arrive 9 parcel per second and the host can serve maximum 10 parcel per second, there will never be 10 parcel in the queue except in the first footmark.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. measure:\nqueue: 10 packet\nserving: 10 packet\n\n2. measure:\nqueue: 9 packet\nserving: 10 packet\n\n3.measure:\nqueue: 9 packet\nserving: 9 packet\n\n4. measure:\nqueue: 9 packet\nserving: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the host can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first measure.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. pace:\nqueue: 10 bundle\nserving: 10 bundle\n\n2. pace:\nqueue: 9 bundle\nserving: 10 bundle\n\n3.pace:\nqueue: 9 bundle\nserving: 9 bundle\n\n4. pace:\nqueue: 9 bundle\nserving: 9 bundle\n\nand so on. if there will always get 9 bundle per second and the host can serve maximum 10 bundle per second, there will never be 10 bundle in the queue except in the first pace.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is to bonk the multicast tree. to progress a scanning tree for multicast, you also have to add the information of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "If pickingbacking is used in the slew window protocol, the receiver expects a specified condemnation period to attach the sequence number and the next ack sequence number to the next table.For this, the additional condemnation delay must be taken into account and the sender must be informed of the fact, which there are probably no separate ack frames transport. Also, the sender must attach the ack to the data itself.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "If pickingbacking is used in the slide window protocol, the liquidator expects a specified conviction period to attach the sequence number and the next ack sequence number to the next table.For this, the additional conviction delay must be taken into account and the sender must be informed of the fact, which there are probably no separate ack frames transmitted. Also, the sender must attach the ack to the data itself.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "If pickingbacking is used in the sliding window protocol, the liquidator expects a specified conviction period to attach the sequence bit and the next ack sequence bit to the next table.For this, the additional conviction delay must be taken into account and the sender must be informed of the fact, which there are probably no separate ack frames transmitted. Also, the sender must attach the ack to the data itself.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "If pickingbacking is used in the slither window protocol, the liquidator expects a specified sentence period to attach the sequence turn and the next ack sequence turn to the next table.For this, the additional sentence delay must be taken into account and the sender must be informed of the fact, which there are probably no separate ack frames transmitted. Also, the sender must attach the ack to the data itself.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "If pickingbacking is used in the slue window protocol, the receiver expects a specified condemnation period to attach the sequence number and the next ack sequence number to the next table.For this, the additional condemnation delay must be taken into account and the sender must be informed of the fact, which there are probably no separate ack frames transport. Also, the sender must attach the ack to the data itself.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one direction, to be able to send some datum back with the ack. it is basically using the default operation of send the ack to also send some additional datum back to the sender, instead of send a new physique.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one direction, to be able to send some datum back with the ack. it is basically using the default operation of place the ack to also send some additional datum back to the vector, instead of place a raw frame.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one direction, to be able to send some datum back with the ack. it is basically using the default operation of place the ack to also send some additional datum back to the vector, instead of place a raw frame.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one direction, to be able to send some datum back with the ack. it is basically using the default operation of place the ack to also send some additional datum back to the sender, instead of place a young frame.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1513q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one direction, to be able to send some datum back with the ack. it is basically using the default operation of place the ack to also send some additional datum back to the sender, instead of place a young frame.",
        "answer_feedback": "the response is incorrect because it implies that the presence of data on both sides is necessary for acknowledgments to be sendable. however, one can also send pure acknowledgments when no data is available for a specific time.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane meth sizing of 1, the sequence should always be correct. if the windowpane meth sizing is greater than 1, there are no requirements, but the sizing is limited by the windowpane meth sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane spyglass sizing of 1, the sequence should always be correct. if the windowpane spyglass sizing is greater than 1, there are no requirements, but the sizing is limited by the windowpane spyglass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window glass sizing of 1, the sequence should always be right. if the window glass sizing is greater than 1, there are no necessity, but the sizing is limited by the window glass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane chalk sizing of 1, the sequence should always be correct. if the windowpane chalk sizing is greater than 1, there are no requirements, but the sizing is limited by the windowpane chalk sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass sizing of 1, the sequence should always be right. if the windowpane glass sizing is greater than 1, there are no requirements, but the sizing is limited by the windowpane glass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest packet is at least 64 bytes, the maximum hit orbit diameter is calculated by the metre it takes for the smallest packet to locomote at a certain speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit orbit diameter is increase 100 metres.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest packet is at least 64 bytes, the maximum hit domain diameter is calculated by the sentence it takes for the smallest packet to locomote at a certain speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit domain diameter is increased 100 sentences.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest parcel is at least 64 bytes, the maximum hit area diameter is calculated by the time it takes for the smallest parcel to locomote at a certain speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit area diameter is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest bundle is at least 64 bytes, the maximum hit compass diameter is calculated by the time it takes for the smallest bundle to locomote at a certain speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit compass diameter is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest packet is at least 64 bytes, the maximum hit orbit diameter is calculated by the metre it takes for the smallest packet to locomote at a certain speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit orbit diameter is increase 100 metres.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent duet receives every frame of each connected side. the duet table holds the information about which components are attached to the network. that intend the transparent duet receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the transparent duet inundate the network with this information, so that other duets also have the information about component a. a welfare of flooding is that it uses the shortest way in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent duad receives every frame of each connected side. the duad table holds the information about which factor are attached to the network. that intend the transparent duad receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the transparent duad glut the network with this information, so that other duads also have the information about component a. a welfare of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent duet receives every frame of each connected side. the duet table holds the information about which components are attached to the network. that intend the transparent duet receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the transparent duet inundate the network with this information, so that other duets also have the information about component a. a welfare of flooding is that it uses the shortest route in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent duo receives every frame of each connected side. the duo table holds the information about which components are attached to the network. that intend the transparent duo receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the transparent duo deluge the network with this information, so that other duos also have the information about component a. a welfare of flooding is that it uses the shortest route in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent duad receives every frame of each connected side. the duad table holds the information about which components are attached to the network. that intend the transparent duad receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the transparent duad inundate the network with this information, so that other duads also have the information about component a. a welfare of flooding is that it uses the shortest way in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0342q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(h,g,ahead)\nhop 2:\n(g,e,ahead)\n(g,f,drop)<=not the shortest class\nhop 3:\n(e,c,ahead)\n(e,b,drop)<=it is not subside on the unicast class from e to a\n(e,f,drop)<=it is not subside on the unicast class from e to a\nhop 4:\n(c,a,ahead)\n(c,b,drop)<=it is not subside on the unicast class from c to a\n(c,d,drop)<=it is not subside on the unicast class from c to a",
        "answer_feedback": "the routing starts from the a\u00a0 as sender and this will result in change in the packets forwarded or dropped.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0342q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(h,g,ahead)\nhop 2:\n(g,e,ahead)\n(g,f,drop)<=not the shortest line\nhop 3:\n(e,c,ahead)\n(e,b,drop)<=it is not resolve on the unicast line from e to a\n(e,f,drop)<=it is not resolve on the unicast line from e to a\nhop 4:\n(c,a,ahead)\n(c,b,drop)<=it is not resolve on the unicast line from c to a\n(c,d,drop)<=it is not resolve on the unicast line from c to a",
        "answer_feedback": "the routing starts from the a\u00a0 as sender and this will result in change in the packets forwarded or dropped.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0342q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(h,g,ahead)\nhop 2:\n(g,e,ahead)\n(g,f,drop)<=not the shortest line\nhop 3:\n(e,c,ahead)\n(e,b,drop)<=it is not conciliate on the unicast line from e to a\n(e,f,drop)<=it is not conciliate on the unicast line from e to a\nhop 4:\n(c,a,ahead)\n(c,b,drop)<=it is not conciliate on the unicast line from c to a\n(c,d,drop)<=it is not conciliate on the unicast line from c to a",
        "answer_feedback": "the routing starts from the a\u00a0 as sender and this will result in change in the packets forwarded or dropped.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0342q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(h,g,ahead)\nhop 2:\n(g,e,ahead)\n(g,f,drop)<=not the shortest track\nhop 3:\n(e,c,ahead)\n(e,b,drop)<=it is not descend on the unicast track from e to a\n(e,f,drop)<=it is not descend on the unicast track from e to a\nhop 4:\n(c,a,ahead)\n(c,b,drop)<=it is not descend on the unicast track from c to a\n(c,d,drop)<=it is not descend on the unicast track from c to a",
        "answer_feedback": "the routing starts from the a\u00a0 as sender and this will result in change in the packets forwarded or dropped.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0342q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(h,g,forward)\nhop 2:\n(g,e,forward)\n(g,f,drop)<=not the shortest grade\nhop 3:\n(e,c,forward)\n(e,b,drop)<=it is not finalise on the unicast grade from e to a\n(e,f,drop)<=it is not finalise on the unicast grade from e to a\nhop 4:\n(c,a,forward)\n(c,b,drop)<=it is not finalise on the unicast grade from c to a\n(c,d,drop)<=it is not finalise on the unicast grade from c to a",
        "answer_feedback": "the routing starts from the a\u00a0 as sender and this will result in change in the packets forwarded or dropped.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the turnout of poisson is ground on odds ground on random arrival packages, ground on t independent. each interval is independent of the previous intervals, so arrivals are without memory. the same situation is for cyberspace. here we have server/client application, www server, streaming clients that have different and random arrivals of packages that can be modeled as poisson turnout.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the outturn of poisson is based on odds based on random arrival packet, based on t independent. each interval is independent of the previous intervals, so arrivals are without memory. the same situation is for cyberspace. here we have server/client application, vane server, streaming clients that have different and random arrivals of packet that can be modeled as poisson outturn.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the turnout of poisson is base on odds base on random comer packages, base on t independent. each interval is independent of the previous intervals, so comers are without memory. the same situation is for cyberspace. here we have server/client application, web server, streaming clients that have different and random comers of packages that can be modeled as poisson turnout.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, as the rate of eating (9) is crushed than the rate of service (10). So in the median the fender is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, as the rate of eating (9) is abject than the rate of service (10). So in the median the polisher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, as the rate of eating (9) is low than the rate of service (10). So in the median the pilot is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, as the rate of rust (9) is depressed than the rate of service (10). So in the median the buffer is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the suit, as the rate of eating (9) is lower than the rate of service (10). So in the median the buff is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own crossed tree, but it is not necessary to boncar the crossed trees each router has entropy that the itinerary it would use for (unicast)-packages due to unique routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own crossed tree, but it is not necessary to boncar the crossed trees each router has entropy that the itinerary it would use for (unicast)-packages due to unique routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own crossed tree, but it is not necessary to boncar the crossed trees each router has entropy that the path it would use for (unicast)-packages due to alone routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own crossed tree, but it is not necessary to boncar the crossed trees each router has information that the way it would use for (unicast)-packages due to singular routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own crossed tree, but it is not necessary to boncar the crossed trees each router has entropy that the route it would use for (unicast)-packages due to unique routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 bundle, since more bundle are dish than the bundle get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 software, since more software are dish than the software fall in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 bundle, since more bundle are dish than the bundle come in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 software, since more software are dish than the software total in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 packet, since more packet are dish than the packet arrive in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 tract because we receive only 9 tract and serve 10 tract. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 share because we obtain only 9 share and dish 10 share. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 packet because we receive only 9 packet and serve 10 packet. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the sentence less than 10 tract because we get only 9 tract and dish 10 tract. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the meter less than 10 portion because we find only 9 portion and dish 10 portion. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of autonomous poisson arrivals has been justified by claiming that the aggregation of many autonomous and identically allot renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in traffic application scenarios that include a large number of autonomous traffic flow. the theoretical scope behind the usage comes from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the individual paces decrease to keep the aggregate pace constant. but, traffic aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of autonomous poisson arrivals has been justified by claiming that the aggregation of many autonomous and identically stagger renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in dealings application scenarios that include a large number of autonomous dealings flow. the theoretical scope behind the usage comes from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the individual rates decrease to keep the aggregate rate constant. but, dealings aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme poisson arrivals has been justified by claiming that the aggregation of many supreme and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in dealings application scenarios that include a large number of supreme dealings flow. the theoretical scope behind the usage comes from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the individual paces decrease to keep the aggregate pace constant. but, dealings aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme poisson arrivals has been justified by claiming that the aggregation of many supreme and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in dealings application scenarios that include a large number of supreme dealings flow. the theoretical scope behind the usage comes from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the individual paces decrease to keep the aggregate pace constant. but, dealings aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of independent poisson arrivals has been justified by claiming that the aggregation of many independent and identically distributed refilling processes tend to poisson process when the number increases.\n\npoisson processes are conventional in dealings application scenarios that include a large number of independent dealings flow. the theoretical scope behind the usage comes from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the individual rates decrease to keep the aggregate rate constant. but, dealings aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, understood datum does not depend on position, some have more soma than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, silent datum does not calculate on emplacement, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the job, silent datum does not depend on positioning, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, understood datum does not look on location, some have more underframe than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the job, silent datum does not depend on locating, some have more frames than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes lands when it is in equipoise. however, the steady-land probability pk to find the process in land k does not change anymore, thus dpk (t )/dt = 0. \n\nin equipoise, it follows from dpk (t )/dt = 0 that the probability flow, also holler flux, into land k rival the probability flow out of land k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes countrys when it is in counterbalance. however, the steady-country chance pk to find the process in country k does not change anymore, thus dpk (t )/dt = 0. \n\nin counterbalance, it follows from dpk (t )/dt = 0 that the chance flow, also phone flux, into country k rival the chance flow out of country k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes areas when it is in equilibrium. however, the steady-area chance pk to find the process in area k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the chance flow, also call flux, into area k rival the chance flow out of area k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes areas when it is in equipoise. however, the steady-area chance pk to find the process in area k does not change anymore, thus dpk (t )/dt = 0. \n\nin equipoise, it follows from dpk (t )/dt = 0 that the chance flow, also called flux, into area k rival the chance flow out of area k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes areas when it is in equipoise. however, the steady-area chance pk to find the process in area k does not change anymore, thus dpk (t )/dt = 0. \n\nin equipoise, it follows from dpk (t )/dt = 0 that the chance flow, also called flux, into area k rival the chance flow out of area k. this yields the global balance equations:\n(sum starting from k=0 until eternity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window crank sizing of 1, the sequence should always be correct. if the window crank sizing is sharp that 1, there are no requirements, but the sizing is circumscribe by the window crank sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glassful sizing of 1, the sequence should always be correct. if the windowpane glassful sizing is sharp that 1, there are no requirements, but the sizing is limited by the windowpane glassful sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane spyglass sizing of 1, the sequence should always be correct. if the windowpane spyglass sizing is sharp that 1, there are no requirements, but the sizing is limited by the windowpane spyglass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane ice size of 1, the sequence should always be correct. if the windowpane ice size is sharp that 1, there are no requirements, but the size is limited by the windowpane ice size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass sizing of 1, the sequence should always be correct. if the windowpane glass sizing is sharp that 1, there are no requirements, but the sizing is limited by the windowpane glass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i suggest to expend the differential manchester encryption: this encryption technique is robust in clock recovery and hence offers synchronization facility at receiver becaexpend a transition is guaranteed at least once every scrap. in addition, it is less error-prone in noisy surroundings.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i suggest to use the differential manchester encryption: this encryption technique is robust in clock recovery and hence offers synchroneity facility at receiver because a transition is guaranteed at least once every scrap. in addition, it is less error-prone in noisy surroundings.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i suggest to employ the differential manchester encryption: this encryption technique is robust in clock retrieval and hence offers synchronism facility at receiver becaemploy a transition is guaranteed at least once every scrap. in addition, it is less error-prone in noisy surroundings.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i suggest to expend the differential manchester encryption: this encryption technique is rich in clock retrieval and hence offers synchronization facility at receiver becaexpend a transition is guaranteed at least once every scrap. in addition, it is less error-prone in noisy surroundings.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i suggest to use the differential manchester encryption: this encryption technique is rich in clock retrieval and hence offers synchroneity facility at receiver because a transition is guaranteed at least once every scrap. in addition, it is less error-prone in noisy surroundings.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 sheaf arrive in 1 minute 10 * 60 = 600 sheaf can be operated in 1 minute on the basis of the assumption that the sheaf arrive equally distributed in the minute (i.e. 9 sheaf per second) and we can act 10 sheaf per second, this means that the organization is occupied in 90% of the metre with the action of the sheaf. in 10% of the metre the organization has no sheaf to act. since the organization can act more multiple in a second than we hope to arrive in a second, the organization will be in a state with less than 10 sheaf waiting in line all the metre.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 sheaf arrive in 1 minute 10 * 60 = 600 sheaf can be operated in 1 minute on the basis of the assumption that the sheaf arrive evenly distributed in the minute (i.e. 9 sheaf per second) and we can act 10 sheaf per second, this means that the organization is occupied in 90% of the sentence with the action of the sheaf. in 10% of the sentence the organization has no sheaf to act. since the organization can act more multiple in a second than we hope to arrive in a second, the organization will be in a state with less than 10 sheaf look in line all the sentence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 parcel arrive in 1 minute 10 * 60 = 600 parcel can be operated in 1 minute on the basis of the assumption that the parcel arrive equally distributed in the minute (i.e. 9 parcel per second) and we can act 10 parcel per second, this means that the organization is occupied in 90% of the time with the action of the parcel. in 10% of the time the organization has no parcel to act. since the organization can act more multiple in a second than we hope to arrive in a second, the organization will be in a state with less than 10 parcel wait in line all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 megabucks arrive in 1 minute 10 * 60 = 600 megabucks can be operated in 1 minute on the basis of the assumption that the megabucks arrive equally distributed in the minute (i.e. 9 megabucks per second) and we can act 10 megabucks per second, this means that the organization is occupied in 90% of the metre with the action of the megabucks. in 10% of the metre the organization has no megabucks to act. since the organization can act more multiple in a second than we hope to arrive in a second, the organization will be in a state with less than 10 megabucks waiting in line all the metre.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 package arrive in 1 minute 10 * 60 = 600 package can be operated in 1 minute on the basis of the assumption that the package arrive equally distributed in the minute (i.e. 9 package per second) and we can act 10 package per second, this means that the organization is occupied in 90% of the time with the action of the package. in 10% of the time the organization has no package to act. since the organization can act more multiple in a second than we hope to arrive in a second, the organization will be in a state with less than 10 package expect in line all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific flexure to transmit the sync signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently commodious for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific folds to channelize the sync signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently commodious for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific crease to transmit the sync signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently commodious for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific fold to transmit the sync signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific folds to transmit the sync signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently commodious for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole time in a state, in which there are less than 10 pile waiting in the queue, due to the fact that there are always more pile processed pro second than arriving.\nexercise = arrival rate / serve rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of pile in the organisation\nn =  exercise / 1 - exercise which gives = 9 pile\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the exercise ist the same at every time, the probability that the organisation is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the establishment will be for the whole time in a nation, in which there are less than 10 bundle waiting in the queue, due to the fact that there are always more bundle processed pro second than arriving.\nemployment = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of bundle in the establishment\nn =  employment / 1 - employment which gives = 9 bundle\nwe can also calculate the probability, that the establishment is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the employment ist the same at every time, the probability that the establishment is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole time in a country, in which there are less than 10 pile waiting in the queue, due to the fact that there are always more pile processed pro second than arriving.\nexercise = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of pile in the organisation\nn =  exercise / 1 - exercise which gives = 9 pile\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the exercise ist the same at every time, the probability that the organisation is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the formation will be for the whole time in a state, in which there are less than 10 pile waiting in the queue, due to the fact that there are always more pile processed pro second than arriving.\nutilisation = arrival rate / overhaul rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of pile in the formation\nn =  utilisation / 1 - utilisation which gives = 9 pile\nwe can also calculate the probability, that the formation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every time, the probability that the formation is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole time in a state, in which there are less than 10 pile waiting in the queue, due to the fact that there are always more pile processed pro second than arriving.\nexercise = arrival rate / servicing rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of pile in the organisation\nn =  exercise / 1 - exercise which gives = 9 pile\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the exercise ist the same at every time, the probability that the organisation is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0342q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(h,g,frontward)\nhop 2:\n(g,e,frontward)\n(g,f,drop)<=not the brusk route\nhop 3:\n(e,c,frontward)\n(e,b,drop)<=it is not site on the unicast route from e to a\n(e,f,drop)<=it is not site on the unicast route from e to a\nhop 4:\n(c,a,frontward)\n(c,b,drop)<=it is not site on the unicast route from c to a\n(c,d,drop)<=it is not site on the unicast route from c to a",
        "answer_feedback": "the routing starts from the a\u00a0 as sender and this will result in change in the packets forwarded or dropped.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to ego-chronization there is no indigence to have a specific line to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 user.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to self-chronization there is no indigence to have a specific line to transmit the synchronisation signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to ego-chronization there is no indigence to have a specific line to send the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to self-chronization there is no indigence to have a specific line to transmit the synchroneity signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to ego-chronization there is no indigence to have a specific line to transmit the synchronizing signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester encryption is the sound alternative because of its good ego-clocking function which is important in a congested meshing. it also render error detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester encryption is the estimable option because of its good ego-clocking function which is important in a engorged network. it also provides error detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester encryption is the secure alternative because of its good ego-clocking function which is important in a engorged web. it also provides error detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest package is at least 64 byte, the maximum strike arena diam is calculated by the time it takes for the smallest package to travel at a certain speed. thus, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the strike arena diam is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the modest package is at least 64 byte, the maximum hit arena diam is calculated by the time it takes for the modest package to travel at a certain speed. thus, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit arena diam is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the smallest package is at least 64 byte, the maximum make arena diam is calculated by the time it takes for the smallest package to travel at a certain speed. thus, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the make arena diam is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the humble package is at least 64 byte, the maximum strike arena diameter is calculated by the time it takes for the humble package to travel at a certain speed. thus, at 10 mb/s = 1x10^7 byte/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the strike arena diameter is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1240q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "since the humble package is at least 64 bytes, the maximum hit arena diam is calculated by the time it takes for the humble package to travel at a sure speed. thus, at 10 mb/s = 1x10^7 bytes/s, 64/1x10^7 = 6.4x10^-6 s while on 100mb/s, 64/100x10^7 = 6.4 x 10^-8 s. thus the hit arena diam is increase 100 times.",
        "answer_feedback": "the answer is incorrect as it states that the collision domain diameter increases 100 times, but for collisions to be detected, the diameter decreases by a factor of 10. for example, from 1000m to 100m.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data link stratum of a station must obtain a young package from the top stratum for the rest of the wait time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data link layer of a station must obtain a novel package from the top layer for the rest of the wait time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data liaison level of a station must obtain a new package from the top level for the rest of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data connection bed of a station must obtain a new package from the top bed for the rest of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data link stratum of a station must obtain a young package from the top stratum for the rest of the wait time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the solvent frames have to be capable to hold datum + ack and not only ack or only datum. this way the ack can be detain and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the solvent build have to be capable to hold datum + ack and not only ack or only datum. this way the ack can be delay and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the solvent skeleton have to be capable to hold datum + ack and not only ack or only datum. this way the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the solvent frames have to be capable to hold datum + ack and not only ack or only datum. this agency the ack can be retard and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the solvent frames have to be capable to hold datum + ack and not only ack or only datum. this means the ack can be stay and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "paleness is the problem\uff0cthe datum reticence is not bet on the localisation, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "beauteousness is the problem\uff0cthe datum reticence is not calculate on the localisation, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "candour is the problem\uff0cthe datum reticence is not depending on the localization, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "candor is the problem\uff0cthe datum reticence is not calculate on the localisation, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum reticence is not depending on the locating, some have more bod than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific line to transmit the synchronisation sign.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local net with 3 user.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific line to transmit the synchronisation sign.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific line to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local net with 3 user.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific line to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local lucre with 3 exploiter.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no requirement to have specific line to transmit the synchronisation signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is know the multicast tree. to construct a spanning tree for multicasting, you also have to transmit the information of the other is of the multicast radical.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is know the multicast tree. to construct a cross tree for multicasting, you also have to bring the s of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is jazz the multicast tree. to construct a traverse tree for multicasting, you also have to contribute the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is fuck the multicast tree. to construct a traverse tree for multicasting, you also have to impart the entropy of the other is of the multicast radical.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is know the multicast tree. to construct a traverse tree for multicasting, you also have to carry the entropy of the other is of the multicast radical.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamey-power in decree to work very performant with a gamey amount of datum.\ndifficulty is that it is not that proficient, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it form with gamy-power in order to work very performant with a gamy amount of datum.\ntrouble is that it is not that serious, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with gamy-power in rescript to work very performant with a gamy amount of datum.\nbother is that it is not that good, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it works with blue-power in edict to work very performant with a blue amount of datum.\ntrouble is that it is not that skilful, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it shape with gamey-power in order to work very performant with a gamey amount of datum.\nhassle is that it is not that upright, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the output of poisson is based on odds based on random arrival software, based on t independent. each interval is independent of the old intervals, so arrivals are without retentivity. the same situation is for the Internet. here we have server/client application, web server, streaming clients that have different and random arrivals of software that can be molded as poisson output.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the output of poisson is based on odds based on random arrival packages, based on t independent. each interval is independent of the previous intervals, so arrivals are without storage. the same situation is for the Internet. here we have waiter/client application, web waiter, streaming customer that have different and random arrivals of packages that can be molded as poisson output.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the output of poisson is based on odds based on random arrival packet, based on t independent. each interval is independent of the previous intervals, so arrivals are without retentivity. the same situation is for the Internet. here we have host/client application, web host, streaming clients that have different and random arrivals of packet that can be molded as poisson output.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the output of poisson is based on odds based on random arrival packages, based on t independent. each interval is independent of the former intervals, so arrivals are without retentivity. the same situation is for the Internet. here we have server/client application, web server, streaming guest that have different and random arrivals of packages that can be molded as poisson output.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they postulate a good throughput and good groove employment. and also they have perfect alfilaria for polisher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they ask a good throughput and good channel employment. and also they have sodding alfilaria for polisher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue windowpane, because they need a good throughput and good canal employment. and also they have perfect filaree for polisher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue windowpane, because they need a good throughput and good line employment. and also they have perfect filaree for polisher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are do than the package that arrive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcels, as more parcels are do than the parcel that arrive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcel, as more parcel are served than the packet that come in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 softwares, as more softwares are served than the software that get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcels, as more parcels are attend than the parcel that arrive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific line to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local meshing with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific crease to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local mesh with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific line to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local meshing with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific line to transmit the synchrony signal.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local meshing with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific line to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and commodious enough for local net with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, ahead) (f, c, ahead) (c, b, ahead) c is not feel on the unicast path from b to a (c, d, onwards) c is not feel on the unicast path from d to (c, e, ahead) c is not feel on the unicast path from e to (d, f, ahead) d is not feel on the unicast path from f to (f, g, ahead) f is not feel on the unicast path from g to a leap 2e, a, onwards) (f, a, ahead) jump 3g, a, ahead) jump 4h, a, ahead)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, forwards) (f, c, forwards) (c, b, forwards) c is not observe on the unicast itinerary from b to a (c, d, onwards) c is not observe on the unicast itinerary from d to (c, e, forwards) c is not observe on the unicast itinerary from e to (d, f, forwards) d is not observe on the unicast itinerary from f to (f, g, forwards) f is not observe on the unicast itinerary from g to a leap 2e, a, onwards) (f, a, forwards) jump 3g, a, forwards) jump 4h, a, forwards)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, to, forward) (d, to, forward) (b, to, forward) (e, b, upwards) (g, e, upwards) (h, g, ahead) (f, c, ahead) (c, b, ahead) c is not witness on the unicast way from b to a (c, d, onwards) c is not witness on the unicast way from d to (c, e, ahead) c is not witness on the unicast way from e to (d, f, ahead) d is not witness on the unicast way from f to (f, g, ahead) f is not witness on the unicast way from g to a leap 2e, a, onwards) (f, a, ahead) jump 3g, a, ahead) jump 4h, a, ahead)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. purpose:  help prevent ip speech burlesque. 2. rpf a sender broadcasts to all the stations. when a bundle reaches a is ,the is will check the course. if it is the usually course. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. finding:  help prevent ip address burlesque. 2. rpf a sender broadcasts to all the stations. when a bundle accomplish a is ,the is will check the course. if it is the usually course. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. conclusion:  help prevent ip address burlesque. 2. rpf a sender broadcasts to all the stations. when a bundle reaches a is ,the is will check the course. if it is the ordinarily course. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. determination:  help prevent ip speech parody. 2. rpf a sender broadcasts to all the stations. when a bundle make a is ,the is will check the course. if it is the usually course. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the elongation of the piggy includes the acknowledgment \"ack\". - contains the episode-number ack(sec.no) and confirms the frame(sec.no). - here, the ack acknowledgment can be implicitly yield by the figure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the elongation of the piggy includes the credit \"ack\". - contains the successiveness-number ack(sec.no) and confirms the frame(sec.no). - here, the ack credit can be implicitly founder by the figure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the elongation of the piggy includes the identification \"ack\". - contains the episode-number ack(sec.no) and substantiate the frame(sec.no). - here, the ack identification can be implicitly given by the figure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the elongation of the piggy includes the realization \"ack\". - contains the episode-number ack(sec.no) and confirms the frame(sec.no). - here, the ack realization can be implicitly pass by the figure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the need for the elongation of the piggy includes the identification \"ack\". - contains the episode-number ack(sec.no) and confirms the frame(sec.no). - here, the ack identification can be implicitly collapse by the figure.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the airscrew is that all is know the multicast tree. to fabricate a spanning tree for multicasting, you also have to agree the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is know the multicast tree. to reconstruct a spanning tree for multicasting, you also have to add the entropy of the other is of the multicast group.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the airscrew is that all is know the multicast tree. to build a spanning tree for multicasting, you also have to tally the entropy of the other is of the multicast grouping.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, because the pace of arriver (9) is lower than the pace of service (10). so in mediocre the buffer is always below its maximum capacitance of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, because the pace of comer (9) is lower than the pace of service (10). so in mediocre the buff is always below its maximum capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, because the pace of arrival (9) is lower than the pace of overhaul (10). so in mediocre the buffer is always below its maximum capacitance of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, because the rate of reaching (9) is lower than the rate of serve (10). so in mediocre the buffer is always below its maximum capacitance of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the case, because the rate of arrival (9) is lower than the rate of serving (10). so in mediocre the pilot is always below its maximum capability of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own traverse tree but is do not involve to love the traverse trees each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own traverse tree but is do not need to fuck the traverse tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own traverse tree but is do not need to retire the traverse tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own traverse tree but is do not need to hump the traverse trees each router has entropy which path it would practice for (unicast)-packets becapractice of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own traverse tree but is do not postulate to bed the traverse trees each router has entropy which path it would utilize for (unicast)-packets becautilize of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "l1 help is an unreliable bit menstruum. it is the most basic type of transfer help, without sequence errors. l2 help is a reliable and efficient data transfer between two adjacent locations. transfer could occur between more than 2 places, but a physical connexion is required. l2 functions is data transfer through frameworks with menstruum ascendancy, error ascendancy and punishment and configuration management.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "l1 supporter is an unreliable bit flow. it is the most basic type of transfer supporter, without sequence errors. l2 supporter is a reliable and efficient data transfer between two adjacent locations. transfer could occur between more than 2 places, but a physical connective is required. l2 functions is data transfer through frameworks with flow control, error control and punishment and configuration management.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "l1 avail is an unreliable bit period. it is the most basic type of transfer avail, without sequence errors. l2 avail is a reliable and efficient data transfer between two adjacent locations. transfer could occur between more than 2 places, but a physical connection is required. l2 functions is data transfer through frameworks with period ascendence, error ascendence and punishment and configuration management.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "l1 assistant is an unreliable bit flow. it is the most basic type of transfer assistant, without sequence errors. l2 assistant is a reliable and efficient data transfer between two adjacent locations. transfer could occur between more than 2 places, but a physical connectedness is required. l2 functions is data transfer through frameworks with flow control, error control and punishment and configuration management.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "l1 assist is an unreliable bit menses. it is the most basic type of transfer assist, without sequence errors. l2 assist is a reliable and efficient data transfer between two adjacent locations. transfer could occur between more than 2 places, but a physical connection is required. l2 functions is data transfer through frameworks with menses controller, error controller and punishment and configuration management.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the metre less than 10 parcel because we receive only 9 parcel and reply 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 software because we receive only 9 software and answer 10 software.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the time less than 10 packet because we receive only 9 packet and resolve 10 packet.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the sentence less than 10 parcel because we receive only 9 parcel and serve 10 parcel.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there must not be all the metre less than 10 bundle because we receive only 9 bundle and answer 10 bundle.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own crossbreed tree but is do not need to screw the crossbreed tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own mark tree but is do not need to screw the mark tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own hybridizing tree but is do not need to screw the hybridizing tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own hybrid tree but is do not need to screw the hybrid trees each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own hybrid tree but is do not need to screw the hybrid tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific crease to transmit the synchronicity signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local network with 3 exploiter.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no motivation to have specific crease to transmit the synchroneity signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local network with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific crease to transmit the synchronizing bespeak.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local network with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no need to have specific crease to transmit the synchronising bespeak.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local network with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no demand to have specific crease to transmit the synchronisation signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local network with 3 user.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first in second 0, 9 software come, the waiting time for the first w1 software is not grant therefore assumed with 1 second. now there are 9 software in the polisher. second 1, 9 software more come. the polisher is completely filled with 10 software, 8 more fall. the software are starting to be plate with an average service rate of 10. second 2, there is no software in the polisher. 9 new ones come and are directly plated. from now on the polisher will not be filled again. this means that there are 58 seconds with less than 10 software waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first in second 0, 9 software come, the waiting time for the first w1 software is not pay therefore assumed with 1 second. now there are 9 software in the buffer. second 1, 9 software more come. the buffer is completely filled with 10 software, 8 more fall. the software are starting to be plate with an average service rate of 10. second 2, there is no software in the buffer. 9 new ones come and are directly plated. from now on the buffer will not be filled again. this means that there are 58 seconds with less than 10 software waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first in second 0, 9 software come, the waiting time for the first w1 software is not consecrate therefore assumed with 1 second. now there are 9 software in the buff. second 1, 9 software more come. the buff is completely filled with 10 software, 8 more fall. the software are starting to be plate with an average service rate of 10. second 2, there is no software in the buff. 9 new ones come and are directly plated. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 software waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first in second 0, 9 package come, the await time for the first w1 package is not return therefore assumed with 1 second. now there are 9 package in the cowcatcher. second 1, 9 package more come. the cowcatcher is completely filled with 10 package, 8 more fall. the package are starting to be plate with an average service rate of 10. second 2, there is no package in the cowcatcher. 9 new ones come and are directly plated. from now on the cowcatcher will not be filled again. this means that there are 58 seconds with less than 10 package await in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first in second 0, 9 package come, the waitress time for the first w1 package is not render therefore assumed with 1 second. now there are 9 package in the polisher. second 1, 9 package more come. the polisher is completely filled with 10 package, 8 more fall. the package are starting to be plate with an average service rate of 10. second 2, there is no package in the polisher. 9 new ones come and are directly plated. from now on the polisher will not be filled again. this means that there are 58 seconds with less than 10 package waitress in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in an address, to be capable to send some datum back with the ack. basically it is using the default operation of ship the ack to send also some additional datum back to the transmitter, instead of ship a new frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be station in an address, to be able to send some datum back with the ack. basically it is using the default operation of ship the ack to send also some additional datum back to the transmitter, instead of ship a new frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass size of 1, the sequence should always be correct. if the windowpane glass size is big than 1, there are no demand, but the size is limited by the windowpane glass size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass sizing of 1, the sequence should always be correct. if the windowpane glass sizing is greater than 1, there are no necessary, but the sizing is limited by the windowpane glass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass size of 1, the sequence should always be correct. if the windowpane glass size is greater than 1, there are no requirement, but the size is throttle by the windowpane glass size.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass sizing of 1, the sequence should always be correct. if the windowpane glass sizing is greater than 1, there are no prerequisite, but the sizing is limited by the windowpane glass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane glass sizing of 1, the sequence should always be correct. if the windowpane glass sizing is greater than 1, there are no requirement, but the sizing is limited by the windowpane glass sizing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On average, there are 9 parcels in the buff per second. lambda = 9 t=1 p(less than 10 parcels in the buff) = p(0 parcel) +...+ p(9) parcel = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On median, there are 9 bundle in the buff per second. lambda = 9 t=1 p(less than 10 bundle in the buff) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On average, there are 9 parcels in the buff per second. lambda = 9 t=1 p(less than 10 parcels in the buff) = p(0 parcel) +...+ p(9) parcel = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On median, there are 9 bundle in the buff per second. lambda = 9 t=1 p(less than 10 bundle in the buff) = p(0 packet) +...+ p(9) packet = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On fair, there are 9 bundles in the buff per second. lambda = 9 t=1 p(less than 10 bundles in the buff) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 mailboat arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 mailboat in the buff. at second 1, 9 more mailboat arrive. the buff is completely meet with 10 mailboat, 8 more are dropped.  the mailboat are starting to be function with an average service rate of 10. at second 2, there are no mailboat will in the buff. 9 new ones arrive and are now function. from now on the buff won\u2019t fill up again. this means there are 58 seconds with less than 10 mailboat waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 mailboat arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 mailboat in the buff. at second 1, 9 more mailboat arrive. the buff is completely filled with 10 mailboat, 8 more are dropped.  the mailboat are starting to be subprogram with an average service rate of 10. at second 2, there are no mailboat will in the buff. 9 new ones arrive and are flat subprogram. from now on the buff won\u2019t fill up again. this means there are 58 seconds with less than 10 mailboat waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 mailboat arrive, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 mailboat in the buff. at second 1, 9 more mailboat arrive. the buff is completely filled with 10 mailboat, 8 more are dropped.  the mailboat are starting to be office with an average service rate of 10. at second 2, there are no mailboat will in the buff. 9 new ones arrive and are directly office. from now on the buff won\u2019t fill up again. this means there are 58 seconds with less than 10 mailboat waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forrader)\nhop 2:\n(g,f, forrader), (g,e, forrader)\nhop 3:\n(e,b, forrader), (e,c, forrader), (e,f, drop)<=\u00a0 because of surplus\n(f,c, drop)<= because of surplus, (f,d, forrader)\nhop 4:\n(b,c, drop)<= becuase of surplus, (b,a, forrader), (c,a drop)<= becuase of surplus, (d,a, drop)<= becuase of surplus",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson offset is base on probabilities base on randomly arriving packets, base on t indepedent.\nevery interval is independent to the previous intervals, so arrivals are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, stream clients which have dissimilar and randomly packet arrivals which can be modelled as poisson offset.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson emergence is based on probabilities based on haphazardly arriving packets, based on t indepedent.\nevery interval is independent to the previous intervals, so arrivals are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, swarm clients which have dissimilar and haphazardly packet arrivals which can be modelled as poisson emergence.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson process is based on probabilities based on randomly arriving packets, based on t indepedent.\nevery interval is independent to the previous intervals, so arrivals are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, swarm clients which have dissimilar and randomly packet arrivals which can be modelled as poisson process.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson process is base on probabilities base on randomly arriving packets, base on t indepedent.\nevery interval is independent to the previous intervals, so arrivals are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, teem clients which have dissimilar and randomly packet arrivals which can be modelled as poisson process.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson appendage is based on probabilities based on arbitrarily arriving packets, based on t indepedent.\nevery interval is independent to the previous intervals, so arrivals are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, stream clients which have dissimilar and arbitrarily packet arrivals which can be modelled as poisson appendage.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundles, as more bundles are plate than the bundle come in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 software, as more software are plated than the parcel descend in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 packet, as more packet are plate than the package come in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 packet, as more packet are plated than the packet derive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundles, as more bundles are plate than the bundle come in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own spanning tree but is do not need to cognise the spanning trees each router has entropy which course it would practice for (unicast)-packets becapractice of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own spanning tree but is do not require to cognise the spanning trees each router has entropy which route it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each transmitter has its own traverse tree but is do not require to cognise the traverse trees each router has entropy which path it would utilise for (unicast)-packets becautilise of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own spanning tree but is do not need to cognise the spanning trees each router has entropy which route it would utilise for (unicast)-packets becautilise of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own spanning tree but is do not need to cognise the spanning trees each router has entropy which way it would employ for (unicast)-packets becaemploy of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. purpose: help prevent ip Spoofing direction. 2. rpf a sender transmissions to all stations. when a package gain to is , the is will check the row. if it is the usual row. will be sent to others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. conclusion: help prevent ip Spoofing direction. 2. rpf a sender transmissions to all post. when a package reaches to is , the is will check the form. if it is the usual form. will be sent to others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, ahead)\nhop 2:\n(g,f, ahead), (g,e, ahead)\nhop 3:\n(e,b, ahead), (e,c, ahead), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, ahead)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, ahead), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forward)\nhop 2:\n(g,f, forward), (g,e, forward)\nhop 3:\n(e,b, forward), (e,c, forward), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forward)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forward), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, ahead)\nhop 2:\n(g,f, ahead), (g,e, ahead)\nhop 3:\n(e,b, ahead), (e,c, ahead), (e,f, drop)<=\u00a0 because of gemini\n(f,c, drop)<= because of gemini, (f,d, ahead)\nhop 4:\n(b,c, drop)<= becuase of gemini, (b,a, ahead), (c,a drop)<= becuase of gemini, (d,a, drop)<= becuase of gemini",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forward)\nhop 2:\n(g,f, forward), (g,e, forward)\nhop 3:\n(e,b, forward), (e,c, forward), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forward)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forward), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0392q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(h,g, forwards)\nhop 2:\n(g,f, forwards), (g,e, forwards)\nhop 3:\n(e,b, forwards), (e,c, forwards), (e,f, drop)<=\u00a0 because of similitude\n(f,c, drop)<= because of similitude, (f,d, forwards)\nhop 4:\n(b,c, drop)<= becuase of similitude, (b,a, forwards), (c,a drop)<= becuase of similitude, (d,a, drop)<= becuase of similitude",
        "answer_feedback": "the flow starts from a\u00a0 as sender not h. packets are dropped for being not on the best route, not for being duplicate as the sole reason.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the result frames have to be capable to carry datum + ack and not only ack or only datum. this agency the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the result frames have to be able to expect datum + ack and not only ack or only datum. this manner the ack can be delayed and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer frames have to be able to carry datum + ack and not only ack or only datum. this agency the ack can be retard and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the dissolver frames have to be capable to carry datum + ack and not only ack or only datum. this way the ack can be detain and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the resolvent frames have to be able to sway datum + ack and not only ack or only datum. this way the ack can be delay and sent along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link level of a station must obtain a new bundle from the top level at the end of the waiting clip interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link stratum of a place must obtain a new package from the top stratum at the end of the waiting time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link stratum of a post must obtain a new package from the top stratum at the end of the waiting metre interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link layer of a place must obtain a new packet from the top layer at the end of the waiting sentence interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum link stratum of a station must obtain a new software from the top stratum at the end of the waiting time interval",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. gradation:\nqueue: 10 parcel\nservice: 10 parcel\n\n2. gradation:\nqueue: 9 parcel\nservice: 10 parcel\n\n3.gradation:\nqueue: 9 parcel\nservice: 9 parcel\n\n4. gradation:\nqueue: 9 parcel\nservice: 9 parcel\n\nand so on. if there will always arrive 9 parcel per second and the host can serve maximum 10 parcel per second, there will never be 10 parcel in the queue except in the first gradation.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footmark:\nqueue: 10 package\nservicing: 10 package\n\n2. footmark:\nqueue: 9 package\nservicing: 10 package\n\n3.footmark:\nqueue: 9 package\nservicing: 9 package\n\n4. footmark:\nqueue: 9 package\nservicing: 9 package\n\nand so on. if there will always arrive 9 package per second and the emcee can serve maximum 10 package per second, there will never be 10 package in the queue except in the first footmark.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step:\nqueue: 10 packet\nservice: 10 packet\n\n2. step:\nqueue: 9 packet\nservice: 10 packet\n\n3.step:\nqueue: 9 packet\nservice: 9 packet\n\n4. step:\nqueue: 9 packet\nservice: 9 packet\n\nand so on. if there will always arrive 9 packet per second and the boniface can serve maximum 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. tone:\nqueue: 10 package\nservicing: 10 package\n\n2. tone:\nqueue: 9 package\nservicing: 10 package\n\n3.tone:\nqueue: 9 package\nservicing: 9 package\n\n4. tone:\nqueue: 9 package\nservicing: 9 package\n\nand so on. if there will always arrive 9 package per second and the innkeeper can serve maximum 10 package per second, there will never be 10 package in the queue except in the first tone.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0231q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. stride:\nqueue: 10 bundle\nservice: 10 bundle\n\n2. stride:\nqueue: 9 bundle\nservice: 10 bundle\n\n3.stride:\nqueue: 9 bundle\nservice: 9 bundle\n\n4. stride:\nqueue: 9 bundle\nservice: 9 bundle\n\nand so on. if there will always arrive 9 bundle per second and the innkeeper can serve maximum 10 bundle per second, there will never be 10 bundle in the queue except in the first stride.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only specify the optimal manner from the other knobs to this knob, but also the optimal manners from this knob to the other knobs. link province routing can be used to construct multicast traverse trees by first running the link province routing routine to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any manner between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only specify the optimal way from the other knobs to this knob, but also the optimal ways from this knob to the other knobs. link province routing can be used to retrace multicast traverse trees by first running the link province routing function to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any way between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only specify the optimum way from the other knobs to this knob, but also the optimum ways from this knob to the other knobs. link province routing can be used to manufacture multicast traverse trees by first running the link province routing procedure to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any way between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain guest is that it does not only specify the optimal style from the other guests to this guest, but also the optimal styles from this guest to the other guests. link province routing can be used to construct multicast traverse trees by first running the link province routing subprogram to get the traverse tree for a certain guest x. this traverse tree could already be used as the multicast traverse tree for guest x, but it can be optimized by removing all edges that are not part of any style between any two guests of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the traverse tree for a certain knob is that it does not only specify the optimum way from the other knobs to this knob, but also the optimum ways from this knob to the other knobs. link province routing can be used to build multicast traverse trees by first running the link province routing procedure to get the traverse tree for a certain knob x. this traverse tree could already be used as the multicast traverse tree for knob x, but it can be optimized by removing all edges that are not part of any way between any two knobs of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme poisson arrivals has been justified by claiming that the aggregation of many supreme and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in traffic application scenario that include a large number of supreme traffic flow. the theoretical background behind the usage number from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the single rates decrease to keep the aggregate rate constant. but, traffic aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of autonomous poisson arrivals has been justified by claiming that the aggregation of many autonomous and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in traffic application scenarios that include a large number of autonomous traffic flow. the theoretical background behind the usage follow from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild stipulation, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the single rates decrease to keep the aggregate rate constant. but, traffic aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme poisson arrivals has been justified by claiming that the aggregation of many supreme and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in traffic application scenarios that include a large number of supreme traffic flow. the theoretical background behind the usage do from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the single rates decrease to keep the aggregate rate constant. but, traffic aggregation need not always result in a poisson process. so it holds if the above-cite criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of supreme poisson arrivals has been justified by claiming that the aggregation of many supreme and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in traffic application scenario that include a large number of supreme traffic flow. the theoretical background behind the usage fare from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild conditions, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the single rates decrease to keep the aggregate rate constant. but, traffic aggregation need not always result in a poisson process. so it holds if the above-mentioned criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0879q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the assumption of independent poisson arrivals has been justified by claiming that the aggregation of many independent and identically distributed renewal processes tend to poisson process when the number increases.\n\npoisson processes are conventional in traffic application scenarios that include a large number of independent traffic flow. the theoretical background behind the usage comes from palm's theorem (arrowsmith et al. 2015). it states that under suitable but mild consideration, such a large number of multiplexed flow approach a poisson process as the number of flow grows. still, the single rates decrease to keep the aggregate rate constant. but, traffic aggregation need not always result in a poisson process. so it holds if the above-note criteria apply.",
        "answer_feedback": "the response does not provide an explicit \"yes\" or \"no\". it instead states another underlying condition when the poisson process will hold, without concluding whether it holds for the real internet.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent span receives every frame of each join side. the span board holds the entropy about which components are attached to the network. that means the transparent span receives from the component a a frame which has the entropy \"a can be reached over lan l.\" in the promotion process, the transparent span oversupply the network with this entropy, so that other spans also have the entropy about component a. a benefit of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent span receives every frame of each join side. the span board holds the entropy about which components are attached to the network. that means the transparent span receives from the component a a frame which has the entropy \"a can be reached over lan l.\" in the promotion process, the transparent span floods the network with this entropy, so that other spans also have the entropy about component a. a welfare of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "they do with cushy power in order to work very performant with a placid amount of datum. work is that it is not so good, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "they do with voiced power in order to work very performant with a quiet amount of datum. work is that it is not so good, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "they do with delicate power in order to work very performant with a smooth amount of datum. work is that it is not so unspoilt, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "they do with diffuse power in order to work very performant with a smooth amount of datum. work is that it is not so practiced, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "they do with diffused power in order to mold very performant with a still amount of data. mold is that it is not so good, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- you need an controller - because if the receiver has no means of directing, the director will never get an ack for its targeted forms - so when you receive a form, the receiver has no means of directing and the count is finished, the receiver directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- you need an controller - because if the recipient has no way of directing, the director will never get an ack for its direct forms - so when you receive a form, the recipient has no way of directing and the count is finished, the recipient aim an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- you need an controller - because if the recipient has no style of directing, the director will never get an ack for its targeted forms - so when you receive a form, the recipient has no style of directing and the count is finished, the recipient target an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- you need an controller - because if the receiver has no way of directing, the director will never get an ack for its aim forms - so when you receive a form, the receiver has no way of directing and the count is finished, the receiver directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- you need an controller - because if the recipient has no path of directing, the director will never get an ack for its targeted forms - so when you receive a form, the recipient has no path of directing and the count is finished, the recipient place an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 parcel get, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 parcel in the buff. at second 1, 9 more parcel get. the buff is completely meet with 10 parcel, 8 more are dropped.  the parcel are starting to be answer with an average service rate of 10. at second 2, there are no parcel left in the buff. 9 new ones get and are directly answer. from now on the buff won\u2019t fill up again. this imply there are 58 seconds with less than 10 parcel waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0203q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first at second 0, 9 parcel get, the waiting time for the first packet w1 is not given therefore assumed with 1second. there are now 9 parcel in the buff. at second 1, 9 more parcel get. the buff is completely filled with 10 parcel, 8 more are dropped.  the parcel are starting to be answer with an average service pace of 10. at second 2, there are no parcel left in the buff. 9 new ones get and are directly answer. from now on the buff won\u2019t fill up again. this imply there are 58 seconds with less than 10 parcel waiting in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In the midriff, there are 9 mailboat on the buffer per second. lambda = 9 t=1 p(less than 10 mailboat on the buffer) = p(0 packet) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In the heart, there are 9 packet on the buffer per second. lambda = 9 t=1 p(less than 10 packet on the buffer) = p(0 packet) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In the middle, there are 9 package on the buffer per second. lambda = 9 t=1 p(less than 10 package on the buffer) = p(0 packet) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In the middle, there are 9 bundle on the buffer per second. lambda = 9 t=1 p(less than 10 bundle on the buffer) = p(0 packet) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In the midriff, there are 9 mailboat on the buffer per second. lambda = 9 t=1 p(less than 10 mailboat on the buffer) = p(0 packet) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "loveliness is the problem\uff0cthe datum stockpile is not calculate on the localisation, some have more shape than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "equity is the problem\uff0cthe datum backlog is not calculate on the localisation, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "beauteousness is the problem\uff0cthe datum stockpile is not depending on the locating, some have more form than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "candour is the problem\uff0cthe datum stockpile is not depend on the localisation, some have more build than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "comeliness is the problem\uff0cthe datum reserve is not depending on the localization, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1525q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "if you employ piggbacking on the skid windowpane protocol, \nthe receiver waits for a given time period to attach the sequence number\nand the next ack-sequence number to the next frame.\n\nin order to do that, additional time delay has to be considered and the \nsender has to be informed about the fact, that there are probably no \nstandalone ack chassis transmitted. also, the sender has to attach the \nack to the data himself.",
        "answer_feedback": "the response does not identify the underlying requirement for piggybacking. the above points are related to the implementation of piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1525q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "if you employ piggbacking on the sliding windowpane protocol, \nthe receiver waits for a given conviction period to bind the sequence number\nand the next ack-sequence number to the next frame.\n\nin order to do that, additional conviction delay has to be think and the \nsender has to be informed about the fact, that there are probably no \nstandalone ack frames transmitted. also, the sender has to bind the \nack to the data himself.",
        "answer_feedback": "the response does not identify the underlying requirement for piggybacking. the above points are related to the implementation of piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1525q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "if you employ piggbacking on the sliding windowpane protocol, \nthe receiver waits for a given conviction period to attach the sequence number\nand the next ack-sequence number to the next frame.\n\nin order to do that, additional conviction delay has to be weigh and the \nsender has to be informed about the fact, that there are probably no \nstandalone ack inning transmitted. also, the sender has to attach the \nack to the data himself.",
        "answer_feedback": "the response does not identify the underlying requirement for piggybacking. the above points are related to the implementation of piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1525q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "if you employ piggbacking on the sliding windowpane protocol, \nthe receiver waits for a given conviction period to confiscate the sequence number\nand the next ack-sequence number to the next frame.\n\nin order to do that, additional conviction delay has to be considered and the \nsender has to be informed about the fact, that there are probably no \nstandalone ack physique transmitted. also, the sender has to confiscate the \nack to the data himself.",
        "answer_feedback": "the response does not identify the underlying requirement for piggybacking. the above points are related to the implementation of piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1525q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "if you employ piggbacking on the sliding windowpane protocol, \nthe receiver waits for a given conviction period to bind the sequence number\nand the next ack-sequence number to the next frame.\n\nin order to do that, additional conviction delay has to be considered and the \nsender has to be informed about the fact, that there are probably no \nstandalone ack shape transmitted. also, the sender has to bind the \nack to the data himself.",
        "answer_feedback": "the response does not identify the underlying requirement for piggybacking. the above points are related to the implementation of piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space incur each frame from each side of the junction. the separation board contains the entropy about the components that are connected to the network. this means that the transparent space incur from the component a framework that has the entropy \"a can be reached over lan l.\" in the promotion process, the transparent space floods the network with this entropy, so that other sections also have the entropy about the component a. a benefit of the flood is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space get each frame from each side of the junction. the separation board contains the entropy about the components that are connected to the network. this means that the transparent space get from the component a framework that has the entropy \"a can be reached over lan l.\" in the promotion process, the transparent space floods the network with this entropy, so that other sections also have the entropy about the component a. a benefit of the flood is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in the second 0, 9 packet arrive, the waiting time for the first w1 packet is not given therefore assumed with 1 second. now there are 9 packet in the buff. in the second 1, 9 packet more arrive. the buff is completely filled with 10 packet, 8 more fall. the packet are starting to be with an average service rate of 10. in the second 2, there is no packet in the buff. 9 new packets arrive and are directly made. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 packet waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in the second 0, 9 parcel arrive, the waiting time for the first w1 parcel is not open therefore assumed with 1 second. now there are 9 parcel in the buff. in the second 1, 9 parcel more arrive. the buff is completely filled with 10 parcel, 8 more fall. the parcel are starting to be with an average service rate of 10. in the second 2, there is no parcel in the buff. 9 novel parcels arrive and are directly made. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 parcel waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in the second 0, 9 parcel arrive, the waiting time for the first w1 parcel is not given therefore assumed with 1 second. now there are 9 parcel in the buff. in the second 1, 9 parcel more arrive. the buff is completely filled with 10 parcel, 8 more fall. the parcel are starting to be with an average service rate of 10. in the second 2, there is no parcel in the buff. 9 novel parcels arrive and are directly made. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 parcel waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in the second 0, 9 bundle arrive, the waiting time for the first w1 bundle is not founder therefore assumed with 1 second. now there are 9 bundle in the buff. in the second 1, 9 bundle more arrive. the buff is completely filled with 10 bundle, 8 more fall. the bundle are starting to be with an average service rate of 10. in the second 2, there is no bundle in the buff. 9 new bundles arrive and are directly made. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 bundle waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "First in the second 0, 9 parcel arrive, the waiting time for the first w1 parcel is not render therefore assumed with 1 second. now there are 9 parcel in the buff. in the second 1, 9 parcel more arrive. the buff is completely filled with 10 parcel, 8 more fall. the parcel are starting to be with an average service rate of 10. in the second 2, there is no parcel in the buff. 9 fresh parcels arrive and are directly made. from now on the buff will not be filled again. this means that there are 58 seconds with less than 10 parcel waiting in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer frames have to be able to contain datum + ack and not only ack or only datum. this fashion the ack can be delayed and transport along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer frames have to be able to contain datum + ack and not only ack or only datum. this mode the ack can be delayed and place along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1511q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer frames have to be able to stop datum + ack and not only ack or only datum. this manner the ack can be delayed and air along with datum in one frame.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above point is related to how piggybacking's implementation works and not what is required for piggybacking to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. purpose:  help prevent ip reference burlesque. 2. rpf a transmitter broadcasts to all the stations. when a megabucks reaches a is ,the is will check the itinerary. if it is the usually itinerary. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. purpose:  help prevent ip destination burlesque. 2. rpf a sender broadcasts to all the stations. when a megabucks reaches a is ,the is will check the itinerary. if it is the normally itinerary. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skim 1c, a, forrard) (d, a, forrard) (b, a, forrard) (e, b, forrard) (g, e, forrard) (h, g, forrard) (f, c, forrard) (c, b, cliff) c is not found on the unicast path of b a a (c, d, cliff) c is not found on the unicast path of d a (c, e, cliff) c is not found on the unicast path of e a (d, f, cliff) d is not found on the unicast path of f a (f, g, cliff) f is not found on the unicat path of g to a jump 2e, a, forrard) (f, a, forrard) skim 3g, a, forrard) skim 4h, a, forrard)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "cut 1c, a, forrard) (d, a, forrard) (b, a, forrard) (e, b, forrard) (g, e, forrard) (h, g, forrard) (f, c, forrard) (c, b, drib) c is not notice on the unicast path of b a a (c, d, drib) c is not notice on the unicast path of d a (c, e, drib) c is not notice on the unicast path of e a (d, f, drib) d is not notice on the unicast path of f a (f, g, drib) f is not notice on the unicat path of g to a jump 2e, a, forrard) (f, a, forrard) cut 3g, a, forrard) cut 4h, a, forrard)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "jump 1c, a, forrard) (d, a, forrard) (b, a, forrard) (e, b, forrard) (g, e, forrard) (h, g, forrard) (f, c, forrard) (c, b, bead) c is not found on the unicast itinerary of b a a (c, d, bead) c is not found on the unicast itinerary of d a (c, e, bead) c is not found on the unicast itinerary of e a (d, f, bead) d is not found on the unicast itinerary of f a (f, g, bead) f is not found on the unicat itinerary of g to a jump 2e, a, forrard) (f, a, forrard) jump 3g, a, forrard) jump 4h, a, forrard)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, forrard) (d, a, forrard) (b, a, forrard) (e, b, forrard) (g, e, forrard) (h, g, forrard) (f, c, forrard) (c, b, drib) c is not rule on the unicast track of b a a (c, d, drib) c is not rule on the unicast track of d a (c, e, drib) c is not rule on the unicast track of e a (d, f, drib) d is not rule on the unicast track of f a (f, g, drib) f is not rule on the unicat track of g to a jump 2e, a, forrard) (f, a, forrard) skip 3g, a, forrard) skip 4h, a, forrard)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skim 1c, a, forrard) (d, a, forrard) (b, a, forrard) (e, b, forrard) (g, e, forrard) (h, g, forrard) (f, c, forrard) (c, b, fall) c is not found on the unicast track of b a a (c, d, fall) c is not found on the unicast track of d a (c, e, fall) c is not found on the unicast track of e a (d, f, fall) d is not found on the unicast track of f a (f, g, fall) f is not found on the unicat track of g to a jump 2e, a, forrard) (f, a, forrard) skim 3g, a, forrard) skim 4h, a, forrard)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the belongings is that all is to know the multicast tree. to rebuild a crossbreed tree for multicast, you also have to lend the entropy of the other is from the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the dimension is that all is to cognize the multicast tree. to rebuild a cross tree for multicast, you also have to add the entropy of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the holding is that all is to know the multicast tree. to rebuild a cross tree for multicast, you also have to bestow the entropy of the other is from the multicast grouping.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the prop is that all is to bed the multicast tree. to rebuild a cross tree for multicast, you also have to add the entropy of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is that all is to experience the multicast tree. to rebuild a hybridizing tree for multicast, you also have to add the entropy of the other is from the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "influence with gamy-mogul in order to work very performant with a measure of data gamy. trouble is that it is not so well, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "influence with gamy-exponent in lodge to work very performant with a amount of data gamy. problem is that it is not so well, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "influence with gamy-tycoon in order to run very performant with a amount of data gamy. problem is that it is not so well, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "influence with gamy-king in order to solve very performant with a quantity of data gamy. job is that it is not so well, when there is less data.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent dyad receives every form of each connect side. the dyad table holds the entropy about which components are attached to the network. that imply the transparent dyad receives from the component a a form which has the entropy \"a can be reached over lan l.\" in the forwarding process, the transparent dyad floods the network with this entropy, so that other dyads also have the entropy about component a. a benefit of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent duo receives every frame of each connect side. the duo table holds the entropy about which components are attached to the network. that imply the transparent duo receives from the component a a frame which has the entropy \"a can be reached over lan l.\" in the forwarding process, the transparent duo floods the network with this entropy, so that other duos also have the entropy about component a. a welfare of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent straddle receives every frame of each connect side. the straddle table holds the information about which components are attached to the network. that imply the transparent straddle receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding procedure, the transparent straddle floods the network with this information, so that other straddles also have the information about component a. a welfare of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent brace receives every shape of each connect side. the brace table holds the entropy about which components are attached to the network. that imply the transparent brace receives from the component a a shape which has the entropy \"a can be reached over lan l.\" in the forwarding process, the transparent brace floods the network with this entropy, so that other braces also have the entropy about component a. a benefit of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent straddle receives every anatomy of each connect side. the straddle table holds the entropy about which components are attached to the network. that imply the transparent straddle receives from the component a a anatomy which has the entropy \"a can be reached over lan l.\" in the forwarding process, the transparent straddle floods the network with this entropy, so that other straddles also have the entropy about component a. a benefit of flooding is that it uses the shortest path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the case, because the reaching pace (9) is lower than the serve pace (10). \nso on mediocre the buffer is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the casing, because the reaching pace (9) is lower than the serving pace (10). \nso on mediocre the buff is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the casing, because the arrival pace (9) is lower than the help pace (10). \nso on mediocre the cowcatcher is always below its maximal capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the casing, because the arrival pace (9) is lower than the overhaul pace (10). \nso on mediocre the cowcatcher is always below its maximal capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the casing, because the arriver pace (9) is lower than the serve pace (10). \nso on mediocre the fender is always below its maximum capacity of 10.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. the correct answer is 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this net i advise to use the differential manchester encryption: this encryption technique is robust in clock convalescence and hence offers synchronization facility at receiver because a transition is guaranteed at least once every snatch. in improver, it is less error-prone in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this meshing i advise to use the differential manchester encoding: this encoding technique is robust in clock convalescence and hence offers synchronization facility at receiver because a transition is guaranteed at least once every snatch. in gain, it is less error-prostrate in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this network i advise to use the differential manchester encryption: this encryption technique is rich in clock convalescence and hence offers synchronization facility at receiver because a transition is guaranteed at least once every snatch. in improver, it is less error-prone in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this mesh i advise to use the differential manchester encoding: this encoding technique is robust in clock convalescence and hence offers synchronization facility at receiver because a transition is guaranteed at least once every snatch. in accession, it is less error-prostrate in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0101q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for this meshwork i advise to use the differential manchester encryption: this encryption technique is robust in clock convalescence and hence offers synchronization facility at receiver because a transition is guaranteed at least once every snatch. in addition, it is less error-prostrate in noisy environments.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "sliding window, because they need a salutary throughput and salutary groove utilization. and also they have sodding alfileria for pilot.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "sliding windowpane, because they need a salutary throughput and salutary groove exercise. and also they have perfect clocks for buffer.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "sliding window, because they need a salutary throughput and salutary groove utilisation. and also they have unadulterated clocks for pilot.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "sliding window, because they need a salutary throughput and salutary groove utilisation. and also they have everlasting clocks for pilot.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "sliding window, because they need a salutary throughput and salutary groove utilisation. and also they have consummate clocks for pilot.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 package, since more package are do than the package descend in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 share, since more share are do than the share derive in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 share, since more share are do than the share do in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 tract, since more tract are do than the tract follow in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 tract, since more tract are do than the tract arrive in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirement are listed below 1. an interlocal agreement between the agencies must be signed and lodge with the county auditor or brought online; 2. the original catching agency has complied with all the requirement and publishes the call online; and 3. the seller accepts the agreement through the initial call.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the demand are listed below 1. an interlocal agreement between the agencies must be signed and filed with the county auditor or brought online; 2. the original catching agency has complied with all the demand and publishes the call online; and 3. the trafficker accepts the agreement through the initial call.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an interlocal agreement between the agencies must be signed and file with the county auditor or brought online; 2. the original catching agency has complied with all the requirements and publishes the call online; and 3. the seller consent the agreement through the initial call.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the prerequisite are listed below 1. an interlocal agreement between the agencies must be signed and filed with the county auditor or brought online; 2. the original catching agency has complied with all the prerequisite and publishes the call online; and 3. the vendor accepts the agreement through the initial call.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below 1. an interlocal agreement between the agencies must be signed and charge with the county auditor or brought online; 2. the original catching agency has complied with all the requirements and publishes the call online; and 3. the trafficker accepts the agreement through the initial call.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson scattering is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the yesteryear. the poisson scattering is often used to model the arrival of packets during a separation. the arrival times of packets modeled by the poisson scattering have an exponential scattering and constitute an very sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential scattering, so the error introduced by modeling them as poisson scattering is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson scattering is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the yesteryear. the poisson scattering is often used to model the arrival of packets during a separation. the arrival times of packets modeled by the poisson scattering have an exponential scattering and constitute an very sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential scattering, so the error introduced by modeling them as poisson scattering is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson scattering is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the yesteryear. the poisson scattering is often used to model the arrival of packets during a separation. the arrival times of packets modeled by the poisson scattering have an exponential scattering and constitute an very sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential scattering, so the error introduced by modeling them as poisson scattering is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson dissemination is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the yesteryear. the poisson dissemination is often used to model the arrival of packets during a separation. the arrival times of packets modeled by the poisson dissemination have an exponential dissemination and constitute an identical sovereign dissemination process. however, in practice it has been shown that packet arrival times do not have an exponential dissemination, so the error introduced by modeling them as poisson dissemination is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important feature of the poisson scattering is that the probability of x taking a discrete value is sovereign over the above values, i.e. the probability is sovereign of the yesteryear. the poisson scattering is often used to model the arrival of packets during a separation. the arrival times of packets modeled by the poisson scattering have an exponential scattering and constitute an superposable sovereign distribution process. however, in practice it has been shown that packet arrival times do not have an exponential scattering, so the error introduced by modeling them as poisson scattering is significantly large.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 packet take reward: 10 packet 2. step: queue: 9 packet take reward: 10 packet 3. step: queue: 9 packet take reward: 9 packet take reward: 9 packet and so on. if there will always be 9 packet per second and the waiter can serve a maximum of 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 packet take vantage: 10 packet 2. step: queue: 9 packet take vantage: 10 packet 3. step: queue: 9 packet take vantage: 9 packet take vantage: 9 packet and so on. if there will always be 9 packet per second and the waiter can serve a maximum of 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 packet take vantage: 10 packet 2. step: queue: 9 packet take vantage: 10 packet 3. step: queue: 9 packet take vantage: 9 packet take vantage: 9 packet and so on. if there will always be 9 packet per second and the waiter can serve a maximum of 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. pace: queue: 10 packet take advantage: 10 packet 2. pace: queue: 9 packet take advantage: 10 packet 3. pace: queue: 9 packet take advantage: 9 packet take advantage: 9 packet and so on. if there will always be 9 packet per second and the waiter can process a maximum of 10 packet per second, there will never be 10 packet in the queue except in the first pace.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. step: queue: 10 packet take reward: 10 packet 2. step: queue: 9 packet take reward: 10 packet 3. step: queue: 9 packet take reward: 9 packet take reward: 9 packet and so on. if there will always be 9 packet per second and the waiter can function a maximum of 10 packet per second, there will never be 10 packet in the queue except in the first step.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on average, there are 9 packet in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 packet in the buff) = p(0 packet) +...+ p(9 packet) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on mean, there are 9 software in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 software in the buff) = p(0 software) +...+ p(9 software) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on median, there are 9 parcel in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the buff) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on medium, there are 9 parcel in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the buff) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on average, there are 9 parcel in the buff per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the buff) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 software, since more software are service than the software get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 packet, since more packet are service than the packet get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 bundle, since more bundle are serving than the bundle get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 parcel, since more parcel are service than the parcel get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0239q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "for every seconds, there will be less than 10 packet, since more packet are avail than the packet get in the queue.",
        "answer_feedback": "the response implies that the system is waiting for a whole minute which is incorrect as the system is less than full for 56.95 seconds instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this meshwork I advise using differential manchester encryption: this coding technique is robust in clock convalescence and therefore offers ease of synchronization in the receiver because a transition is guaranteed at least once each start. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this net I advise using differential manchester encryption: this coding technique is robust in clock convalescence and therefore offers ease of synchronization in the receiver because a transition is guaranteed at least once each start. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this network I advise using differential manchester encryption: this coding technique is robust in clock convalescence and therefore offers ease of synchronization in the receiver because a modulation is guaranteed at least once each start. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this mesh I advise using differential manchester encryption: this coding technique is robust in clock convalescence and therefore offers ease of synchronization in the receiver because a passage is guaranteed at least once each start. In addition, it is less prone to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this web I advise using differential manchester encoding: this coding technique is robust in clock convalescence and therefore offers ease of synchronization in the receiver because a conversion is guaranteed at least once each start. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window sizing of 1, the sequence must always be correct.\nif the window sizing is capital than 1, there are no requirements, but the sizing is ricochet by the window sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window size of 1, the sequence must always be correct.\nif the window size is expectant than 1, there are no requirements, but the size is bound by the window size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window size of 1, the sequence must always be correct.\nif the window size is greater than 1, there are no requirements, but the size is constipate by the window size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane size of 1, the sequence must always be correct.\nif the windowpane size is cracking than 1, there are no requirements, but the size is trammel by the windowpane size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window size of 1, the sequence must always be correct.\nif the window size is greater than 1, there are no requirements, but the size is spring by the window size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to charge the datum as a parcel and does not have to charge a single parcel for each receiver, it is also not required to know all the recipient as the tree will go to the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to send the datum as a packet and does not have to send a single packet for each receiver, it is also not required to love all the liquidator as the tree will go to the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to transmit the datum as a package and does not have to transmit a single package for each recipient, it is also not required to bonk all the recipients as the tree will go to the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to broadcast the datum as a package and does not have to broadcast a single package for each recipient, it is also not required to know all the recipients as the tree will go to the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to station the datum as a software and does not have to station a single software for each liquidator, it is also not required to know all the liquidators as the tree will go to the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the essential are listed below\n1. an interlocal agreement between agencies must be signal and filed with the county attender or posted online;\n2. the original contracting agency has complied with all essential and posts the appeal online; and\n3. the vendor concord to the arrangement through the initial appeal.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on imply, there are 9 packet in the cowcatcher per second.\nlambda = 9\nt=1\n\np(less than 10 packet in the cowcatcher) = p(0 packet) +...+ p(9 packet) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on entail, there are 9 package in the buffer per second.\nlambda = 9\nt=1\n\np(less than 10 package in the buffer) = p(0 package) +...+ p(9 package) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on imply, there are 9 package in the cowcatcher per second.\nlambda = 9\nt=1\n\np(less than 10 package in the cowcatcher) = p(0 package) +...+ p(9 package) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on mean, there are 9 packet in the pilot per second.\nlambda = 9\nt=1\n\np(less than 10 packet in the pilot) = p(0 packet) +...+ p(9 packet) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on mean, there are 9 software in the pilot per second.\nlambda = 9\nt=1\n\np(less than 10 software in the pilot) = p(0 software) +...+ p(9 software) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the essential for the piggybacking extension includes the acknowledgment \"ack\".\n- it contains the sequence-number ack(seq.no) and support the frame(seq.no). \n- here, the acknowledgment ack can be reappearance by the frames implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the essential for the piggybacking extension includes the acknowledgment \"ack\".\n- it contains the sequence-turn ack(seq.no) and corroborate the frame(seq.no). \n- here, the acknowledgment ack can be return by the frames implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the essential for the piggybacking extension admit the acknowledgment \"ack\".\n- it contains the sequence-number ack(seq.no) and confirms the frame(seq.no). \n- here, the acknowledgment ack can be rejoinder by the frames implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the essential for the piggybacking extension include the acknowledgment \"ack\".\n- it contains the sequence-number ack(seq.no) and confirms the frame(seq.no). \n- here, the acknowledgment ack can be retort by the frames implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1489q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the essential for the piggybacking extension include the acknowledgment \"ack\".\n- it contains the sequence-act ack(seq.no) and confirms the frame(seq.no). \n- here, the acknowledgment ack can be return by the frames implicitly.",
        "answer_feedback": "the response answers the requirement incorrectly. the response states what happens in piggybacking/flow control in general, but a duplex channel is required for it to work.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skip 1c, a, off)\u00a0 (d, a, off)\u00a0 (b, a, off)\u00a0 (e, b, off)\u00a0 (g, e, off)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(h,g,off)\u00a0 \u00a0(f,c,off)\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, b, drop) c\u00a0is not located on the unicast itinerary from b to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, d, drop)\u00a0c\u00a0is not located on the unicast itinerary from d to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(c, e, drop)\u00a0c\u00a0is not located on the unicast itinerary from e to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(d, f, drop)\u00a0d\u00a0is not located on the unicast itinerary from f to a\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(f, g, drop)\u00a0f\u00a0is not located on the unicast itinerary from g to a\nskip 2e, a, off)\u00a0(f, a, off)\nskip 3g, a, off)\u00a0 \u00a0 \u00a0\nskip 4h, a, off)",
        "answer_feedback": "the response is incorrect. please check the model solution.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - flow restraint in the mechanism of credit of the shipping layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - period control in the mechanics of citation of the transport layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - flow restraint in the mechanics of mention of the rapture layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - flow ascendancy in the mechanics of mention of the ecstasy layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - menses control in the mechanics of mention of the shipping layer + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "works with gamey-mogul in fiat to work very performant with a gamey amount of datum. problem is that it is not so practiced, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "works with gamey-tycoon in fiat to work very performant with a gamey amount of datum. problem is that it is not so well, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "works with gamey-office in society to work very performant with a gamey amount of datum. problem is that it is not so estimable, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "works with mettlesome-ability in rescript to work very performant with a mettlesome amount of datum. problem is that it is not so good, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "works with juicy-power in edict to work very performant with a juicy amount of datum. problem is that it is not so honest, when there is less datum.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the appendage still changes the countries when it is in residuum. however, the probability of stable country pk to find the appendage in country k no longer changes, so dpk (t )/dt = 0. in residuum, is deduced from dpk (t )/dt = 0 that the probability period, also called period, in country k is equal to the probability period outside country k. this yields the equations of global equilibrium: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the appendage still changes the countries when it is in libra. however, the chance of stable country pk to find the appendage in country k no longer changes, so dpk (t )/dt = 0. in libra, is deduced from dpk (t )/dt = 0 that the chance flow, also called flow, in country k is equal to the chance flow outside country k. this yields the equations of global equilibrium: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the summons still changes the countries when it is in equipoise. however, the probability of stable country pk to find the summons in country k no longer changes, so dpk (t )/dt = 0. in equipoise, is deduced from dpk (t )/dt = 0 that the probability flow, also shout flow, in country k is equal to the probability flow outside country k. this yields the equations of global equilibrium: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the outgrowth still changes the countries when it is in counterweight. however, the probability of stable country pk to find the outgrowth in country k no longer changes, so dpk (t )/dt = 0. in counterweight, is deduced from dpk (t )/dt = 0 that the probability catamenia, also called catamenia, in country k is equal to the probability catamenia outside country k. this yields the equations of global equilibrium: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes the countries when it is in residue. however, the chance of stable country pk to find the process in country k no longer changes, so dpk (t )/dt = 0. in residue, is deduced from dpk (t )/dt = 0 that the chance catamenia, also called catamenia, in country k is equal to the chance catamenia outside country k. this yields the equations of global equilibrium: (sum from k = 0 to infinity) = pk = 1",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own hybridizing-tree, but it is not necessary to lay the hybridizing-trees each roadr has entropy that road would utilize for (unicast)-packages due to unicast routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own hybridizing-tree, but it is not necessary to lay the hybridizing-tree each router has entropy that route would use for (unicast)-packages due to unicast routing algorithm",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an crucial characteristic of the poisson dissemination is that the probability of x taking a discrete value is autonomous upon the previous values i.e. the probability is autonomous of the past. poisson dissemination is often used to model reaching of packets during an separation. the packet reaching times modeled by the poisson dissemination have an exponential dissemination and constitute an autonomous identically distributed process. however, in practice it has been shown that the packet inter-reaching times do not have an exponential dissemination, hence the error introduced by modeling them as poisson dissemination is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an crucial characteristic of the poisson dispersal is that the probability of x taking a discrete value is autonomous upon the previous values i.e. the probability is autonomous of the past. poisson dispersal is often used to model reaching of packets during an separation. the packet reaching times modeled by the poisson dispersal have an exponential dispersal and constitute an autonomous identically distributed process. however, in practice it has been shown that the packet inter-reaching times do not have an exponential dispersal, hence the error introduced by modeling them as poisson dispersal is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson distribution is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson distribution is often used to model arriver of packets during an separation. the packet arriver times modeled by the poisson distribution have an exponential distribution and constitute an sovereign identically distributed process. however, in practice it has been shown that the packet inter-arriver times do not have an exponential distribution, hence the error introduced by modeling them as poisson distribution is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson distribution is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson distribution is often used to model reaching of packets during an separation. the packet reaching times modeled by the poisson distribution have an exponential distribution and constitute an sovereign identically distributed process. however, in practice it has been shown that the packet inter-reaching times do not have an exponential distribution, hence the error introduced by modeling them as poisson distribution is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson scattering is that the probability of x taking a discrete value is autonomous upon the previous values i.e. the probability is autonomous of the past. poisson scattering is often used to model comer of packets during an separation. the packet comer times modeled by the poisson scattering have an exponential scattering and constitute an autonomous identically distributed process. however, in practice it has been shown that the packet inter-comer times do not have an exponential scattering, hence the error introduced by posture them as poisson scattering is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1116q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the holding is that all is know the multicast tree. to build a sweep tree for multicasting, you also have to bestow the entropy of the other is of the multicast grouping.",
        "answer_feedback": "initially, only each is is aware of which group it belongs to and still needs to discover other group members. to construct a multicast spanning tree, we need to add the information to which group each is belongs. the response does not state how this information is added, propagated, and used to construct the multicast spanning tree.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson diffusion is that the probability of x taking a distinct value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson diffusion is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson diffusion have an exponential diffusion and constitute an sovereign identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential diffusion, hence the error introduced by modeling them as poisson diffusion is significantly tumid.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson diffusion is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson diffusion is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson diffusion have an exponential diffusion and constitute an sovereign identically disseminate process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential diffusion, hence the error introduced by modeling them as poisson diffusion is significantly large.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson dispersal is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson dispersal is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson dispersal have an exponential dispersal and constitute an sovereign identically circularise process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential dispersal, hence the error introduced by modeling them as poisson dispersal is significantly magnanimous.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson dissemination is that the probability of x taking a discrete value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson dissemination is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson dissemination have an exponential dissemination and constitute an sovereign identically propagate process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential dissemination, hence the error introduced by modeling them as poisson dissemination is significantly big.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0885q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "an important characteristic of the poisson diffusion is that the probability of x taking a distinct value is sovereign upon the previous values i.e. the probability is sovereign of the past. poisson diffusion is often used to model arrival of packets during an separation. the packet arrival times modeled by the poisson diffusion have an exponential diffusion and constitute an sovereign identically distributed process. however, in practice it has been shown that the packet inter-arrival times do not have an exponential diffusion, hence the error introduced by modeling them as poisson diffusion is significantly expectant.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals at the same node for real internet traffic. however, the response states an explanation of the error introduced while modelling the packet arrival using poisson distribution due to non-exponential distributions.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the arrangement will be for the whole clip in a state, in which there are less than 10 megabucks waiting in the queue, due to the fact that there are always more megabucks processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of megabucks in the arrangement\nn =  utilisation / 1 - utilisation which pay = 9 megabucks\nwe can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every clip, the probability that the arrangement is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the arrangement will be for the whole clip in a state, in which there are less than 10 pile waiting in the queue, due to the fact that there are always more pile processed pro second than arriving.\nutilisation = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of pile in the arrangement\nn =  utilisation / 1 - utilisation which collapse = 9 pile\nwe can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every clip, the probability that the arrangement is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the arrangement will be for the whole clip in a state, in which there are less than 10 megabucks waiting in the queue, due to the fact that there are always more megabucks processed pro second than arriving.\nutilisation = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - median number of megabucks in the arrangement\nn =  utilisation / 1 - utilisation which gives = 9 megabucks\nwe can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every clip, the probability that the arrangement is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the arrangement will be for the whole clip in a state, in which there are less than 10 pile waiting in the queue, due to the fact that there are always more pile processed pro second than arriving.\nutilisation = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9\nn - median number of pile in the arrangement\nn =  utilisation / 1 - utilisation which sacrifice = 9 pile\nwe can also calculate the probability, that the arrangement is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilisation ist the same at every clip, the probability that the arrangement is full remains equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data connection level of one station must get a fresh packet from the upper level by the destruction of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data connection layer of one station must get a young bundle from the upper layer by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data connection stratum of one station must get a fresh mailboat from the upper stratum by the death of the timeout separation",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data connection level of one station must get a raw packet from the upper level by the dying of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data connection class of one station must get a fresh bundle from the upper class by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the replacement of datum does not calculate on positioning, some have more stimulus than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the substitute of datum does not depend on place, some have more input than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the substitution of datum does not depend on position, some have more input than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the replacement of datum does not bet on positioning, some have more stimulant than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "justice is the problem, the substitution of datum does not depend on position, some have more input than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only ask to station out the datum as one bundle and dont have to station a single bundle for each receiver, you also dont ask to know all the receivers as the tree will handle the transmittal.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to air out the datum as one parcel and dont have to air a single parcel for each receiver, you also dont need to know all the receivers as the tree will handle the transmitting.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only take to send out the datum as one package and dont have to send a single package for each recipient, you also dont take to know all the recipients as the tree will handle the transmitting.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only require to send out the datum as one package and dont have to send a single package for each liquidator, you also dont require to know all the liquidators as the tree will handle the transmitting.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1104q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that you only need to station out the datum as one mailboat and dont have to station a single mailboat for each receiver, you also dont need to know all the receivers as the tree will handle the transmitting.",
        "answer_feedback": "the response's reasoning will not hold when we have a sender with 5 nodes directly connected to it. in such a case, 5 copies will be made at the sender and individually sent to each node. the explanation for the link-state modification is missing.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole cadence in a state, in which there are less than 10 packets waiting in the queue, due to the fact that there are always more packets processed pro second than arriving.\nutilization = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of packets in the organisation\nn =  utilization / 1 - utilization which gives = 9 packets\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilization ist the same at every cadence, the probability that the organisation is full persist equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole measure in a state, in which there are less than 10 packets waiting in the queue, due to the fact that there are always more packets processed pro second than arriving.\nemployment = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of packets in the organisation\nn =  employment / 1 - employment which gives = 9 packets\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the employment ist the same at every measure, the probability that the organisation is full persist equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole cadence in a state, in which there are less than 10 packets waiting in the queue, due to the fact that there are always more packets processed pro second than arriving.\nutilization = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of packets in the organisation\nn =  utilization / 1 - utilization which gives = 9 packets\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilization ist the same at every cadence, the probability that the organisation is full persist equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0237q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "in this case the organisation will be for the whole cadence in a state, in which there are less than 10 packets waiting in the queue, due to the fact that there are always more packets processed pro second than arriving.\nutilization = arrival pace / service pace = 9 pkts/s / 10 pkts/s = 0.9\nn - average number of packets in the organisation\nn =  utilization / 1 - utilization which gives = 9 packets\nwe can also calculate the probability, that the organisation is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the utilization ist the same at every cadence, the probability that the organisation is full persist equally.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time as was done for p_10. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. pace: queue: 10 packet take reward: 10 packet 2. pace: queue: 9 packet take reward: 10 packet 3. pace: queue: 9 packet take reward: 9 packet 4. pace: queue: 9 packet takes reward: 9 packet and so on. if you always arrive 9 packet per second and the server can serve a maximum of 10 packet per second, there will never be 10 packet in queue except in the first pace.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. gradation: queue: 10 bundle take reward: 10 bundle 2. gradation: queue: 9 bundle take reward: 10 bundle 3. gradation: queue: 9 bundle take reward: 9 bundle 4. gradation: queue: 9 bundle takes reward: 9 bundle and so on. if you always arrive 9 bundle per second and the server can serve a maximum of 10 bundle per second, there will never be 10 bundle in queue except in the first gradation.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. tone: queue: 10 bundle take advantage: 10 bundle 2. tone: queue: 9 bundle take advantage: 10 bundle 3. tone: queue: 9 bundle take advantage: 9 bundle 4. tone: queue: 9 bundle takes advantage: 9 bundle and so on. if you always arrive 9 bundle per second and the host can serve a maximum of 10 bundle per second, there will never be 10 bundle in queue except in the first tone.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. stride: queue: 10 package take vantage: 10 package 2. stride: queue: 9 package take vantage: 10 package 3. stride: queue: 9 package take vantage: 9 package 4. stride: queue: 9 package takes vantage: 9 package and so on. if you always arrive 9 package per second and the waiter can serve a maximum of 10 package per second, there will never be 10 package in queue except in the first stride.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "1. footprint: queue: 10 software take advantage: 10 software 2. footprint: queue: 9 software take advantage: 10 software 3. footprint: queue: 9 software take advantage: 9 software 4. footprint: queue: 9 software takes advantage: 9 software and so on. if you always arrive 9 software per second and the host can serve a maximum of 10 software per second, there will never be 10 software in queue except in the first footprint.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes lands when it is in equipoise. however, the steady-land chance pk to find the process in land k does not change anymore, thus dpk (t )/dt = 0. \n\nin equipoise, it follows from dpk (t )/dt = 0 that the chance flow, also called flux, into land k equals the chance flow out of land k. this cede the global balance equations:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes areas when it is in counterbalance. however, the steady-area probability pk to find the process in area k does not change anymore, thus dpk (t )/dt = 0. \n\nin counterbalance, it follows from dpk (t )/dt = 0 that the probability flow, also called flux, into area k equals the probability flow out of area k. this cede the global balance equations:\n(summate starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still commutes areas when it is in equilibrium. however, the steady-area probability pk to find the process in area k does not commute anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the probability flow, also called flux, into area k equals the probability flow out of area k. this cede the global balance equations:\n(total starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still changes states when it is in equilibrium. however, the steady-state chance pk to find the process in state k does not change anymore, thus dpk (t )/dt = 0. \n\nin equilibrium, it follows from dpk (t )/dt = 0 that the chance flow, also called flux, into state k equals the chance flow out of state k. this cede the global balance equations:\n(summate starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0223q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the process still converts lands when it is in balance. however, the steady-land probability pk to find the process in land k does not convert anymore, thus dpk (t )/dt = 0. \n\nin balance, it follows from dpk (t )/dt = 0 that the probability flow, also called flux, into land k equals the probability flow out of land k. this cede the global balance equations:\n(sum starting from k=0 until infinity) => pk =1",
        "answer_feedback": "the response is incorrect because it states a description of the system's equilibrium state. however, the question requirement is to calculate the number of expected seconds where the system has less than 10 packets waiting in the queue.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue windowpane, because they need a good throughput and good channel utilisation. and also they have perfect clocks for cowcatcher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need a safe throughput and safe channel exercise. and also they have utter clocks for cowcatcher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need a safe throughput and safe channel exercise. and also they have stark clocks for polisher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need a good throughput and good channel employment. and also they have perfect clocks for cowcatcher.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0156q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "slue window, because they need a dependable throughput and dependable channel exercise. and also they have perfect clocks for pilot.",
        "answer_feedback": "non-related response, the question asks for the encoding types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. menstruum control: make sure that a transmitter does not send faster than a recipient can receive 2. frame: datum are packaged in a frame, this frame contains, for example, the datum, destination address and source 3. Error detection: important to make sure that the entire datum has been received aright. if an error is warned, the recipient can be signaled to send the datum again",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. menstruum control: make sure that a transmitter does not send faster than a liquidator can receive 2. frame: datum are packaged in a frame, this frame contains, for case, the datum, destination address and source 3. Error detection: important to make sure that the entire datum has been received correctly. if an error is warned, the liquidator can be signaled to send the datum again",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. flowing control: make sure that a transmitter does not send faster than a liquidator can receive 2. frame: datum are packaged in a frame, this frame contains, for example, the datum, destination address and source 3. Error detection: important to make sure that the entire datum has been received aright. if an error is warned, the liquidator can be signaled to send the datum again",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. Flow control: make sure that a transmitter does not send faster than a liquidator can receive 2. frame: datum are packaged in a frame, this frame contains, for model, the datum, destination address and source 3. Error detection: important to make sure that the entire datum has been received aright. if an error is warned, the liquidator can be signaled to send the datum again",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. menstruum control: make sure that a transmitter does not send faster than a receiver can receive 2. frame: datum are packaged in a frame, this frame contains, for instance, the datum, destination destination and source 3. Error detection: important to make sure that the entire datum has been received correctly. if an error is warned, the receiver can be signaled to send the datum again",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 portion because we welcome only 9 portion and function 10 portion. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 package because we welcome only 9 package and function 10 package. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 package because we receive only 9 package and serve 10 package. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 package because we welcome only 9 package and function 10 package. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0215q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "there should be all the time less than 10 package because we receive only 9 package and work 10 package. ^^",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time (60 seconds) is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the system will be for the entire metro in a state, in which there are less than 10 packet waiting in the queue, because there is always more packet processed pro second than arriving. utilization = arrival rate / overhaul rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packet in the system n = use / 1 - use giving = 9 packet we can also calculate the chance, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is equal in each meter, the chance that the system is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the system will be for the entire metro in a state, in which there are less than 10 packet waiting in the queue, because there is always more packet processed pro second than arrive. utilization = arrival rate / avail rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packet in the system n = use / 1 - use giving = 9 packet we can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is equal in each meter, the probability that the system is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the system will be for the entire metro in a state, in which there are less than 10 packet waiting in the queue, because there is always more packet processed pro second than get. utilization = arrival rate / service rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packet in the system n = use / 1 - use giving = 9 packet we can also calculate the chance, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is equal in each meter, the chance that the system is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the system will be for the entire metro in a state, in which there are less than 10 packet waiting in the queue, because there is always more packet processed pro second than arrive. utilization = arrival rate / serve rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packet in the system n = use / 1 - use giving = 9 packet we can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. because the use is equal in each meter, the probability that the system is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "In this case the system will be for the entire metro in a state, in which there are less than 10 packet waiting in the queue, becarole there is always more packet processed pro second than arriving. utilization = arrival rate / servicing rate = 9 pkts/s / 10 pkts/s = 0.9 n - average number of packet in the system n = role / 1 - role giving = 9 packet we can also calculate the probability, that the system is full: p_10 = (1-p)*p^10 / (1-p^11) we get 0.05 as a result. becarole the role is equal in each meter, the probability that the system is complete remains the same.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be litigated in 1 minute found on the assumption that the bundle arrive evenly distributed in the minute (i.e. 9 bundle per second) and we can litigate 10 bundle per second, this means that the scheme is occupied in 90% of the time with litigating the bundle. in 10% of the time the scheme has no bundle to litigate. since the scheme can litigate more bundle in a second than we hope to arrive in a second, the scheme will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be litigated in 1 minute ground on the assumption that the bundle arrive equally distributed in the minute (i.e. 9 bundle per second) and we can litigate 10 bundle per second, this means that the scheme is occupied in 90% of the time with litigating the bundle. in 10% of the time the scheme has no bundle to litigate. since the scheme can litigate more bundle in a second than we hope to arrive in a second, the scheme will be in a state with less than 10 bundle waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 parcel arrive in 1 minute 10 * 60 = 600 parcel can be litigated in 1 minute ground on the assumption that the parcel arrive evenly distributed in the minute (i.e. 9 parcel per second) and we can litigate 10 parcel per second, this means that the scheme is occupied in 90% of the time with litigating the parcel. in 10% of the time the scheme has no parcel to litigate. since the scheme can litigate more parcel in a second than we hope to arrive in a second, the scheme will be in a state with less than 10 parcel await in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 software arrive in 1 minute 10 * 60 = 600 software can be litigated in 1 minute based on the assumption that the software arrive equally distributed in the minute (i.e. 9 software per second) and we can litigate 10 software per second, this means that the scheme is occupied in 90% of the time with litigating the software. in 10% of the time the scheme has no software to litigate. since the scheme can litigate more software in a second than we hope to arrive in a second, the scheme will be in a state with less than 10 software waiting in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 bundle arrive in 1 minute 10 * 60 = 600 bundle can be litigated in 1 minute ground on the assumption that the bundle arrive evenly distributed in the minute (i.e. 9 bundle per second) and we can litigate 10 bundle per second, this means that the scheme is occupied in 90% of the time with litigating the bundle. in 10% of the time the scheme has no bundle to litigate. since the scheme can litigate more bundle in a second than we hope to arrive in a second, the scheme will be in a state with less than 10 bundle expect in the queue all the time.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Differential manchester encryption is the estimable alternative because of its good ego-clocking function which is authoritative in a congested network. it also provides mistake detection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs an comptroller - because if the recipient does not have a body to direct, the conductor will never get an ack for his directed bodies - so when he find a body, the recipient does not have a body to direct and the count is finished, the recipient directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs an controller - because if the recipient does not have a soundbox to direct, the director will never get an ack for his directed bodies - so when he have a soundbox, the recipient does not have a soundbox to direct and the count is finished, the recipient directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs an comptroller - because if the recipient does not have a eubstance to direct, the director will never get an ack for his directed bodies - so when he meet a eubstance, the recipient does not have a eubstance to direct and the count is finished, the recipient directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs an accountant - because if the receiver does not have a torso to direct, the manager will never get an ack for his directed bodies - so when he receives a torso, the receiver does not have a torso to direct and the count is finished, the receiver directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs an accountant - because if the receiver does not have a trunk to direct, the manager will never get an ack for his directed bodies - so when he receives a trunk, the receiver does not have a trunk to direct and the count is finished, the receiver directs an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be air in one direction, in order to send some data back with the ack. basically it is using the default surgery of manoeuvre the ack to also send some additional data back to the transmitter, instead of manoeuvre a new frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- the essentials for the elongation of the piggy admit the acknowledgment \"ack\". - contains the sequence-number ack(seq.no) and confirms the frame(seq.no). - here, the ack acknowledgment can be implicitly returned by the chassis.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on transportation stratum\n\ncite mechanic\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-way handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow ascendency on ecstasy stratum\n\nsummons mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-fashion handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on ecstasy stratum\n\ncite mechanic\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-style handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow control on shipping stratum\n\nadvert mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-way handshake protocol\n+\u00a0ds\n-\u00a0\n\nflow ascendence on shipping stratum\n\nabduce mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession function is 0 and the next succession function and the next ack-succession function to be waitress is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness act is 0 and the next successiveness act and the next ack-successiveness act to be waitress is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence bit is 0 and the next sequence bit and the next ack-sequence bit to be wait is yield",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness bit is 0 and the next successiveness bit and the next ack-successiveness bit to be wait is make",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession subroutine is 0 and the next succession subroutine and the next ack-succession subroutine to be wait is yield",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum necktie bed of one station must get a novel packet from the upper bed by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data tie bed of one post must get a raw bundle from the upper bed by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum standoff bed of one station must get a raw packet from the upper bed by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum crosstie bed of one station must get a young packet from the upper bed by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1532q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the datum crosstie bed of one station must get a new package from the upper bed by the death of the timeout interval",
        "answer_feedback": "the response is incorrect because even if it fails to get a packet from the upper layer, it can send the acknowledgment independently without piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the concernence added to the next framework has to concern to the framework received so that it can be assigned to the related datum. Otherwise it cannot be notice which framework is affirmed by its concernence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the advertence added to the next framework has to advert to the framework received so that it can be assigned to the related datum. Otherwise it cannot be identify which framework is affirmed by its advertence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the mentionence added to the next framework has to mention to the framework received so that it can be assigned to the related datum. Otherwise it cannot be discovered which framework is support by its mentionence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference tally to the next framework has to refer to the framework received so that it can be assigned to the related datum. Otherwise it cannot be divulge which framework is affirmed by its reference.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reference bestow to the next framework has to refer to the framework received so that it can be assigned to the related datum. Otherwise it cannot be discovered which framework is verify by its reference.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence number is 0 and the next sequence number and the next ack-sequence number to be expected is generate",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment turn is 0 and the next installment turn and the next ack-installment turn to be anticipate is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence numeral is 0 and the next sequence numeral and the next ack-sequence numeral to be expected is sacrifice",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment number is 0 and the next installment number and the next ack-installment number to be gestate is feed",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial installment routine is 0 and the next installment routine and the next ack-installment routine to be wait is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own cross tree but is do not need to know the cross tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own cross tree but is do not need to hump the cross tree each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own cross tree but is do not take to bash the cross trees each router has entropy which path it would use for (unicast)-packets because of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own cross tree but is do not need to hump the cross trees each router has entropy which path it would utilize for (unicast)-packets becautilize of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1043q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own cross tree but is do not need to whop the cross trees each router has entropy which path it would utilise for (unicast)-packets becautilise of the unicast routing algorithms",
        "answer_feedback": "the response is incomplete as it does not mention where the provided incomplete information is used in, rpf or rpb. the purpose of using them is also not mentioned.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a enumerationer - because if the recipient does not have a beam anatomy, the beamer will never enenumerationer an ack for its beam anatomys - so when you enenumerationer a anatomy, the recipient does not have a beam anatomy and the enumeration is finished, the receiving beam an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a enumerationer - because if the recipient does not have a beam frame, the beamer will never incur an ack for its beam frames - so when you incur a frame, the recipient does not have a beam frame and the enumeration is finished, the receiving beam an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a enumerationer - because if the recipient does not have a beam skeleton, the beamer will never have an ack for its beam skeletons - so when you have a skeleton, the recipient does not have a beam skeleton and the enumeration is finished, the receiving beam an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a numerationer - because if the recipient does not have a beam frame, the beamer will never ennumerationer an ack for its beam frames - so when you ennumerationer a frame, the recipient does not have a beam frame and the numeration is finished, the receiving beam an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a enumerationer - because if the recipient does not have a beam inning, the beamer will never invite an ack for its beam innings - so when you invite a inning, the recipient does not have a beam inning and the enumeration is finished, the receiving beam an ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge separately. ack or nak is impound to the next datum frame and then charge with datum together to the other side.\n\n-the datum contact bottom of one station must get a new packet from the upper bottom by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and charge together. otherwise, the datum contact bottom sends only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not beam separately. ack or nak is bond to the next datum frame and then beam with datum together to the other side.\n\n-the datum contact bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and beam together. otherwise, the datum contact bed beam only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge separately. ack or nak is tie to the next datum frame and then charge with datum together to the other side.\n\n-the datum contact bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and charge together. otherwise, the datum contact bed transmit only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not beam separately. ack or nak is tie to the next datum frame and then beam with datum together to the other side.\n\n-the datum contact bed of one station must get a new packet from the upper bed by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and beam together. otherwise, the datum contact bed direct only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge separately. ack or nak is attach to the next datum frame and then charge with datum together to the other side.\n\n-the datum contact seam of one station must get a new packet from the upper seam by the end of the timeout interval. then the ack or nak is piggybacked on the datum frame and charge together. otherwise, the datum contact seam sends only ack or nak frame.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "1. An inter-local agreement between agencies must be sign and filed with the county attender or published online; 2. the original contracting agency has complied with all essentials and puts the confluence online; and 3. the seller agrees with the agreement through the initial confluence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "1. An inter-local agreement between agencies must be signed and filed with the county hearer or published online; 2. the original contracting agency has follow with all essentials and puts the confluence online; and 3. the seller agrees with the agreement through the initial confluence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "1. An inter-local agreement between agencies must be signal and filed with the county hearer or published online; 2. the original contracting agency has complied with all essentials and assign the meeting online; and 3. the seller agrees with the agreement through the initial meeting.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "1. An inter-local agreement between agencies must be signed and filed with the county attender or published online; 2. the original contracting agency has complied with all essentials and redact the confluence online; and 3. the seller agrees with the agreement through the initial confluence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "1. An inter-local agreement between agencies must be signed and filed with the county hearer or published online; 2. the original contracting agency has complied with all essentials and place the confluence online; and 3. the seller agrees with the agreement through the initial confluence.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-mode handshake protocol + ds - menstruum control in transport level cite mechanical + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-way handshake protocol + ds - period control in raptus layer cite mechanical + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-path handshake protocol + ds - flow control in conveyance level cite mechanical + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-fashion handshake protocol + ds - flow control in conveyance class cite mechanical + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-fashion handshake protocol + ds - menstruum controller in transport stratum cite mechanical + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each frame from each connection side. the data table contains the entropy about the components that are connected to the network. which imply that the transparent space receives from the component a frame that has the entropy \"to be reached over lan l.\" in the promotion process, the transparent space floods the network with this entropy, so that other lapses also have the entropy about the component a. a welfare of the flood is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each soma from each connection side. the data table contains the entropy about the components that are connected to the network. which imply that the transparent space receives from the component a soma that has the entropy \"to be reached over lan l.\" in the furtherance process, the transparent space floods the network with this entropy, so that other lapses also have the entropy about the component a. a benefit of the flood is that it uses the shortest way of the network.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each frame from each connection side. the data table contains the entropy about the components that are connected to the mesh. which imply that the transparent space receives from the component a frame that has the entropy \"to be reached over lan l.\" in the promotion process, the transparent space floods the mesh with this entropy, so that other lapses also have the entropy about the component a. a benefit of the flood is that it uses the shortest way of the mesh.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each frame from each connection side. the data table contains the entropy about the components that are connected to the net. which imply that the transparent space receives from the component a frame that has the entropy \"to be reached over lan l.\" in the promotion process, the transparent space floods the net with this entropy, so that other lapses also have the entropy about the component a. a benefit of the flood is that it uses the shortest way of the net.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent space receives each frame from each connection side. the data table contains the entropy about the components that are connected to the web. which imply that the transparent space receives from the component a frame that has the entropy \"to be reached over lan l.\" in the promotion process, the transparent space floods the web with this entropy, so that other lapses also have the entropy about the component a. a benefit of the flood is that it uses the shortest way of the web.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a retort - because if the liquidator does not have skeleton for air, the aerator will never get an ack for its aerated skeleton - so when you receive a skeleton, the liquidator does not have skeleton for air and the counting is finished, the receiving air one ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- take a rejoinder - because if the receiver does not have skeleton for air, the aerator will never get an ack for its aerated skeleton - so when you receive a skeleton, the receiver does not have skeleton for air and the counting is end, the receiving air one ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a replication - because if the liquidator does not have skeleton for air, the aerator will never get an ack for its aerated skeleton - so when you receive a skeleton, the liquidator does not have skeleton for air and the counting is stop, the receiving air one ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- needs a sideboard - because if the liquidator does not have skeleton for air, the aerator will never get an ack for its aerated skeleton - so when you receive a skeleton, the liquidator does not have skeleton for air and the counting is stop, the receiving air one ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- take a comeback - because if the recipient does not have skeleton for air, the aerator will never get an ack for its aerated skeleton - so when you receive a skeleton, the recipient does not have skeleton for air and the counting is finished, the receiving air one ack",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0675q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead\u2192 duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1. flow mastery: see that a transmitter does not send faster than a receiver can receive\n2. framing: datum are packed in a inning, this inning contains e.g. the datum, destination address and source \n3. fault detection: important to ensure that all datum has been received correctly. if an fault is find, the receiver may be signalled to send the datum again",
        "answer_feedback": "the response answers no parts of the question correctly and is not related to the question.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the number must be used, since the protocol oriented to the charnumberer requires additional time due to the insertion of dles in the frame and convert to the good coding. moreover, the protocol oriented to the account leads to the desynchronisation in case of a transmission wrongdoing and therefore is not reliable enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the number must be used, since the protocol oriented to the charnumberer requires additional time due to the insertion of dles in the frame and convert to the good coding. moreover, the protocol oriented to the account conduce to the desynchronization in case of a transmission error and therefore is not honest enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the deed must be used, since the protocol oriented to the chardeeder requires additional time due to the insertion of dles in the frame and convert to the good coding. moreover, the protocol oriented to the account take to the desynchronization in case of a transmission error and therefore is not dependable enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the turn must be used, since the protocol oriented to the charturner requires additional time due to the insertion of dles in the frame and convert to the good coding. moreover, the protocol oriented to the account direct to the desynchronization in case of a transmission error and therefore is not honest enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the protocol oriented to the turn must be used, since the protocol oriented to the charturner requires additional time due to the insertion of dles in the frame and convert to the good coding. moreover, the protocol oriented to the account leads to the desynchronization in case of a transmission fault and therefore is not authentic enough for its daily use.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it tempt with gamy-power in order to form very performant with a gamy amount of datum.\nproblem is that it is not that well, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it shape with gamy-king in order to mold very performant with a gamy amount of data.\nproblem is that it is not that well, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it charm with gamy-force in ordering to work very performant with a gamy amount of data.\nproblem is that it is not that well, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it influence with gamy-exponent in order to run very performant with a gamy amount of datum.\nproblem is that it is not that well, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it tempt with gamy-magnate in order to work very performant with a gamy amount of datum.\nproblem is that it is not that well, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On middling, there are 9 bundles in the fenders per second. lambda = 9 t=1 p(less than 10 bundles in the fender) = p(0 bundle) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On modal, there are 9 packet in the fenders per second. lambda = 9 t=1 p(less than 10 packet in the fender) = p(0 mailboat) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On average, there are 9 softwares in the fenders per second. lambda = 9 t=1 p(less than 10 softwares in the fender) = p(0 mailboat) +...+ p(9) software = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On modal, there are 9 parcel in the fenders per second. lambda = 9 t=1 p(less than 10 parcel in the fender) = p(0 bundle) +...+ p(9) package = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "On modal, there are 9 bundles in the fenders per second. lambda = 9 t=1 p(less than 10 bundles in the fender) = p(0 parcel) +...+ p(9) bundle = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0.5874 0.5874 * 60s = 35s",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on signify, there are 9 packet in the buffer per second.\nlambda = 9\nt=1\n\np(less than 10 packet in the buffer) = p(0 packet) +...+ p(9 packet) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on imply, there are 9 mailboat in the pilot per second.\nlambda = 9\nt=1\n\np(less than 10 mailboat in the pilot) = p(0 mailboat) +...+ p(9 mailboat) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on signify, there are 9 parcel in the pilot per second.\nlambda = 9\nt=1\n\np(less than 10 parcel in the pilot) = p(0 parcel) +...+ p(9 parcel) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on mean, there are 9 package in the fender per second.\nlambda = 9\nt=1\n\np(less than 10 package in the fender) = p(0 package) +...+ p(9 package) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "on mean, there are 9 bundle in the fender per second.\nlambda = 9\nt=1\n\np(less than 10 bundle in the fender) = p(0 bundle) +...+ p(9 bundle) = sum(k=0 to 9)[ 9^k * exp(-9) / k!] = 0,5874\n\n0,5874 * 60s = 35s",
        "answer_feedback": "the obtained probability for less than 10 packets is incorrect, and so is the time. the idea behind the steps is correct, but the calculation is wrong.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection orientate -blame control -end to end flow control udp: -connectionless -no flow control -no blame control or retransmission -maybe used with broadcast/multicast and stream",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0832q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp: -connection point -fault control -end to end run control udp: -connectionless -no run control -no fault control or retransmission -maybe used with broadcast/multicast and stream",
        "answer_feedback": "the response states differences between tcp and udp while the question requirement is to identify differences between udp and tcp headers.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for the width/multicasting of the transverse tree for a given node is that it not only specifies the optimum path of the other knob to this node, but also the optimum routes from this node to the other knob. earth routing link can be used to construct multicast transverse trees by first running the link ground routing procedure to obtain the transverse tree for a given x node.This thwartwise-sectional tree could already be used as the multicast thwartwise tree for the x node, but it can be optimized by removing all edges that are not part of any route between two knob of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for the width/multicasting of the transverse tree for a given node is that it not only specifies the optimal path of the other knob to this node, but also the optimal routes from this node to the other knob. earth routing link can be used to construct multicast transverse trees by first running the link ground routing procedure to obtain the transverse tree for a given x node.This transverse-sectional tree could already be used as the multicast transverse tree for the x node, but it can be optimized by removing all edges that are not part of any route between two knob of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the pellucid span receives every frame of each connected side. the span board holds the information about which components are attached to the network. that entail the pellucid span receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the pellucid span floods the network with this information, so that other spans also have the information about component a. a welfare of flooding is that it uses the shortsighted path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the cobwebby duet receives every frame of each connected side. the duet table holds the information about which components are attached to the network. that entail the cobwebby duet receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the cobwebby duet floods the network with this information, so that other duets also have the information about component a. a welfare of flooding is that it uses the forgetful path in the network.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the pellucid span receives every frame of each connected side. the span table holds the information about which components are attached to the mesh. that entail the pellucid span receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the pellucid span floods the mesh with this information, so that other spans also have the information about component a. a welfare of flooding is that it uses the inadequate path in the mesh.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the transparent brace receives every frame of each connected side. the brace board holds the information about which components are attached to the meshwork. that entail the transparent brace receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the transparent brace floods the meshwork with this information, so that other braces also have the information about component a. a welfare of flooding is that it uses the shortest path in the meshwork.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0901q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry \u201cq can be reached over l\u201d to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the pellucid straddle receives every frame of each connected side. the straddle table holds the information about which components are attached to the meshwork. that entail the pellucid straddle receives from the component a a frame which has the information \"a can be reached over lan l.\" in the forwarding process, the pellucid straddle floods the meshwork with this information, so that other straddles also have the information about component a. a welfare of flooding is that it uses the shortest path in the meshwork.",
        "answer_feedback": "the bridge table does not contain component information. the response does not mention how the information \"a can be reached over lan l\" is used in backward learning and selective forwarding. the stated benefit is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in year a. except 0 and 127 are earmark for network and curriculum",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all reference in year a. except 0 and 127 are earmark for network and syllabus",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in year a. except 0 and 127 are reserved for net and program",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all address in year a. except 0 and 127 are reserve for mesh and broadcast",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1665q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "from 0.0.0.0\u00a0 to 127.0.0.0 are all speech in year a. except 0 and 127 are reserved for web and plan",
        "answer_feedback": "network is x.0.0.0 and broadcast is x.255.255.255, with x between 0 and 127\nmissing: loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skim 1c, a, frontwards) (d, a, frontwards) (b, a, frontwards) (e, b, frontwards) (g, e, frontwards) (h,g, frontwards) (f,c,c,frontwards) (c,b,cliff) c is not on the unicast track of b a (c,d,cliff) c is not on the unicast track of d a (c,e, cliff) c is not on the unicast track of e a (d,f, cliff) d is not on the unicast track of f a (f,g, cliff) f is not on the unicast track of g to a jump 2e, a, frontwards) (f, a, frontwards) skim 3g, a, frontwards) skim 4h, a, frontwards)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "skim 1c, a, frontwards) (d, a, frontwards) (b, a, frontwards) (e, b, frontwards) (g, e, frontwards) (h,g, frontwards) (f,c,c,frontwards) (c,b,dip) c is not on the unicast itinerary of b a (c,d,dip) c is not on the unicast itinerary of d a (c,e, dip) c is not on the unicast itinerary of e a (d,f, dip) d is not on the unicast itinerary of f a (f,g, dip) f is not on the unicast itinerary of g to a jump 2e, a, frontwards) (f, a, frontwards) skim 3g, a, frontwards) skim 4h, a, frontwards)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "vamoose 1c, a, frontwards) (d, a, frontwards) (b, a, frontwards) (e, b, frontwards) (g, e, frontwards) (h,g, frontwards) (f,c,c,frontwards) (c,b,drib) c is not on the unicast way of b a (c,d,drib) c is not on the unicast way of d a (c,e, drib) c is not on the unicast way of e a (d,f, drib) d is not on the unicast way of f a (f,g, drib) f is not on the unicast way of g to a jump 2e, a, frontwards) (f, a, frontwards) vamoose 3g, a, frontwards) vamoose 4h, a, frontwards)",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson process is based on probabilities based on randomly arriving bundles, based on t indepedent.\nevery interval is independent to the former intervals, so comer are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, streaming clients which have different and randomly bundle comer which can be modelled as poisson process.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson bidding is based on probabilities based on randomly arriving packets, based on t indepedent.\nevery interval is independent to the premature intervals, so arriver are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, streaming clients which have different and randomly packet arriver which can be modelled as poisson bidding.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson process is based on probabilities based on randomly arriving packets, based on t indepedent.\nevery interval is independent to the late intervals, so arrival are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, streaming clients which have different and randomly packet arrival which can be modelled as poisson process.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson process is based on probabilities based on randomly arriving packets, based on t indepedent.\nevery interval is independent to the previous intervals, so arrival are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, streaming customer which have different and randomly packet arrival which can be modelled as poisson process.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0860q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval \u03b4t are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "the poisson process is based on probabilities based on randomly arriving packets, based on t indepedent.\nevery interval is independent to the former intervals, so arriver are memoryless.\nthe same situation is for the cyberspace. here we have server/client application, webserver, streaming clients which have different and randomly packet arriver which can be modelled as poisson process.",
        "answer_feedback": "the correct answer is \"no\". the packets in streaming are not random but depend on the previous arrivals at a node.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the answer frames have to be able to brake the data + ack and not just ack or just data. this way the ack can be delay and sent along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reception frames have to be able to brake the datum + ack and not just ack or just datum. this way the ack can be delayed and sent along with the datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the response framings have to be able to brake the datum + ack and not just ack or just datum. this way the ack can be delayed and sent along with the datum in a framing.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reception frames have to be able to brake the data + ack and not just ack or just data. this way the ack can be retard and sent along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the reception forms have to be able to brake the data + ack and not just ack or just data. this room the ack can be stay and sent along with the data in a form.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the font, because the arrival pace (9) is lower than the service pace (10). so in the median the polisher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the font, because the arrival pace (9) is lower than the service pace (10). so in the median the cowcatcher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the font, because the arrival pace (9) is downhearted than the service pace (10). so in the median the polisher is always below its maximum capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the font, because the arrival pace (9) is lower than the service pace (10). so in the median the cowcatcher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "this is always the font, because the arrival pace (9) is lower than the service pace (10). so in the median the fender is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data class of a station must hold a new package from the upper class by the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data class of a station must obtain a fresh package from the upper class by the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data class of a station must obtain a new package from the upper class by the end of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data layer of a station must obtain a fresh package from the upper layer by the death of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the data class of a station must obtain a new package from the upper class by the last of the waiting time separation",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "closure frames have to be able to delight datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with the datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "answer frames have to be capable to enchant data + ack and not just ack or just data. in this way the ack can be delayed and sent along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "firmness frames have to be capable to delight data + ack and not just ack or just data. in this way the ack can be delayed and sent along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent frames have to be able to transport datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with the datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solution frames have to be capable to transport datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with the datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window sizing of 1, the sequence must always be right.\nif the window sizing is nifty than 1, there are no requirements, but the sizing is circumscribe by the window sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window sizing of 1, the sequence must always be right.\nif the window sizing is bully than 1, there are no prerequisite, but the sizing is limited by the window sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window sizing of 1, the sequence must always be right.\nif the window sizing is neat than 1, there are no requirement, but the sizing is limited by the window sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window size of 1, the sequence must always be right.\nif the window size is greater than 1, there are no requirements, but the size is determine by the window size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window size of 1, the sequence must always be right.\nif the window size is greater than 1, there are no requisite, but the size is limited by the window size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem, the data reserve is not wagered on the emplacement, some have more building than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "equity is the job, the data reserve is not wagered on the billet, some have more structure than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the trouble, the data reserve is not wagered on the spot, some have more construction than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "equity is the job, the data reserve is not bet on the positioning, some have more construction than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the trouble, the data reserve is not wagered on the position, some have more expression than others",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the housing, because the pace of arrival (9) is lower than the pace of service (10). so in mediocre the polisher is always below its maximum capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the housing, because the pace of arrival (9) is lower than the pace of service (10). so in mediocre the buff is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the housing, because the pace of arrival (9) is lower than the pace of service (10). so in mediocre the pilot is always below its maximum capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the housing, because the rate of reaching (9) is lower than the rate of service (10). so in mediocre the cowcatcher is always below its maximal capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "This is always the housing, because the pace of arriver (9) is lower than the pace of service (10). so in mediocre the cowcatcher is always below its maximum capacity of 10.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the essential are listed below\n1. an interlocal concord between office must be sign and filed with the county auditor or posted online;\n2. the original contracting agency has complied with all essential and posts the collection online; and\n3. the vendor agrees to the arrangement through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the requirements are listed below\n1. an interlocal concord between means must be consecrate and filed with the county auditor or posted online;\n2. the original contracting agency has complied with all requirements and brand the collection online; and\n3. the vendor agrees to the arrangement through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the demand are listed below\n1. an interlocal concord between way must be consecrate and filed with the county auditor or posted online;\n2. the original contracting agency has complied with all demand and posts the collection online; and\n3. the vendor agrees to the arrangement through the initial collection.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession bend is 0 and the next succession bend and the next ack-succession bend to be calculate is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness bout is 0 and the next successiveness bout and the next ack-successiveness bout to be look is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession bout is 0 and the next succession bout and the next ack-succession bout to be calculate is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession bout is 0 and the next succession bout and the next ack-succession bout to be reckon is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1524q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence twist is 0 and the next sequence twist and the next ack-sequence twist to be bet is given",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. the stated points are not always true and depend on the implementation.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no indigence to have specific parentage to transmit the synchronisation signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local mesh with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no indigence to have specific stock to transmit the synchronisation signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local mesh with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no indigence to have specific line to transmit the synchronisation signaling.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local mesh with 3 exploiter.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no indigence to have specific lineage to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local mesh with 3 exploiter.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0137q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "manchester encoding.\n1. because of the self-clocking there is no indigence to have specific seam to transmit the synchronisation signal.\n2. manchester encoding is less complex than differential manchester encoding, and convenient enough for local mesh with 3 users.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0246q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "9 * 60 = 540 package arrive in 1 minute\n10 * 60 = 600 package can be process in 1 minute\n\nbased on the assumption that the package arrive uniformly distributed in the minute (i.e. 9 package per second) and we can litigate 10 package per second, this means that the dodge is busy in 90 % of the sentence with litigateing the package. in 10 % of the sentence the dodge has no package to litigate. \nsince the dodge can litigate more package in a second than we expect to arrive in a second, the dodge will be in a state with less than 10 package waiting in the queue for the whole sentence.",
        "answer_feedback": "the description to justify the system waiting time is missing in the response. additionally, the system does not stay in a less than 10 packets state for a whole minute, only 56.95 seconds.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the acknowledgement supply to the next skeleton has to appertain to the received skeleton so that it can be assigned to the related data. otherwise you cannot identify which skeleton is confirmed by your acknowledgement.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the acknowledgement supply to the next anatomy has to touch to the received anatomy so that it can be assigned to the related data. otherwise you cannot identify which anatomy is confirmed by your acknowledgement.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the acknowledgement supply to the next physique has to touch to the received physique so that it can be assigned to the related data. otherwise you cannot identify which physique is confirmed by your acknowledgement.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the acknowledgment supply to the next chassis has to pertain to the received chassis so that it can be assigned to the related data. otherwise you cannot identify which chassis is confirmed by your acknowledgment.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the acknowledgment supply to the next figure has to relate to the received figure so that it can be assigned to the related data. otherwise you cannot identify which figure is confirmed by your acknowledgment.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it release with high-power in order to cultivate very performant with a high amount of data.\njob is that it is not that proficient, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it twist with eminent-power in order to work very performant with a eminent amount of data.\njob is that it is not that good, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it bend with gamy-power in order to work very performant with a gamy amount of data.\njob is that it is not that expert, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it turn with high-power in order to lick very performant with a high amount of datum.\njob is that it is not that expert, when there is less datum.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0732q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "it turn with gamey-power in order to exercise very performant with a gamey amount of data.\njob is that it is not that good, when there is less data.",
        "answer_feedback": "the response is incorrect. there is a fairness issue with the distribution of transmission rights between stations that depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0102q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encryption is the best option because of its honest self-clocking feature which is important in a binge net. it also offer error detection.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 softwares, as more softwares are to make the software number in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are to make the packet come in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 packet, as more packet are to make the package derive in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcels, as more parcels are to make the parcel come in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are to make the parcel follow in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a utile property for broad-/multicasting of the hybrid tree for a certain node is that it does not only specify the optimal path from the other nodes to this node, but also the optimal itinerary from this node to the other nodes. link country routing can be used to construct multicast hybrid tree by first running the link country routing procedure to get the hybrid tree for a certain node x. this hybrid tree could already be used as the multicast hybrid tree for node x, but it can be optimized by removing all edges that are not part of any path between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the hybridizing tree for a certain node is that it does not only specify the optimum path from the other nodes to this node, but also the optimum itinerary from this node to the other nodes. link country routing can be used to construct multicast hybridizing tree by first running the link country routing procedure to get the hybridizing tree for a certain node x. this hybridizing tree could already be used as the multicast hybridizing tree for node x, but it can be optimized by removing all edges that are not part of any path between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1089q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for broad-/multicasting of the hybridizing tree for a certain node is that it does not only specify the optimum path from the other nodes to this node, but also the optimum itinerary from this node to the other nodes. link country routing can be used to construct multicast hybridizing tree by first running the link country routing procedure to get the hybridizing tree for a certain node x. this hybridizing tree could already be used as the multicast hybridizing tree for node x, but it can be optimized by removing all edges that are not part of any path between any two nodes of the multicast group.",
        "answer_feedback": "what makes spanning trees desirable for multicast and broadcast is the absence of loops and, thus, minimizing unnecessary duplicates.  the response is missing how the multicast group information is distributed to all nodes. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0096q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the fleck oriented protocol should be used, as the character oriented protocol requires improveral time due to the insertion of dles into the frame and convert to the veracious encoding. in improver, the reckoning oriented protocol leads to desynchronisation in the event of a transmission error and is therefore not reliable enough for everyday use.",
        "answer_feedback": "the provided response is not related to the theme of the question which is encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference of the a. folk except 0 and 127 are reserved for the meshwork and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference of the a. sept except 0 and 127 are reserved for the meshwork and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all addresses of the a. family except 0 and 127 are earmark for the meshwork and programme",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference of the a. house except 0 and 127 are reserved for the mesh and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all address of the a. kin except 0 and 127 are reserved for the net and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a utile property for the multicasting/widening of the tree of spaces for a given knob is that it not only specifies the optimum path of the other knobs to this knob, but also the optimum routes of this knob to the other knobs.The routing per link province can be used to construct multicast space trees by first running the routing procedure per link province to obtain the tree of spaces for a given x knob.This tree of spaces could already be used as the multicast space tree for the x knob, but it can be optimized by removing all edges that are not part of any route between two knobs of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for the multicasting/widening of the tree of spaces for a given knob is that it not only specifies the optimum path of the other knobs to this knob, but also the optimum routes of this knob to the other knobs.The routing per link province can be used to construct multicast space trees by first running the routing procedure per link province to obtain the tree of spaces for a given x knob.This tree of spaces could already be used as the multicast space tree for the x knob, but it can be optimized by removing all edges that are not part of any route between two knobs of the multicast radical.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a utilitarian property for the multicasting/widening of the tree of spaces for a given guest is that it not only specifies the optimal path of the other guests to this guest, but also the optimal routes of this guest to the other guests.The routing per link province can be used to construct multicast space trees by first running the routing procedure per link province to obtain the tree of spaces for a given x guest.This tree of spaces could already be used as the multicast space tree for the x guest, but it can be optimized by removing all edges that are not part of any route between two guests of the multicast grouping.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a useful property for the multicasting/widening of the tree of spaces for a hold thickening is that it not only specifies the optimum path of the other thickenings to this thickening, but also the optimum routes of this thickening to the other thickenings.The routing per link province can be used to construct multicast space trees by first running the routing procedure per link province to obtain the tree of spaces for a hold x thickening.This tree of spaces could already be used as the multicast space tree for the x thickening, but it can be optimized by removing all edges that are not part of any route between two thickenings of the multicast group.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own extension tree, but it is not necessary to cognise the extension trees each router has entropy that route would use for (unicast)-packages due to unequalled routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own extension tree, but it is not necessary to know the extension tree each router has entropy that route would use for (unicast)-packages due to unequaled routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own extension tree, but it is not necessary to know the extension tree each router has entropy that route would use for (unicast)-packages due to unique routing algorithm",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each sender has its own extension tree, but it is not necessary to live the extension tree each router has entropy that route would use for (unicast)-packages due to unique routing algorithms",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "each vector has its own extension tree, but it is not necessary to screw the extension trees each router has entropy that route would use for (unicast)-packages due to unique routing algorithm",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence turn is 0 and the next sequence turn is given and the next sequence turn is look",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial sequence act is 0 and the next sequence act is given and the next sequence act is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness figure is 0 and the next successiveness figure is given and the next successiveness figure is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial succession act is 0 and the next succession act is given and the next succession act is look",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial successiveness routine is 0 and the next successiveness routine is given and the next successiveness routine is expected",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this meshing I advise using differential manchester eninscribe: this inscribe technique is robust in clock recovery and therefore offers adroitness synchronization in the receiver because a transition is guaranteed at least once each bite. In addition, it is less prone to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this mesh I suggest using differential manchester eninscribe: this inscribe technique is robust in clock recovery and therefore offers adroitness synchronization in the receiver because a transition is guaranteed at least once each bite. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this network I intimate using differential manchester enrazz: this razz technique is robust in clock recovery and therefore offers adroitness synchronization in the receiver because a transition is guaranteed at least once each bite. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this meshing I hint using differential manchester encoding: this coding technique is robust in clock recovery and therefore offers adroitness synchronization in the receiver because a transition is guaranteed at least once each bite. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "For this meshing I indicate using differential manchester encoding: this coding technique is robust in clock recovery and therefore offers adroitness synchronization in the receiver because a transition is guaranteed at least once each bite. In addition, it is less prostrate to errors in noisy environments.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "id": "smp1507q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the demand are listed below\n1. an interlocal accord between agencies must be signalize and filed with the county auditor or posted online;\n2. the original contracting agency has complied with all demand and posts the ingathering online; and\n3. the marketer check to the arrangement through the initial ingathering.",
        "answer_feedback": "the response answers no parts of the question correctly and it is not related to the topic.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1497q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "framing may check implicit acks",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. implicit acknowledgment is a result of piggybacking rather than a prerequisite.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1497q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "framing may check implicit acks",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. implicit acknowledgment is a result of piggybacking rather than a prerequisite.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1497q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "framing may soften implicit acks",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. implicit acknowledgment is a result of piggybacking rather than a prerequisite.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1497q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "underframe may check implicit acks",
        "answer_feedback": "the response does not identify the underlying requirement of duplex operation. implicit acknowledgment is a result of piggybacking rather than a prerequisite.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent bod have to be capable to contain data + ack and not just ack or just data. in this way the ack can be check and sent along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent anatomy have to be capable to contain data + ack and not just ack or just data. in this way the ack can be detain and sent along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent soma have to be capable to contain data + ack and not just ack or just data. in this way the ack can be delayed and mail along with the data in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent frame have to be able to contain datum + ack and not just ack or just datum. in this way the ack can be delayed and ship along with the datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "solvent form have to be capable to contain datum + ack and not just ack or just datum. in this way the ack can be delayed and sent along with the datum in a frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handclasp protocol\n+\u00a0ds\n-\u00a0\n\nmenstruum controller on ecstasy layer\n\nreference mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-agency handclasp protocol\n+\u00a0ds\n-\u00a0\n\nmenstruum ascendancy on rapture layer\n\nreference mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-means handshake protocol\n+\u00a0ds\n-\u00a0\n\nmenstruum ascendancy on conveyance layer\n\nreference mechanism\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-way shake protocol\n+\u00a0ds\n-\u00a0\n\nmenstruum control on transport layer\n\nreference mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0438q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "three-delegacy shake protocol\n+\u00a0ds\n-\u00a0\n\nmenstruum control on transport layer\n\nreference mechanics\n+\u00a0\n-\nmultiplexing / demultiplexing\n+\n-",
        "answer_feedback": "the response is incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no frame to shaft, the shafter will never get an ack for his shafted flesh\n- so when a frame is received, the receiver have no frame to shaft and the count is ended, the receiver shaft a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a tabulator \n- because if receiver have no frame to shaft, the shafter will never get an ack for his shafted flesh\n- so when a frame is received, the receiver have no frame to shaft and the count is ended, the receiver shaft a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a tabulator \n- because if receiver have no underframe to beam, the beamer will never get an ack for his beamed flesh\n- so when a underframe is received, the receiver have no underframe to beam and the count is ended, the receiver beam a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a replication \n- because if receiver have no underframe to beam, the beamer will never get an ack for his beamed flesh\n- so when a underframe is received, the receiver have no underframe to beam and the count is ended, the receiver beam a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1527q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "- need a counter \n- because if receiver have no frame to ray, the rayer will never get an ack for his rayed flesh\n- so when a frame is received, the receiver have no frame to ray and the count is ended, the receiver ray a ack",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the stated-point is more of an optimizing technique rather than a requirement.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - current ascendence in transport layer quote machinist + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - flow ascendancy in ecstasy layer quote mechanic + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three agencies + ds - catamenia ascendence in transportation layer quote mechanics + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three office + ds - current control in transport layer quote mechanism + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via\u3000a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "handshake protocol of three bureau + ds - flow ascendancy in transport layer quote machinist + - multiplexing / demultiplexing + -",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.5
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not air separately. ack or nak is attached to the next datum trope and then air with datum together to the other side.\n\n-the datum link layer of one station must get a new packet from the upper layer by the end of the timeout interval. then the ack or nak is piggybacked on the datum trope and air together. otherwise, the datum link layer sends only ack or nak trope.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not charge separately. ack or nak is attached to the next datum form and then charge with datum together to the other side.\n\n-the datum link bottom of one station must get a new packet from the upper bottom by the end of the timeout interval. then the ack or nak is piggybacked on the datum form and charge together. otherwise, the datum link bottom sends only ack or nak form.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1537q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-acks or naks and datum are not broadcast separately. ack or nak is attached to the next datum physique and then broadcast with datum together to the other side.\n\n-the datum link seam of one station must get a new packet from the upper seam by the end of the timeout interval. then the ack or nak is piggybacked on the datum physique and broadcast together. otherwise, the datum link seam sends only ack or nak physique.",
        "answer_feedback": "the response answers no parts of the question correctly. the response contains only the description of what happens in piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the relateence added to the next underframe has to relate to the received underframe so that it can be assigned to the related data. otherwise you cannot discover which underframe is affirm by your relateence.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the denotation added to the next frame has to name to the received frame so that it can be ascribe to the related data. otherwise you cannot discover which frame is affirm by your denotation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the denotation added to the next form has to refer to the received form so that it can be assigned to the related data. otherwise you cannot discover which form is affirm by your denotation.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the mention added to the next shape has to consult to the received shape so that it can be assigned to the related data. otherwise you cannot discover which shape is affirm by your mention.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1484q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the mentionence added to the next figure has to mention to the received figure so that it can be assigned to the related data. otherwise you cannot discover which figure is affirm by your mentionence.",
        "answer_feedback": "the response does not identify the duplex connection as the requirement. acknowledgments, whether sent independently or piggybacked, specify which frame is acknowledged, so it is not a  specific requirement for piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one approach, to be able to ship some datum back with the ack. basically it is using the default operation of shiping the ack to also ship some additional datum back to the transmitter, alternatively of shiping a new frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one approach, to be able to post some datum back with the ack. basically it is using the default operation of posting the ack to also post some additional datum back to the transmitter, instead of posting a raw frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "something needs to be sent in one approach, to be able to ship some datum back with the ack. fundamentally it is using the default operation of shiping the ack to also ship some additional datum back to the transmitter, instead of shiping a new frame.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to ship the datum as a bundle and does not have to ship a single bundle for each receiver, it is also not required to know all the receivers as the tree will manage the infection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to charge the datum as a package and does not have to charge a single package for each recipient, it is also not required to know all the recipients as the tree will handle the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to send the datum as a packet and does not have to send a single packet for each receiver, it is also not required to know all the receivers as the tree will wangle the infection.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to send the datum as a parcel and does not have to send a single parcel for each liquidator, it is also not required to know all the liquidators as the tree will manage the transmittal.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn\u2019t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the fact that it is only required to send the datum as a software and does not have to send a single software for each liquidator, it is also not required to know all the liquidators as the tree will supervise the transmission.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. aim:  help prevent ip address burlesque. 2. rpf a shiper broadcasts to all the place. when a mailboat reaches a is ,the is will check the course. if it is the usually course. it will ship to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. use:  facilitate prevent ip address burlesque. 2. rpf a sender programme to all the stations. when a mailboat reaches a is ,the is will check the course. if it is the usually course. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. determination:  avail prevent ip address burlesque. 2. rpf a chargeer broadcasts to all the stations. when a mailboat reaches a is ,the is will check the course. if it is the usually course. it will charge to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. function:  help prevent ip address burlesque. 2. rpf a beamer broadcasts to all the station. when a mailboat reaches a is ,the is will check the course. if it is the usually course. it will beam to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. aim:  avail prevent ip address burlesque. 2. rpf a sender broadcasts to all the post. when a mailboat reaches a is ,the is will check the course. if it is the usually course. it will send to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific blood to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific pedigree to transmit the synchronization sign. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific stemma to transmit the synchronization sign. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific line to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 user.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-clocking there is no need to have specific pedigree to transmit the synchronization sign. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local network with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all addresses in year a. except 0 and 127 are book for meshwork and plan",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all addresses in year a. except 0 and 127 are appropriate for meshing and platform",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all speech in year a. except 0 and 127 are reserved for web and curriculum",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all reference in year a. except 0 and 127 are earmark for network and plan",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "From 0.0.0.0 to 127.0.0 are all speech in year a. except 0 and 127 are earmark for net and program",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 0.5
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 packet, as more packet are serve than the package get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcel, as more parcel are service than the parcel get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 bundle, as more bundle are service than the software get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcel, as more parcel are overhaul than the package get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called \u201cblocking probability\u201d or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, \u2026, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "For every second, there will be less than 10 parcel, as more parcel are help than the packet get in the queue.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 1.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. intention:  avail prevent ip address burlesque. 2. rpf a beamer broadcasts to all the stations. when a packet touch a is ,the is will check the track. if it is the usually track. it will beam to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1032q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n \u2192 the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "1. intention:  serve prevent ip address burlesque. 2. rpf a chargeer broadcasts to all the stations. when a packet contact a is ,the is will check the track. if it is the usually track. it will charge to others",
        "answer_feedback": "the stated purpose is correct but not the main purpose which is to reduce duplicates when broadcasting. the explanation of rpf is incomplete, as it is not clear what is meant by the usual path or how the packet is forwarded.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe data reticence is not compute on the placement, some have more form than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "beauteousness is the problem\uff0cthe data reticence is not reckon on the locating, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "fairness is the problem\uff0cthe datum reticence is not account on the locating, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "equity is the problem\uff0cthe datum reticence is not calculate on the positioning, some have more form than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0741q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "comeliness is the problem\uff0cthe datum reticence is not cipher on the positioning, some have more frames than others",
        "answer_feedback": "the response identifies the fairness problem in dqdb. however, it states that it is not dependent on the location and that is incorrect. the fairness problem of reserving transmission rights depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window size of 1, the sequence must always be right.\nif the window size is greater than 1, there are no demand, but the size is limited by the window size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window sizing of 1, the sequence must always be right.\nif the window sizing is outstanding than 1, there are no essential, but the sizing is limited by the window sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane size of 1, the sequence must always be right.\nif the windowpane size is corking than 1, there are no requirement, but the size is limited by the windowpane size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a windowpane size of 1, the sequence must always be veracious.\nif the windowpane size is greater than 1, there are no demand, but the size is limited by the windowpane size.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp1535q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "with a window sizing of 1, the sequence must always be veracious.\nif the window sizing is greater than 1, there are no necessary, but the sizing is limited by the window sizing.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the above points are true for the sliding window protocol in general and are not specific to piggybacking.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to car-chronization there is no demand to have a specific line to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to machine-chronization there is no demand to have a specific line to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no demand to have a specific line to transmit the synchronization signaling. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 user.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to automobile-chronization there is no demand to have a specific channel to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 users.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    },
    {
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link\u2019s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "Manchester encoding. 1. Due to auto-chronization there is no demand to have a specific seam to transmit the synchronization signal. 2. Manchester encoding is less complex than differential manchester encoding, and sufficiently convenient for the local mesh with 3 exploiter.",
        "verification_feedback": "incorrect",
        "score": 0,
        "max_score": 2.5
    }
]
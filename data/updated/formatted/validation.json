[
    {
        "id": "smp0209q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption is not realistic for real internet traffic. it is different between day and night. for example in video traffic, a window buffer may be on to fetch the next segments of video, then off to deplete it, and then on again to fetch the next further segments of video.",
        "answer_feedback": "one can use a function instead of a constant to model the arrival rate to reflect such large-scale, day-night behavioral patterns. the arrivals would not depend on previous arrivals then, only on the time of the day, which is known. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0028q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "because it is given that all users have pefect clocks, we can use a simple and cheap binary encoding technique. it will also be a very efficient use of the given bandwidth.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0310q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "with csma/cd, if the speed of the network increases by a factor of 10, the collision domain diameter shrinks. the distance decreases by a factor of 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0051q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encoding should be used, since all users have perfect code and all frequency modulation is utilized (users have access to selected frequencies at all times)",
        "answer_feedback": "the response is incorrect as under the given scenario binary encoding is better suited.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0205q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "there are the differences between tcp and udp headers:\n1. tcp has a at least 20 bytes variable length header while udp has an 8 bytes fixed length header.\n2. tcp provides extensive error checking mechanisms since it uses checksum but also provides flow control and acknowledgement of data while udp has only basic error checking mechanisms using checksum. in tcp, erroneous packets are retransmitted from the source to the destination.\n3. tcp header contains the sequence number of data but udp does not contain the sequence number. there is no sequencing of data in udp.\n4. tcp header has urgent pointer to show receiver where urgent data ends but udp does not have this urgent pointer.\n5. tcp contains information for not only compulsory but also optional functions while udp has only the information for compulsory function.\n6. udp is comparatively faster, simpler and more efficient than tcp. however, tcp is reliable since it guarantees delivery of data to the destination.\n7. tcp is heavy-weight, since tcp requires three packets to set up a socket connection, before any user data can be sent. tcp handles reliability and congestion control. however, udp is lightweight. there is no ordering of messages, no tracking connections, etc.\n8. udp is connectionless, but tcp is connection-oriented. therefore, tcp header has fields used for connection setup and maintenance, specifically the flags. udp does not.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers. the response contains extra points, but they are general differences between the tcp and udp protocol.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0081q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a,b,forward)\n(a,c,forward)\n(a,d,drop)<=d doesn't foward a message from a to f, because f doesn't receive unicast packets via d.\nhop 2:\n(b,e,forward)\n(c,f,drop)<=f doesn't foward a message from a to g, because g doesn't receive unicast packets via f.\nhop 3:\n(e,g,forward)\nhop 4:\n(g,h,drop)<=vertex h has only one neighbor from which it got the message, vertex h does not forward the message.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0231q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table of transparent bridges holds the frame with address on every connected lan and the frame arrival timestamp, including sender and receiver.\nduring the backwards learning phase because of learning in the promiscuous mode the bridge can know any frame from any connected lan and can trace back to the source address on the lan of the received frame to create a table entry in the bridge table. in the forwarding process if the source and destination lans are identical, the frame will be dropped, otherwise(if they are different), the frame will be forwarded. if the destination lan is unknown, the frame will be flooded. \nthe benefit is forwarding frames without considering types of lans and without changing the configuration tables to achieve transparency.",
        "answer_feedback": "the bridge table does not contain both sender and receiver information; it only maps the destination station to the incoming lan. the stated benefit is not correct as the response mentions the benefit of transparent bridges in general, not of using transparent bridge table information in forwarding. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0368q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the communication needs to be duplex.\nadditionally, there should be a time period, within this time period, data link layer should wait for the next packet, and attach the acknowledgement to the outgoing data frame and then send the frame.\nwhen time expires and there is no packet to be sent, link layer sends a separate acknowledgement frame.",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0132q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases are \"slow start\" and \"congestion avoidance\". in phase 1 cwnd less than  ss_thresh. the congestion window increases exponentially until cwnd >= ss_thresh (so cwnd=1, then 2, then 4 etc.). after the threshold is reached, phase 2 is entered where we have an additive increase and a multiplicative decrease. this means, that the cogestion window now is always increased by 1 every roundtrip time and when a timeout (=congestion) occurs, the ss_thresh is set to 50% of the current size of the congestion window (ss_thresh=cwnd/2), the congestion window is reset to 1 and the slow start (phase 1) is entered again.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0345q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "- asynchronous: start and stop bit between every byte (bad transmission rate, but easy to realize)\n\n- synchronous: use of flags/syn for start and end of data frames containing multiple bytes (higher transmission rate, but more complex)",
        "answer_feedback": "the response explains the differences between asynchronous and synchronous transmission correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0179q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service:\nin this service, the data that is sent by the sender is expected to arrive at the receiver, however, there is no feedback from the receiver's side. due to a lack of acknowledgement from the receiver side, there exists a possibility of data units getting lost. furthermore, in this service there is no flow control taking place and neither is there a possibility of connect/disconnect. this form of service is best suited for l1 communication channels with a very low error rate.\n\nconfirmed connectionless service:\nthis service is a form of bi-directional communication, where upon sending information the receiver responds with an acknowledgment of whether the information has been received or not. it is particularly used in applications where a high error rate is expected, such as for moving devices. similar to the unconfirmed connectionless service, no flow control or a connect/disconnect phase takes place. due to the additional acknowledgement here, no data loss is possible, however, duplication and sequencing errors are still possible\n\nconnection-oriented service:\nas opposed to the connectionless services, the connection-oriented service operates with flow control, achieved by a 3-phase bi-directional communication (connect, transfer, disconnect). this prevents data loss, duplication of data or sequencing errors. this form of service requires some sort of connection management as both the sides agree to perform the communication.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0332q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "two solutions to the problem mentioned before are carrier extension and frame bursting. the basic principle in carrier extension is to attach a new extension field containing “scrap” data to the frame just to make it larger so that collisions can be detected. in frame bursting you take a similar approach, but instead of appending otherwise useless data, you just send a concatenated sequence of multiple frames in a single transmission. this is much more efficient than the carrier extension as no bandwidth is wasted on “scrap” data but the drawback is that the end-to-end delay for a frame is increased since you generally have to wait until you have the specified number of frames to send as a sequence which is bad for interactive services.",
        "answer_feedback": "the response correctly answers the definition of frame bursting, its advantage and disadvantage.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0376q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "frames may contain an implicit acks.\nduplex operation. \nit has to have an initial seqno. of 0",
        "answer_feedback": "apart from the correct answer of duplex operation, the response also contains other requirements. the first point is true, but it refers to what happens in piggybacking in general. the last point is incorrect as it is specific to the example given in the slides.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0002q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "csma/cd saves time and bandwidth. furthermore csma/cd is used for ethernet so it is really compatible to a lot of products. the usage of csma/cd with p-persistent csma would be nearly perfect, so the channel usage would be very high. a problem could be the maximum distance to a station.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0160q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "least probable to most probable \nb -> c -> a \n\nb: 0.6^3*0.4^3 = 0.013824\nc: (6 ncr 3) * (0.6^3*0.4^3) = 0.27648\na: p(x>=3)= (6 ncr 3) * (0.6^3*0.4^3)+ (6 ncr 4) (0.6^4*0.4^2)+ (6 ncr 5) * (0.6^5*0.4^1)+(0.6^6*0.4^0) = 0.8208",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0110q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "one method to resolve the problem of duplicate packets is to use temporarily valid tsaps for only one connection. on paper, this reduces the problem of duplicates since each tsap is only used once and therefore reduces the number of duplicates to the ones occuring in that one connection. however, a disadvantage is that some tsaps always exist and are well-known. hence, it is not possible to realize this approach and generate temporary tsaps for each connection. \n\nanother method would be to make connections unique and identify them individually. an advantage is that duplicates from different connections do not occur anymore since each is unique. however, this is not possible with connection-less systems. additional knowledge is needed to realize this approach since end systems need to remember the sequence numbers even after being turned off so that they remain unique for each connection. \n\nthe third approach to solve duplicates is to identify each packet individually with unique sequence numbers. an advantage is that it easily allows the receiver to identify and discard duplicate packets since it can just compare sequence numbers to check if it already received a packet with that number. however, this approach requires that the range of sequence numbers are chosen wisely so that they do not repeat before each packet is delivered and processed. furthermore, this approach requires more bandwidth/memory due to the overhead of the sequence numbers.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0121q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "phase 1: slow start (getting to equilibrium) “want to find this extremely fast and wasting time”. phase 2: congestion avoidance “additive increase - gradually probing for additional bandwidth. multiplicative decrease - decreasing cwnd upon loss/timeout”. congestion window (cwnd): initial value is 1 mss (=maximum segment size), and counted as bytes. slow-start threshold value (ss_thresh): initial value is advertised window size.\n\t phase 1: slow start (cwnd is less than ss_thresh) => after initialize (cwnd =1), each time a segment is acknowledged increment cwnd by one (cwnd++). then continue until reach ss_thresh (window size) or packet loss. phase 2: congestion avoidance (cwnd >= ss_thresh) => when timeout, that means there is a congestion. and in each time congestion occurs ss_thresh is set to 50% of the current size of the congestion window (ss_thresh = cwnd/2), cwnd is reset to one (cwnd = 1), and slow-start is entered.",
        "answer_feedback": "the response is partially correct because the slow start phase is missing details about how ss_thresh changes when a packet is lost. also, the congestion avoidance phase's explanation lacks how the cwnd is incremented.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.62
    },
    {
        "id": "smp0334q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting is the transmission of concatenated frames in a single transmission. this increases the efficiency in comparison to the carrier extension because we only send relevant data. however, we have to wait until the buffer is full in order to concatenate and send them which increases the end to end delay.",
        "answer_feedback": "the response correctly answers all three parts of the question.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0071q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "this would lead to problems, since this metric would lead to an oscillation of the loadadditionally, it would be a lot of computational overhead, since the paths have to be constantly evaluated",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0268q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "- in order to keep the core packet structure simple, ipv6 removed some unnecessary header fields and provide instead a extension headers, which can be used only when really need it. \n\n-extension headers are located between the main header and the payload.\n\n- advantage: it will help to extend the protocol in the future without affecting other\ncore fields in the packet.( flexibility)",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0017q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "tokenring wouldn't be impaired by the high channel load and can be easily expanded. depending on the traffic and number of computers connected time between sends may be long though.",
        "answer_feedback": "extendability might be a strong suit but it has its flaws and it is not easy to expand!",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.71
    },
    {
        "id": "smp0269q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers in ipv6 are a way of enlarge the header in order to put additional information. they are placed between the fixed header and the payload. the main advantage of extension layer compared to ipv4 is that they are optional while in ipv4 the options field is required. therefore in ipv6 you can add bigger variable length optional information without changing the fixed header. so if you want to change ipv6 you are able to put in information in these extensions.",
        "answer_feedback": "the advantage given in the response is partially correct because the option field in ipv4 is optional as well. it had a variable length of 0-40 bytes.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0392q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "the performance of the network goes down with too many duplicate packets and we need to find ways to differentiate between correct date and duplicate date.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0367q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the initial seqno needs to be known + the next seqno and the next ack-seqno needs to be known.\notherwise, piggybacking is not possible.",
        "answer_feedback": "the response is incorrect as the main requirement for piggybacking is a two-way/duplex channel. the points stated in the response are an implementation detail of the sliding window protocol.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0292q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "1.to support billions of end-systems.\n2.to reduce routing tables.\n3.to simplify protocol processing.\n4.to increase security.\n5.to support real time data traffic.",
        "answer_feedback": "all five ipv6 objectives mentioned in the response are completely accurate.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0306q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "collision domain diameter means the maximum length of line between two nodes in the network which you can use in respect to the length of used frames, the sending speed and the fact, that you want to be able to detect any kind of data collision during transmission. if we now increase the speed of transmission with all other factors remaining the same - especially the frame length -, the time of transmission for each node decreases. so there is less time of data frames travelling on the line during which the stations could detect a collision. to keep the function of collision detection, the maximum length of line - a.k.a. the collision domain diameter - in the network has to decrease to the same factor. so an increase of transmission speed from 10 mbit/s to 100 mbit/s - factor 10 - causes a reduction of collision domain diameter to the factor of 10, too. for example, in ethernet 802.3 this means a reduction from 3000m to 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0190q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the main problem is the \"fairness\" - the nodes in the beginning of the bus can reserve way more data than in the end, to send it to the other bus. this is only based of their position, which is unfair to the other nodes",
        "answer_feedback": "the response correctly identifies the fairness issue in dqdb which depends on the station location in bus.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0074q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "this strategy is problematic, because the utilization can change over time, therfore a can assume paths which are over used at the moment. a update structure for the metric would be needed.",
        "answer_feedback": "to evaluate the path, the current load is used: changes in the utilization are considered and a will not use paths which are overused at the moment.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0182q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "dqdb has a fairness problem. the likelihood to access the medium (reserve a slot on other bus) is not the same for all stations because it depends on the location. that means that a station that is wired at the beginning (or end) of the bus, sometimes has an advantage and sometimes a disadvantage compared to other stations at different locations. this is not fair.",
        "answer_feedback": "the response correctly identifies the fairness problem in dqdb and also provides an appropriate reason for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0115q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps:\n-need large numbers of names because it should be unique -> not usable in reality\n+very potent, because tsap is valid for one connection only\n\n2. to identify connections individually:\n-endsystems must be capable of storing this information\n+if there is a duplicate from another connection they don't interact with each other\n\n3. to identify pdus individually:\n-perfect time has to be known by everybody\n+one can reuse the seqno after a certain time",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0248q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "purpose of rpf and rpb: avoid receiving duplicate packets * rpf: use unicast routing information to decide if an incoming packet is dropped or sent further via the outgoing links: * send further if incoming packet used path in unicast routing info * drop if incoming packet did not use path in unicast routing info * rpb: select outgoing edges: * select edge if a packet coming from the connected node to the sender would use this edge. * sent incoming packet via selected edges (not including the incoming edge).",
        "answer_feedback": "the response correctly answers the purpose and the explanation for both broadcast types. the purpose is to avoid forwarding duplicate packets not receiving but it is acceptable.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0317q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "if the speed got ten times faster, we have to decrease the maximum collision domain diameter by 90%, that is the distance between the nodes, so that a collision can still be detected while sending. so there is basically a tradeoff between distance and efficiency.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0148q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "congestion control consists of the slow start phase, where cwnd<ss_thresh applies and cwnd is increased exponentially until packet loss or reaching ss_thresh, and the congestion avoidance phase with cwnd >=ss_thresh when ss_thresh is set to cwnd/2 and cwnd to 1 after every congestion and the slow start phase restarts.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.in the congestion avoidance phase, the cwnd is increased linearly before congestion occur is also not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0343q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "async. transmission: each character of a message is bounded by a start and stop bit.this mode is both simple and inexpensive, but to the costs of low transmission rates which are mostly limited to 200 bit/sec.\n\nsync.transmission: several characters of the message a \"pooled\" to frames and those frames are defined by syn or flag. this apporach is more complex but enables higher transmission rate.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0128q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases are slow start(getting to equilibrium) and congestion avoidance.\nthe slow start is to discover the correct sending rate where initial congestion window size is 1 and each time the segment is acknowledged, then increasing it by one this is done until the slow start threshold is reached or ends with packet loss.\nin case of congestion avoidance, when the congestion occurs then we reduce the value of slow start threshold to half the value of the congestion window and then resetting back the value of congestion window to 1 and starting the slow start phase again.",
        "answer_feedback": "tthe response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost. the explanation of the congestion avoidance phase is also partially correct as it does not mention how the congestion window increases in this phase, exponentially or linearly.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0084q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop2:\n(b, e, forward)\n(b, c, drop) <= c doesn't send any packets to a, over b\n(c, d, drop) <= d doesn't send any packets to a, over c\n(c, e, drop) <= e doesn't send any packets to a, over c\n(c, f, forward)\n(d, c, drop) <= c doesn't send any packets to a, over d\n(d, f, drop) <= f doesn't send any packets to a, over d\n\nhop 3:\n(f, e, forward)\n(f, g, forward)\n(e, f, drop) <= f doesn't send any packets to a, over e\n(e, g, forward)\n\nhop 4:\n(g, h, drop) <= h doesn't have any adjacent nodes other than g",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop)  will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0285q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "four objectives of ipv6 are:\nlonger addresses to be able support more end-systems\nto be more adaptable than ipv4 in the future by providing extension headers\nmake the header simpler to allow for faster processing in routers\nincrease the security by including ipsec as a mandatory feature",
        "answer_feedback": "the response is correct because all stated objectives of ipv 6 are correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0019q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "using token ring would be a good solution, as it is easy to implement (in terms of hardware) and it provides fairly distributed medium access even in high load situations. a weakness is the ring topology that requires a newly added system to be connected to two other systems.",
        "answer_feedback": "well, there are other solutions, that would be easier to implement then token ring (aloha for example)",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.86
    },
    {
        "id": "smp0353q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission:\n- byte-oriented / block-oriented\n- each byte/block (packet) is bounded by start bit and stop bit\n- low transmission rates, often up to 200 bit/s\n- simple, inexpensive\nsynchronous transmission:\n- multiple characters pooled to frames\n- frames begin and end with syn or flag\n- higher transmission rates\n- requires additional effort / time\n- eg. character-oriented, count-oriented, bit-oriented protocols",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0289q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "to support billions of addresses, since it has much longer addresses than ipv4\nto be open to change, it does so by the support of extension headers.\nto provide better multicasting features than ipv4\nto increase security.",
        "answer_feedback": "the response answers all four objectives of ipv6 correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0111q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "one method to avoid duplicate packets is to make the time-out time of the packets larger. the advantage of that is that the sender has enough time to receive the acknowledgment of the packets. the disadvantage is that if the time-out time is too large and the sender has only a certain window size to send unacknowledged packets, it could results that the sender is sending the data too slow and the receiver has to wait.\n\nanother method is that the receiver can ignore/ discard the same packets by using sequence numbers. the advantage is that the receiver will not be full of duplicate packets and knows via sequence number which packet should arrive next. the disadvantage is that the packets send with sequence numbers are larger.\n\nanother method is to use temporarily valid tsaps. the advantage is that the tsap is only valid for one connection only. a disadvantage is that server addressing is not possible because the server is reached via a designated/known tsap.",
        "answer_feedback": "the problem of duplicate packets on the transport layer in a connection-oriented service needs to be resolved.",
        "verification_feedback": "partially correct",
        "max_score": 1.5,
        "normalized_score": 0.67
    },
    {
        "id": "smp0406q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 and 127.x.y.z",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0165q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "event c, event a and event b",
        "answer_feedback": "the stated order of events is incorrect. the correct order is b, c, a. additionally, the response lacks a justification regarding all event probabilities.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0412q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0/8 - start address\n127.0.0.0/8 through 127.255.255.255/8 are reserved for loopback addresses",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0282q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "1.support larger address space. \n\nthe number of user has increased dramatically. in order to support more addresses,  we need ipv6 with longer address (128 bits) since we are out of addresses with ipv4 (only 32 bits). \n\n2. ipv6 can perform multicasting(and anycast). \n\nin other word, it can send to multiple persons with multiple addresses, which ipv4 can not deliver (ipv4 can only have 1 destination address for unicast).\n\n3.  it helps providing flexibility.\n\nit provides a extension header field, which can be used for appending new field(if need it in the future) without affecting the other fixed headers. \n\n4. ipv6 can simplify the protocol processing.\n\nthe header fields in ipv6 is simpler than ipv4. some header fields, which were rarely used in ipv4, have been removed. therefore ipv6 can simplify the protocol processing.",
        "answer_feedback": "all the ipv6 objectives mentioned in the response are completely correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0349q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "synchronous: characters are sent in frames. their size defined by a syn or flag sent at the start and the end of the transmission.\nasynchronous: characters begin and end are marked a start and a stop bit. each character is sent independently.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0425q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "reserved for loopback : 127.0.0.0 - 127.255.255.255\nclass a reserved range : 10.0.0.0 to 10.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0402q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "duplicates may look like two separate commands/messages to the receiver.",
        "answer_feedback": "the response is correct. the response can also state what will be the consequence in such a scenario.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0271q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "the extension headers are placed between fixed header and payload. extension headers have advantages compared to ipv4 because they are optional, help to overcome size limitation, and allow to append new options without changing the fixed header.",
        "answer_feedback": "the response answers all three parts of the question. there is no specific definition stated in the response but it is present within the advantage part.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0424q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "10.0.0.0 to 10.255.255.255 are reserved",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0265q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers describes a form of additional information, which can be added to the packet. if and how many extension headers are added is optional and completely up to the higher layers to decide. in the packet they are located between the header and the data (unit). the main advantage is that you are not forced to put an option-field in the header, like in ipv4, anymore. so that space is not wasted, if the option-field is not used.",
        "answer_feedback": "the response answers the description correctly. the location of the extension headers is not precise. they are located between the fixed header and payload. the stated main advantage is incorrect as the option field in the ipv4 header is already optional, so there is no added advantage.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0237q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "there are a multitude of challenges facing mobile routing. from the speed the mobile hosts have, to security, scalability etc.  two challenges of mobile routing are hidden terminals and exposed terminals. hidden terminals:  the hidden terminal problem occurs when multiple nodes can access one is, but not each other. this leads to issues when both nodes try to send data packets to the is in the middle simulatenously. as the nodes that are not in each others reach are \"hidden\" from each other, they cannot detect the collision at the is in the middle.  exposed terminals:  the exposed terminal problem occurs when multiple nodes are in close vicinity and in their neighboring radio range. a node (lets call it b) has to wait for an adjacent one (c) to finish with their data transmission (to a node d) before starting their own, even if their destination node (lets call it a) would be a node that is not in the radio range of c. the sender node that has to wait (b) is \"exposed\" to the traffic from the is next to it (c). this leads to underutilization of the channel and low efficiency.",
        "answer_feedback": "the response correctly states and describes the hidden and exposed terminal problems in wireless networks.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0417q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 to 0.255.255.255 is for current network and 127.0.0.0 to 127.255.255.255 for loop-back addresses",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0133q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "1. slow start: each time a segment is acknowledged cwnd is incremented by one. continues until cwnd reaches ss_thresh or a packet gets lost. 2. congestion avoidance if congestions occurs ss_thresh is set to 50% of the current cwnd an the new cwnd is set to one. then the slow start is entered.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost. the explanation of the congestion avoidance phase is also partially correct as it does not mention how the congestion window increases in this phase, exponentially or linearly.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0398q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "if there are many duplicates in the network, the performance may decrease (-> congestion) and problems might occur (bank example from the lecture).",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0037q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding:\n- because the users have perfect synhronized clocks, they can aggree on a time window that is used to send one single bit. so the self clocking of the manchester encoding is not needed.\n- because we have only 3 interconnected users, we also don't need the high susceptibilty to noise, that would bring the differential manchester encoding",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0147q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "1. slow start: cwnd starts smaller then ss_thresh (cwnd < ss_thresh). cwnd gets increased incrementally until it reaches ss_thresh. \n2. congestion avoidance (when congestions occurs: decrease ss_thresh = cwnd/2 and set cwnd = 1)",
        "answer_feedback": "in the slow start phase, the case when the packet is lost before the threshold is reached is not covered.in the congestion avoidance phase, the cwnd is increased linearly before congestion occur is also not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0014q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i recommend using the p-persistent csma procedure. as the channel load will be high, the company would profit from the high efficiency in terms of the overall throughput of this procedure. with a low p-value, the p-persistent csma could even reach perfect throughput efficiency. also, adding additional systems to the network is simple, as the single participants in this procedure do not need to be aware of each other and it the procedure works completely decentralized. this increases the extendability and maintainability with extending scale. however, one drawback of this approach is that it introduces the p-value as an additional fine-tuning parameter that needs to be adjusted to fit the application scenario at hand, which introduces additional complexity.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0020q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i will use token ring, because it has random frame lengths and good throughput. that's why token ring is expandable.\nbut there is delay because of waiting for token.",
        "answer_feedback": "random frame length and good throughput do not lead to extendability! extendability might be a strong suit but it has its flaws!",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.86
    },
    {
        "id": "smp0140q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the 2 phases of congestion control with tcp:\n1) slow start \n2) congestion avoidance\n\nat 1): the congestion window (cwnd) becomes incremented each time a segment is acknowledged until a package is lost or ss_thresh reached. when cwnd >= ss_thresh, tcp slows down the increasing of cwnd by adjusting tge transmission rate . \nat 2): each time a congestion occurs ss_thresh is  set to half of the size of cwnd (ss_thresh = cwnd / 2) and cwnd is set to 1. then the slow start phase begins again.",
        "answer_feedback": "\" when cwnd >= ss_thresh, tcp slows down the increasing of cwnd by adjusting tge transmission rate . \" should be in phase 2. also congestion canoccur in phase 1 and change in the cwnd needs to be mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0421q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "reserved addresses:\n127.0.0.0 – 127.255.255.255 (for loop-backs)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0207q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption mostly does not hold for real internet traffic as packets are not sent independently and in a steady way. rather, internet traffic is very bursty. data and messages are not sent via individual and independent packets so a single packet most likely is part of a larger message with which it is sent together.",
        "answer_feedback": "it is correct that the assumption does not hold because of bursty traffic. however, the explanation for why the traffic is bursty only refers to packet fragmentation which is only a small reason for bursty traffic.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0106q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "method 1: to use temporarily valid tsaps\ngenerate unique (transport) service access point (tsap) for each communication and they are valid for one connection only\nadvantages:\nyou can always generate new tsaps disadvantages:\nsome tsaps are standardized(\"well-known ports\") and cannot be usedmethod 2: to identify connections individually\neach connection is assigned a new sequence number and endsystems story assigned sequence number and remember them\n\nadvantages:\nduplicates from another connection with a  sequence number doesn't interact with other connection with a different sequence number.disadvantages:\nonly works with connection-oriented servicemethod 3: to identify pdus individually: individual sequential numbers for each pdu\n\nadvantages:\nbetter usage of bandwidth and memory because you have individual sequence numbers for each packet and they almost never get resetdisadvantages:\nsequential number range depends on packet rate and packet probable \"lifetime\"",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0241q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "one challenge is the hidden terminal problem. csma doesn't work in mobile networks because a node cant see the whole transmission medium. they can't detect if there is some other node sending,to the same destination, at the moment so the send to and cause a collision. an other challenge is the exposed terminal problem. it can happen that a node tells all other nodes in range not to send, to avoid collisions at their receiver. but some nodes then need to be silent even though they aren't even in range with the receiver of the other transmission and therefore can't create a collision. so the wait unnecessary and utilization is lower than it could be.",
        "answer_feedback": "the description of the exposed terminal problem is partially correct. it states that a node tells all other nodes not to send. but instead, the node wanting to send senses the medium is busy and waits until it is free again.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0088q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(a, b, forward)(a, c, forward)(a, d, drop) <= d knows that either c nor f are routing to a over dhop 2:(b, e, forward)(c, f, drop) <= f knows that either c nor d or f are routing to a over fhop 3:(e, g, forward)hop 4:(g, h, drop) <= h has no neigbors except g (no links except the incoming link)",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0230q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table holds information about which station is attached on which lan. it includes a timestamp, adress of station and lan. \nwhenever the bridge receives a frame from a station, it can determine in which lan the station is attached. from this information the bridge builds an entry for the station in the bridging table. the advantage from backwards learning is, that the bridge does not have to flood the frames, therefore decreasing the network traffic. additionally, the bridge can drop frames, that are adressed for a receiver in the same lan as the sender station. \nthe entries are deleted, if they haven‘t been updated for a set time (usually several minutes).",
        "answer_feedback": "the response answers all the four requirements of the question correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0064q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the likelihood of the less than 10 packets waiting in the queue is one minus the blocking probability, which is about 5,08%. \ngiven this information, 94,92% of the time, you would expect less than 10 packets to wait in the queue. \nin one minute, this would be about 57 seconds.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0082q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop2:\n(b; c, drop) <= b knows that c does not receive unicast packets via b\n(b, e, forward)\n(c, b, drop)<= c knows that b does not receive unicast packets via c\n(c, d, drop)<= c knows that d  does not receive unicast packets via c\n(c, e, drop)<= c knows that e does not receive unicast packets via c\n(c, f, forward)\n(d, c, drop)<= d knows that c does not receive unicast packets via d\n(d, f, drop)<= d knows that f does not receive unicast packets via d\nhop3:\n(e, c, drop)<= e knows that c does not receive unicast packets via e\n(e, f, drop)<= e knows that f does not receive unicast packets via e\n(e, g, forward)\n(f, e, drop)<= f knows that e does not receive unicast packets via f\n(f, g, drop)<= f knows that g does not receive unicast packets via f\n(f, d, drop)<= f knows that d does not receive unicast packets via f\nhop4:\n(g, h, forward)",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0129q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "cwnd indicates how much data can currently be sent at once before waiting for acknowledgements.  cwnd is doubled every time all remaining acknowledgements are received and as long as cwnd is lower than ss_thresh. once a packet times out (no acknowledgement received), cwnd is reset to 1 and ss_thresh is set to half its previous value (phase one - slow start).  \n\t after surpassing ss_thresh, cwnd will only increase linearly (phase two - congestion avoidance) and will revert to slow start after a timeout.",
        "answer_feedback": "the response correctly states the name of the two phases. the explanation of the slow start phase and congestion avoidance phase is correct except that  ss_thresh is set to half its current congestion window value, not half of its previous threshold value. when the timeout occurs in phase 2, the congestion window is reset to 1, and ss_thresh is set to half its current congestion window value and then reenter into the slow-start phase.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0263q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning trees allows to reach all other nodes of a network with a small subset of links. a spanning tree therefore \"provides\" information for broad- and multicasting to send the packets through the \"best\" route (e.g. minimum hops).",
        "answer_feedback": "the response incorrectly describes the reason why a spanning tree is attractive for broadcast and multicast. although the number of links is reduced, they also need to connect without loops, reducing duplicates. the modification related to the link state algorithm to construct a  multicast spanning tree is not provided.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0217q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "initially, the bridge table, containing fields for the sender, the receive timestamp and the used lan, is empty and as a result the bridge will simply use flooding to reach an unknown destination. during the backwards learning phase the bridge works in promiscuous mode - receives all frames from all its lans - and uses the information of those frames in order to build its table. the information from the table then allows the bridge to forward incoming packets to the correct lan in order for it to reach its destination. the benefit of this method is that the bridge learns and adapts over time and does not have to rely on flooding, therefore optimizing bandwidth usage.",
        "answer_feedback": "the response does not state which information is learned from the received packet and how it is used while selectively forwarding packets. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0206q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "- the tcp header has a sequence number to enable reliable communication, the udp header doesn't.\n- the tcp header has a acknowledgment number, which is used in the 3-way handshake. it is also necessary for the reliable communication. udp doesn't need this field, because it is a connectionless protocol.\n- the tcp header has some flags, which are used for connection management. for example syn for connection establishment and fin for connection release.\n- the tcp header has a field for the advertised window, it is used for flow control. udp doesn't have any flow or congestion control.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0021q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "ich würde tdma mit reservierung vorschlagen,da die auslastung bei dem konkreten beispiel hoch ist und es weniger kollisionen gibt, was insgesamt für einen höheren durchsatz sorgt. außerdem soll, wenn mehr systeme dazukommen, die wartzeit einzelner systeme durch ungenutzte slots nicht zu hoch sein. daher ist es von vorteil den tdma mit reservierung zu benutzen. ein nachteil von tdma mit reservierung ist, dass durch die steigende anzahl an geräten die anzahl der contention slots steigt, was zur folge hat, dass das mehr netzwerkkapazität den contention slots zufällt.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0048q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary coding. \nbecasue if the clocks are perfect in the local newtwork, there in no need to do self-clocking. and the binary coding has better utilization (almost 200%) to bandwidth than other techniques, which is important when the traffic is heavy.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0146q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phases of congestion control: \n- 1. phase: slow start\n- 2. phase: congestion avoidance\nfirst, in the slow start phase, where the cwnd is smaller than the ss_tresh, the cwnd is initialized with cwnd = 1. now the sender can send one segment in the initial set-up. for each acknowledgment, the sender receives the cwnd increases by 1, which means that cwnd doubles his size every rtt. when the cwnd is greater or equal the ss_thresh (cwnd >= ss_thresh) the second phase congestion avoidance begins where the whole cwnd increase by 1 every rtt. ss_thresh doesn't change until congestion occurs.\neach time congestion occurs the ss_tresh is set 50% of the current size, the congestion wind is set to cwnd = 1, and slow-start phase begins again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0062q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "p10 = ((1 - rho) * rho^n) / (1 - rho^(n+1)) = ((1 - 0.9) * 0.9^10) / (1 - 0.9^(11)) = 0.0508\n\nseconds with 10 packets in queue = p10 * 60 = 3.048\n\nseconds with less than 10 packets in queue = 60 - 3.048 = 56.952\n\nso the system is expected to have 10 packets in it's queue for about 3 seconds and less than 10 packets for the remaining 57 seconds.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0362q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is a new version of rarp and bootp but more or less does the same thing. most of the time its a router that can both manually or automatically assign ip addresses (and other information such as dns server, netmask, default router etc. ) to clients in its domain. the request from the clients is a broadcast request, the dhcp server then answers. \na big advantage is the dynamic allocation of ip addresses. each address is given out with a lease timer. a client has to refresh his lease before the timer runs out. if it does, and the client has not refreshed his lease, that ip address can once again be assigned to a new client. therefore it allows to reclaim addresses of disappearing hosts.",
        "answer_feedback": "the definition/description is partially correct as it is a separate protocol or a successor protocol with extended functionality and not a new version of rarp and bootp.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0023q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "csma/cd:\n- attached systems, that are not sending for a long time, don't slow down the network. so the heavy load can be handled well, if only few systems at a time need a high transfer speed.\n- new systems can easily be added without altering the procedure of the router, like in polling or token ring. \n\ncon: \n- if the systems need to have some real time requirements, the procedure can't ensure it. in this case you could implement a tdma with reservation every given time only for this kind of data transfer.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0346q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronisation between sender and receiver.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0138q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "conjestion control with tcp has 2 phases: 1) slow start and 2) conjestion avoidance\n\nslow start -> after initialization, in each step, cwnd is increased exponentially (2^x), until it reaches(or surpasses) ss_thresh.\n conjestion avoidance -> then, it starts increasing only by 1 in each step.\nif we receive a timeout (congestion), the process starts again, but this time we set new ss_thresh = cwnd / 2 and cwnd = 1.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0393q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "duplicate packages are handed over to the receiver too late at an undesired time, so that the receiver can't handle it or handles it twice, which for example can result in a loss if for example money is booked twice.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0223q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "transparent bridges maintain a table that maps each station to an output line or lan the bridge is connected to. initially the table is empty, the bridge reads packets from all its output lines and learns where the stations are located. this phase is called the backwards learning phase. during the forwarding process, the bridge uses the table to make the following decisions. if the source and destination are known and are from the same lan, the packet is dropped. if the source and destination are known and are from different lans, the packet is forwarded to the correct output line. if the destination is not known, then the packet is flooded on all its lines. benefits of such a forwarding process is, only frames that need to cross the bridge are forwarded. they also reduce collisions by creating a separate collision domain on each line of the bridge.",
        "answer_feedback": "by observing packets, the bridge learns through which lan a station can be reached, not where the station is located. this information is used in selective forwarding. apart from this, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0158q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "least probable -> b -> c -> a -> most probable\nb: there is only one case of all possible sequences where event b occur. \ncalculation: p(b) = 0.6^3*0.4^3 = 0.014\nc: if event b occurs, event c occurs too. additionally event c includes several more cases (e.g. htthht)\ncalculation: p(c) = 6 over 3 * p(b) = 0.276 \na: event a includes every case of event c. additionally event a includes several more cases (e.g. hhhhtt)\ncalculation: p(a) = sum_x=3_n=6 (6 over x * 0.6^x * 0.4^(1-x)) = 0.821\nthe exact probability of h is not relevant in this case (except probability of h is 0 or 1 where the probabilities of some or all events becomes equal).",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0130q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases are called slow start and congestion avoidance. in the slow start phase the cwnd is less than ss_thresh which mean we send less data than the advertised window. in the congestion avoidance cwnd is greater or equal to the advertised window which means we send more or exactly enough to saturate the receiver, since we started slowly, we know that the network is very likely to handle the traffic.",
        "answer_feedback": "the response correctly states the name of the two phases. the response does not state the condition, nature, and degree of change in the congestion window and slow start threshold. further, the answer is missing what happens when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0404q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "this can be a problem if the recipient of the duplicates has no way to distinguish between correct and duplicate data, such that late duplicates could be incorrectly considered as new data.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0391q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "the network protocol needs a method to prevent duplicate packets otherwise a loop could be formed where the duplicate packet is forwarded indefinitely. an is would need to keep track of all packets it has seen recently which is not feasible.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0314q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter, the maximal distance where collisions can be recognized decreases tenfold. if the collision domain diameter was 3000 meters before, it now is 300 meters.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0153q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the first phase is called slow start and there cwnd is initialized to 1 and increases exponentially fast (for each acknowledged segment: cwnd++) as long as  the congestion window is below the threshold and the acknowledgements arrive before their timeouts. once the window size exceeds the threshold, the congestion avoidance phase starts and there the congestion window grows lineary (incremented by one). in both cases, in case of a timeout, the threshold is set to half the value of the current congestion window and cwnd = 1.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0180q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service:\n  -  units are transmitted isolated and independently. errors are detected by upper layers.\n\nconfirmed connectionless service:\n  -  the receiver acknowledges received data with a receipt for data units\n  -  in comparison to unconfirmed c. s. data units can be retransmitted if they are missing/not acknowledged. retransmitted packages may lead to duplications and sequence errors\n\nconnection-oriented service\n  -  no package loss, no duplication, no error sequences due to flow control\n  -  the sender sends connection request, to make sure the receiver is ready to get data\n -  data is transferred and the connection is closed after that",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0103q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(a, b, forward)(a, c, forward)(a, d, forward)hop 2:\n(b, c, drop) <= c already has packet from a from hop #1(b, e, forward)(c, b, drop) <= b already has packet from a from hop #1(c, d, drop) <= d already has packet from a from hop #1(c, e, drop) <= e has packet from b with better metric from route abe (2+1=3) vs. ace (2+2=4)(c, f, forward)(d, c, drop) <= c already has packet from a from hop #1(d, f, drop) <= f has packet from c with better metric from route acf (2+1=3) vs. adf (2+3=5)hop 3:\n(e, c, drop) <= c already has packet from a from hop #1(e, f, drop) <= f already has packet from c from hop #2(e, g, forward)(f, d, drop) <= d already has packet from a from hop #1(f, e, drop) <= e already has packet from b from hop #2(f, g, drop) <= g has packet from e with better metric from route abeg (2+1+1=4) vs. acfg (2+1+2=5)hop 4:\n(g, f, drop) <= f already has packet from c from hop #2(g, h, drop) <= h has only one neighbor (g) from which it got the message",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0029q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i think, binary encoding should be used in this network. the reasons are following:\n1. all users are interconnected and have perfect clocks, so we don't need to worry about synchronization problem between receiver and sender, i.e self-clocking feature is not necessary in this case.\n2. to mitigate network congestion causing by excessive traffic, we need to improve bit rate. using binary encoding can provide double wideband compared to manchester encoding.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0246q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "energy efficiency: not having infinite power leads to the problem of having to safe power as to not empty the mobile instantly.\nadaption of routing protocols: in a constantly changing network you have to use other routing algorithms, than in a normal network",
        "answer_feedback": "the response states and describes both the challenges correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0264q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning trees have all nodes covered with the minimum number of edges, so there can't be any loops. that makes them appealing for broad- and multicasting. if we modify link state routing so that each is calculates a multicast tree. all is send link state packets periodically and from the now locally available and complete state information each is calculates a multicast tree.",
        "answer_feedback": "the response correctly answers why a spanning-tree usage is ideal in multicast and broadcast. the provided information for modifying link state to construct a multicast spanning group is not complete as it does not state what additional information is added in each link-state packet apart from the regular information.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0405q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 \n127.255.255.255\nthe first adress and the last adress of each subnet are reserved",
        "answer_feedback": "the addresses have a range: 127.0.0.0 - 127.255.255.255\nmissing loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0296q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "support billions of end systems due to a longer addressing scheme.\nreduce routing tables and simplify protocol processing due to simpler header structures.\nsupport real time data traffic due to traffic classes and flow labels\nprovide multicasting and support mobile end systems",
        "answer_feedback": "the response states four correct objectives of ipv6.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0143q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the two phases are\nslow start (getting to equilibrium) andcongestion avoidance.in the first phase cwnd is increased each time a packet has been acknowledged until ss_thresh is reached or a package is lost. when ss_thresh is reached, the increasing of cwnd (until now doubled each rtt) is slowed down.if an timeout occures in the second phase, ss_threshold is set to cwnd/2, cwnd is reset to 1 and slow start procedure is executed again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0035q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i think they should use binary encoding. compare to other encoding techniques, binary encoding has good utilization of bandwidth. also, the encoding is simple and cheap.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0403q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "they can cause an action to happen twice since the receiver may not be able to distinguish between a packet that was sent twice and one packet that arrives twice.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0094q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a,b,forward)\n(a,c,forward)\n(a,d,drop) d will not forward the packet, because a is the origin and d is not part of a unicast route a-c or a-f.\nhop 2:\n(b,e,drop) b is origin, routes g-a, f-a, c-a do not go through e(c,f,forward)\n\nhop 3:\n(f,g,forward)\n\nhop 4:\n(g,h,drop) g is origin of the packet, no further neighbors",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0380q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "both parties must be able to send data and acknowledge information",
        "answer_feedback": "the response answers the underlying requirement, i.e. duplex connection, correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0101q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 2: \nfrom b: \n(b, c, drop), (b, e, forward) \nfrom c: \n(c, b, drop), \n(c, d, drop), \n(c, e, drop), \n(c, f, forward) \nfrom d: \n(d, c, drop), \n(d, f, drop) \nhop 3:\n from e: \n(e, c, drop), \n(e, f, drop),\n(e, g, forward) \nfrom f:\n(f, d, drop), \n(f, e, drop), \n(f, g, drop) \nhop 4: \nfrom g: \n(g, f, drop), \n(g, h, drop) \nbecause vertex h has only one neighbor from which it got the message, vertex h does not forward the message.\nin total 19 messages are sent during the broadcast.",
        "answer_feedback": "hop 1 not given and (c, f, drop) occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0300q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "1.) global addressing concept for end systems\n2.) simplified address allocation\n3.) addresses independent from\n  - type and topology of the subnetworks\n  - number and type of the subnetworks to which the end systems have been connected \n  - location of a source end systems\n4.) increasing data security",
        "answer_feedback": "the response correctly answers four objectives of ipv6.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0124q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the first phase is called \"slow start\".\nafter the initialisation, the sender starts sending segments, and waits for the receiver to acknowledge them all. this number will double every round trip time (rtt) until the advertised window size is reached. if a timeout happens beforehand, phase one is restarted immediately.\n\nwhen ss_thresh is reached, phase two - \"congestion avoidance\" - is entered, when the \nthe rtt will be increased linearily until a timeout occurs. when this occurs, phase one is initialized again.\nthese two phases will be repeated over and over again, the sending rate will never be constant with tcp.",
        "answer_feedback": "the response is correct except that in both the phases when the congestion occurs,  ss_thresh is set to half of the current size of the congestion window and the congestion window is reset to one, which is not the same as the initialized value where cwnd = 1 and ss_thresh = advertised window.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0401q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "duplicate können zum problem werden, weil zum beispiel befehle mehrmals ankommen und auch mehrmals ausgeführt werden.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0383q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "both parties have to advertise their window sizes to each other to avoid the received data to be thrown away (so the receiving buffer was full). therefore, they need to introduce a new field to the frames which holds this value. alternatively, they agree upon first communication to some static window size and afterwards send their data (and hope the free buffer sizes of both remain the same). in both cases it would be recommandable not to send huge data chunks upon first communication, because both parties don't know the window sizes of the other one yet. with each frame they send a sequence number (even if no data is sent, so the receiver is able to acknowledge it), the ack-number (even if no new data has been received, so the receiver can use this as base for their sequence number), and lastly the window size.",
        "answer_feedback": "the response is incorrect. all the stated points are correct but are related to the window sliding mechanism in general and how the initial setup occurs.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0325q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting is a communication protocol, where one transmission can consist of a concatenation of frames. compared to the carrier extension the throughput increases and has higher efficiency. one disadvantage is that the frames have to wait for their transmission. so frame bursting shouldn't\nbe used with more than 3 clients as this disadvantage can result in lower for every client.",
        "answer_feedback": "the response correctly states the frame bursting definition, advantage and disadvantage.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0415q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 and 127.255.255.255",
        "answer_feedback": "the addresses have a range: 127.0.0.0 - 127.255.255.255\nmissing loopback",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0195q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "while both (udp and tcp headers) have source and destination port fields, every other part of their headers differ. for udp only a packet length and a checksum field follows the two previously mentioned fields. tcp needs more information. so after the source and destination port the header is followed by a sequence number field as well as a field for the ack number. the tcp header also stores information on hl/resv/flags, window size, checksum (as in udp), urgent pointer and options.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0150q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start\nphase 2: congestion avoidance\nafter initialization of cwnd and ss_thresh, cwnd is continuously incremented, increasing the sending rate, as long as segments are acknowledged. this happens until cwnd reaches ss_thresh upon which tcp slows down the increase of cwnd. every time congestion occurs, ss_thres is set to cwnd / 2 and cwnd reset to 1.",
        "answer_feedback": "the response needs to be specific about the rate in both phases.i.e exponential increase in phase 1 and linear increase in phase 2.\nin the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.63
    },
    {
        "id": "smp0243q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "1. hidden terminals: for given nodes a, b and c, nodes a and c cannot hear each other if their transmissions collide at node b. in this way, nodes a and c remain hidden from each other. 2. exposed terminals: for given nodes a, b, c and d, b sends to a and c wants to send to another terminal like d, but not a or b. c has to wait and signals a medium in use. but a is outside the radio range of c, therefore waiting is not necessary. in this way, c is now \"exposed\" to b.",
        "answer_feedback": "the response correctly states and describes the exposed terminal problem. but in the hidden terminal problem, not only the collision but also the transmission of the other sender remains undetected.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0032q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "i would use a binary encoding as the bandwidth is limited. binary encoding makes good use of the given bandwidth as it has 1 bit/baud, with both types of manchester encoding having only 0.5 bits/baud. additionally given a perfect clock the manchester encodings are not needed, as their main advanteges are self clocking in unsynchronized networks.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0061q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "calculate the probability that there are 0, 1, 2, 3, 4 .. 9 packets in the queue.  sum these probabilities and multiply that by 60 seconds.\n\nprobabilities can be calculated with these formulas where pn is the probability the queue has n packets in it:\np0 = (1-r)/(1-r^(n+1))\npn = (1-r)r^n/(1-r^(n+1))\nr = 9/10 = 0.9\n\nprobability of 0 to 9 packets in the buffer = 0.9492\nseconds = 56.96",
        "answer_feedback": "the response correctly explains how the number of expected seconds can be calculated. however, the number of expected seconds or the probability is rounded incorrectly. the correct value is 56.952 instead of 56.96 seconds.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0213q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, this assumption does not hold for real internet traffic. if somebody for example streams videos on the internet, the probability that after the first packet another packet will arrive is much higher than the probability for the first packet. if you increase the interval δt there is the possibility the assumption become true again, but it’s not a realistic case.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0210q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no the assumptions does not hold, since the arrivals depend on each other. for example one request to a server leads to multiple packets being sent back. also the answer of the server then might lead to multiple requests afterwards. thus the packets come in stacks with time in between, since the server and the client need to process the packets.",
        "answer_feedback": "the response is correct except that it attributes the bursty nature of the internet traffic to the request/response model which is not always the case.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0372q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "-it has to be a full-duplex operation\n-frames must contain implicit acknowledgments",
        "answer_feedback": "the response answers the underlying requirement correctly. both points are correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0052q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "with perfect clock we can use binary encoding as the problem with  long sequence of 0/1s wouldn't cause clock synchronization issue. moreover, it's simpler and makes an efficient use of the bandwidth which could be helpful with heavy network traffic.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0056q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "with the poisson process, we can calculate p0 to pn. if p0 = 0.5, this means, 50% of the time the system is empty. \nin this exercise, we have a λ=9, µ=10 and n=10. the blocking probability (the probability that the system is full) p10 is 0.051. so, 5.1% of the time, the buffer is full. the complementary probability (the buffer has less than 10 packets waiting) is 0.949. as a result, in one minute we expect that in 0.949*60s = 56,94s less than 10 packets are waiting in the queue.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0109q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. sequence numbers: + discards duplicates\n2. par: + doesn't block at loss of both frames and acks; - long wait possible\n3. nak: + discards bad frame, can reduce additional traffic",
        "answer_feedback": "the problem of duplicate packets on the transport layer in a connection-oriented service needs to be explained.",
        "verification_feedback": "partially correct",
        "max_score": 1.5,
        "normalized_score": 0.17
    },
    {
        "id": "smp0394q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "if the receiver can't detect that a certain packet is a duplicate of one that arrived before, it might be processed independently causing maybe an action to be executed twice (for example a bank transaction).",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0218q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "a bridge connects some different lans the bridge table contains the information which lan needs to be accessed to reach a certain destination address. at the beginning the bridge does not know the topology and uses flooding to forward packets to the right destination. once a correct route is found a new table entry with this new information is added to the table. this process of slowly getting to know the topology is called backwards learning. when a packet arrives at the bridge and its destination address is already in the bridge table there is no need for flooding the packet can be forwarded directly according to the table entry.",
        "answer_feedback": "the response does not mention what is learned and interpreted on receiving a packet from source s over link l, i.e. s can be reached over l. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0382q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "piggybacking in sliding window allows to send the acknowledgment of a received frame together with data.\n- sender and receiver needs two sequence counter. one for its own frames and one for the acknowledgment of the received frames.\n- benefits the most from a duplex connection\n- when a frame is send, the seqno of the frame and the seqno of the last received frame (for acknowledgment) are send together.\n- the seqno is initialized with 0 and is increased before a new frame is sent.",
        "answer_feedback": "the response is correct as it identifies duplex connection as one of the requirements, but the sequence number need not be initialized with 0.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0365q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is used to assign ip addresses and other configuration to (new) hosts in a network. after an initial dhcp discover packet of a client the server sends the assigned ip address back with additional information, like dns server or netmask.",
        "answer_feedback": "the response answers the definition and the usage of dhcp correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0102q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a,b,f)\n(a,c,f)\n(a,d,f)\n\nhop 2:\n(b,e,f)\n(b,c,d) <- a,c is faster, not minimal spanning tree\n(c,b,d) <- a,b is faster, not minimal spanning tree\n(c,e,d) <- b,e is faster, not minimal spanning tree\n(c,f,f)\n(c,d,d) <- a,d is faster, not minimal spanning tree\n(d,c,d) <- a,c is faster, not minimal spanning tree\n(d,f,d) <- a,c,f is faster, not minimal spanning tree\n\nhop 3:\n(e,c,d) -> a,c is faster, not minimal spanning tree\n(e,g,f)\n(e,f,d) -> a,c,f is faster, not minimal spanning tree\n(f,e,d) -> a,b,e is faster, not minimal spanning tree\n(f,g,d) -> a,b,e,g is faster, not minimal spanning tree\n(f,d,d) ->a,d,f is faster, not minimal spanning tree\n\nhop 4:\n(g,f,d) -> a,c,f is faster, not minimal spanning tree\n(g,h,f)",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0381q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the participant, who sends the ack, has to have data, which he wants to send. if there is no data to \"biggyback\" the ack on, the participant will wait infinitly for data to send with the ack and therefore the piggyback extension would not work.",
        "answer_feedback": "the response is incorrect because a dedicated timer can be used on the receiver side to overcome the above problem of no data on the receiver side. after the timeout, an acknowledgment is sent independently.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0145q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "first pahse is the slow start phase. second phase is the congestion avoidance.\nfirst phase:\nfor every acknowledged packet the cwnd increases by the maximum segment size\nss_thresh is not changing in this phase\nsecond phase\ncwnd increases with each acknowledgment received linearly. 1/cwnd is the increase\nss_thresh is set to half the congestion window size on timeout",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached(ss_thresh is set to half the congestion window).",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0166q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "event a:\n- the number of h’s follows a binomial distribution with parameters n=6 and p=0.6\n- p[y>=3] = p[y=3] + p[y=4] + p[y=5] + p[y=6]\n- p[y>=3] can be calculated as follows: ((6 choose 3)*0.6^3*(1-0.6)^(6-3))+((6 choose 4)*0.6^4*(1-0.6)^(6-4))+((6 choose 5)*0.6^5*(1-0.6)^(6-5))+((6 choose 6)*0.6^6*(1-0.6)^(6-6))\n- the probability for event a is 0.8208\n\nevent b:\n- the probability that the coin flip results have a specific order is just the product of the probabilities of each desired result\n- p[hhhttt] = 0.6^3*(1-0.6)^3\n- the probability for event b is 0.013824\n\nevent c:\n- p[y=3] = (6 choose 3)*0.6^3*(1-0.6)^(6-3)\n- the probability for event c is 0.27648\n\nhence, the order of the events is b,c,a. this makes sense because b is the most specific event and a the most general.",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0083q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\n\nhop 2:\n(b, e, forward)\n(b, c, drop) <= a->c is shorter\n(c, b, drop) <= a->b is shorter\n(c, e, drop) <= a->b->e is shorter\n(c, f, forward)\n(c, d, drop) <= a->d is shorter\n(d, c, drop) <= a->c is shorter\n(d, f, drop)  <= a->c->f is shorter \n\nhop 3: \n(e, c, drop) <= a->c shorter\n(e, f, drop) <= a -> c-> f is shorter\n(e, g, forward)\n(f, d, drop) => a->d is shorter\n(f, e, drop) => a -> b-> e is shorter\n(f, g, drop) => a -> b -> e -> g is shorter\n\nhop 4:\n(g, f, drop) => a->c->f is shorter\n(g, h, forward)",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0189q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "to build a metropolitan area network (man), which can combine asynchronous data traffic(ieee 802.x mac) and isochrounous traffic (atm-b-isdn), the dqdb (ieee 802.6) was designed.\ntherefore, two unidirectional buses are used. one bus is in the opposite direction of the other. a node is connected to both buses, on one bus data can be requested, on the other one data is sent.\nthe main problem with this architecture is, that a node can request more data than others depending on its position in the network.  so fairness is the issue with dqdb. \nto sum up:\n\"for a light-to-medium load, dqdb is somewhat unfair.\", fairness issues of the dqdb protocol,",
        "answer_feedback": "the response states the correct problem in dqdb architecture, including the proper explanation for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0135q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "phase 1: slow start\n\t \nthe cwnd starts with one and increases (with factor 2^x until a specific value then it grows linearly with +1) until the threshold is reached or packet loss occurred\n\n\nphase 2: congestion avoidance\nif cwnd >= ss_thresh or package loss occurred, the ss_thresh is set to 50% of the cwnd value.\nthe cwnd is reset to 1 and increased again until ss_thresh is reached or package loss occurs (new slow start)",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost. also, the congestion avoidance description does not state how the cwnd increases.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0181q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connection-less service, confirmed connection-less service, and connection-oriented service.\nan unconfirmed connection-less service offers no feedback, if the sent frame was received. a confirmed connection-less service offers this feedback with a simple acknowledgment per frame, therefore no loss occurs. but the acknowledgment can also lead to duplicates because the sender may have not received the ack yet and retransmits the frame. in contrast to other two, a connection-oriented service provides a connection without duplication or sequencing errors and provides flow control, because the connection is setup (exchange of parameters, i.e. sequence number) and teared down afterwards.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0297q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "support billions of end-systems \n\nsimplify routing tables and protocol processing \n\nsupport real time traffic (quality of service)\n\nto be open for change",
        "answer_feedback": "the response answers four objectives of ipv6 correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0069q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "there are multiple possible ways a package could take on its way to g. problems occur because when a path is chosen it's utlilization is goes up makting this a less attractive option, so another path is chosen, repeating indefinately, causing heavy routing overhead.",
        "answer_feedback": "why would this be repeated? if another path has less utilization, the path will be used and the packet will be transmitted to g.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0224q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "each entry in the bridge table holds: a destination address s, which lan (link) l is to be used to reach s, and a timestamp t of when last the frame from s arrived.\n\nwith backward learning, the bridge learns from an incoming frame and the lan connected to the link through which the frame was received that the frame's source s can be reached via lan l (directly or through other bridges) and stores/updates this information (s, l and frame arrival time t) on any arrival of a frame with s as the source address (and purge it by another process if it is too old, that's why t is stored).\n\nthe forwarding process uses the bridge table by looking up the entry for a given destination address s to decide what to do with an incoming frame addressed for s: if an entry is found then the frame is either rerouted via the destination link l if that link is different from the incoming link or discarded (as it should not leave the lan), else flooding is used as a fallback (destination lan unknown).\n\nthe benefit is a reduced network load (compared to flooding the network) if an entry exists for a destination because then only the relevant outgoing link is used and no needless copies of the frame are created and flooded into the network.",
        "answer_feedback": "the response answers all the four requirements of the question correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0360q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "simplifies installation and configuration of end systems , allows for manual and automatic ip address assignment, may provide additional configuration information(dns server, netmask, default router, etc.)\nused for:  request can be relayed by dhcp relay agent, if server on other lan",
        "answer_feedback": "the stated usage is not a usage but the process of how it is carried out.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0238q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "in mobile communication, nodes can move, i.e. are not placed on a fixed location, and are transmitting over the air, i.e. they use wireless communication. this stands in big contrast to fixed and wired networks.\n\nto adapt to these new factors, challenges on many different layers occur. whether the discovery of service in the application layer, the specific needs for routing in the network layer, or the control of power used for transmission in the physical layer and even more have to be taken into account to set up such a mobile network.\n\n             -  for mobile routing, the following challenges exist:\n\n                         o   hosts can move and change the attachment to a certain network segment (handover). this handover mechanisms occur in cellular networks and in complex wlan infrastructures as well. for the  example of wlan, handover can be handled at the link layer if both ace points are in the same networks. if there are different networks, a network layer handoff occurs and needs to be considered to implement routing for a seamless service.\n\n                         o   in mobile ad-hoc networks, nodes can disappear due to the radio system and channel characteristics. therefore the network topology may change rapidly and pre-calculated, pro-active routing may fail. in this case, reactive routing maybe of preference, as the route is calculated using the actual network topology.\n\n             - moreover, the general challenges in mobile communication include:\n\n                        o   hidden terminals\n\n                                §  since in mobile communication no wire is used, the nodes can only listen for a certain distance defined by the radio parameters and the channel characteristics, which makes the usage of csma/cd not practicable as the concept of carrier detection (cd) does not work.\n\n                                    an already happening transmission to a certain destination node could not be detected by an intermediate system (is) if the node communicating with the destination node is out of the “listening”-range of the is. to solve this problem the collision will not be “detected” but “avoided” using certain acks (csma/ca, rts/cts).\n\n                       o   exposed terminals\n\n                                 §  when a node wants to send a packet and detects an already existing transmission in its transmission area, it waits until the existing transmission is finished and only thereafter sends its packet to avoid collisions.\n                                     this can cause underutilization of a channel if the receiving nodes are far enough away from each other, i.e. beyond the radio range, and therefore both transmissions would not affect each other and could have successfully be completed in parallel.\n\n                       o  near and far terminals\n\n                                  §  if multiple packets arrive at the receiver, they will typically arrive with different signal strengths. depending on the modulation used, the receiver will detect the “stronger” packet and ignore the “weaker” packets if the power difference is large enough. however, fading and multipath may lead to changing power levels and add complexity to the problem.\n\n                                  §  using a multipath receiver design, both packets can be detected as different paths and the receiver may fail to detect these packets. the near/far problem is difficult to solve in direct sequence spread spectrum systems (rake receivers). in ofdm based system, this problem is less severe.",
        "answer_feedback": "the response correctly states the challenges faced in the wireless network.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0211q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "after all, this is not less and not more than a simple model. the details of internet traffic including bursty traffic situations, streams like video (e.g. youtube, netflix) or audio (e.g. internet telephony) or the traffic depending on daytime or season cannot be modelled accurately using a poisson process. there is some derivatives of the poisson process to better model the bustiness, e.g. the compound poisson process.\nhowever, the poisson process has some nice mathematical features allowing a simpler math and therefore allowing to analytically describe queueing systems. therefore it is widely used for a first analysis or for more mathematical modelling. if a system needs to be analyzed in more detail, simulations tools (e.g. opnet) can be used. this does not lead to a mathematical formula but delivers more precise numerical results and enables the modelling of a wide variety of data source models.",
        "answer_feedback": "the question asks whether it is true that the arrivals at a node depend on previous arrivals for real internet traffic instead of whether the poisson process is a realistic model. the reasoning is correct for both questions, but the definitive answer to arrival independence is missing.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0185q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem is the fairness, because it can depend on the location of the station if you have an advantage or disadvantage in getting access to the bus and send data. this is, because to send data a station has to make a reservation on one bus and after the reservation arrives on the other bus, the station can send its data on that other bus (so reservation on one and sending on the other). therefore the location of a station has influence on the fairness because for example if the station is at the beginning it could be more likely to get a reservation to send some data than it is when the station is at the end of the bus.",
        "answer_feedback": "the response answer is correct because it identifies the correct problem in dqdb including an appropriate explanation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0275q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers can provide information in addition to the ipv6 header. they are placed between the fixed header and the payload. they are optional, they only have to be transferred if they are actually used. the fixed header remains small.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. as even the option field in the ipv4 header is optional and can be 0 bits long, there is no added advantage over the ipv4 option field in terms of unnecessary transfers. the main header remaining smaller is not an advantage in itself.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0122q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the 2 phases are slow start and congestion avoidance. cwnd indicates the number of segments that are send. each time this sent segment(s) are acknowledged, cwnd and the send segments double (=increments by one per ack) → send a sement, receive ack, increment cwnd, send 2 segments, receive ack for both, increment cwnd by 2 (because of 2 received ack), send 4 segments… exponential growth.\nthis continues until ss_thresh is reached (cwnd >= ss_thresh), or a packet is lost. if a packet is lost, then cwnd falls back to initial size 1 and ss_thresh is set to current cwnd/2. if no packet is lost but threshold reached, then don’t double amount of send segments each rtt (add 1 segment per received ack) but only add 1 segment to each incremented cwnd (linear growth).",
        "answer_feedback": "the response is partially correct because if congestion occurs, ss_thresh is set to half of the current size of the congestion window and the congestion window is reset to one, in both phases. this, therefore, also happens in phase 2.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0152q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "after the initialization, the \"slow start\" phase is entered. the cwnd is increased for every acknowledged packet, leading to an exponential increase. when cwnd >= ss_thresh, the \"congestion avoidance\" phase is entered in which the cwnd is only increased by one in every (error-free) roundtrip time. whenever a packet is lost, the ss_thresh is set to cwnd/2, cwnd to 1 and the \"slow start\" is entered again.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0184q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "dqdb describes a man structure, where every node (mostly lans) is connected with two unidirectional buses, which have a frame generator at the end. a node can reserve on one bus and then send one the other one. the problem is the reservation is depending on the location of the node and therefore you sometimes have an advantage and sometimes a disadvantage and so it is not fair.",
        "answer_feedback": "the response correctly identifies the fairness issue in dqdb and provides an appropriate explanation for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0033q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "as there is no global clock, i would not suggest binary encoding. as there is much traffic i would choose differential manchester encoding, rather than the normal one which is more susceptible to noise.",
        "answer_feedback": "as the perfect clocks are already provided, self-clocking is not required.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0276q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "they are placed between the fixed header and the payload and are used to add additional non-necessary information to the ip package. the main advantage is, that they are allowing to append new options and the fixed header stays the same.",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0361q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "the dynamic host configuration protocol  is a network management protocol.\n\nused for intranet or network service providers to automatically assign ip addresses to users.\nused by the intranet administrator to centrally manage all computers.",
        "answer_feedback": "the response is partially correct because dhcp also allows the manual and dynamic allocation of ip addresses.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0142q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start\nphase 2: congestion avoidance\n\nduring phase 1 each acknowledged segment increases cwnd by 1, which ends up doubling it every round trip.\nduring phase 1 ss_thresh doesn't change.\nafter cwnd reaches ss_thresh phase 2 begins, in which cwnd is increased by 1 every round trip until a timeout occurs.\nwhen a timeout occurs ss_thresh is set to cwnd/2 and cwnd is set to 1.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0201q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "the udp header contains four parts, the sender port, the receiver port, the packet length and the checksum. the sender port is optional and the checksum also. the packet length minimum is 8 byte.\nthe tcp header also contains a source and destination port and a checksum but has some other contents too. so four fields which are different from the udp header are the sequence number, the acknowledgment number, the hl/resv/flags and the advertised window. additional there is an urgent pointer field and some space for options. the tcp header is also larger than the udp header.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers. however, the abbreviations, such as hl and resv should be properly named.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0127q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "phase 1: slow start\nthe basic idea behind \"slow start\" is to send packets as much as the network can accept. it starts to transmit 1 packet and if that packet is transmitted successfully and receives an ack, it increases its window size to 2, and after receiving 2 acks it increases its window size to 4, and then 8, and so on.. \"slow start\" increases its window size exponentially until the slow-start threshold is reached.\n\nphase 2: congestion avoidance\nafterwards, the congestion window is only incremented by one unit if all packets from the window have been successfully transmitted. it therefore only grows linearly per roundtrip time. this phase is called the congestion avoidance phase. if a timeout occurs, the congestion window is reset to 1 and the slow-start threshold is reduced to half of the congestion window. the phase of exponential growth is thus shortened, so that the window grows only slowly in case of frequent packet losses.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0042q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding.\n1. since all users have perfect clocks, self-clocking isnt needed.\n2. good utilization of the bandwidth, so congestion is less of an issue.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0120q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "one possibilty to adress the problem of duplicate packets is to use temporarily valid tsaps. these tsap are valid for one connection only and are unique for this connection. some ports are relied to as well-known tsaps, which can cause duplicates again.\nanother possibility is to identify connections individually with a seqno. so duplicates are avoided by assigning a seqno to every connection. a disadvantage is the need to store this information in the endsystems even if they are switched of.\nanother possibility is to identify the different packets individually. so a sequential number is assigned to each pdu individually. this makes it easy to identify duplicates. a disadvantage is the higher usage of memory and bandwidth.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0418q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "10.0.0.0 to 10.255.255.255 private ip addresses\n\n127.0.0.0 to 127.255.255.255 reserved for loopback",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0034q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding because the link's capacities is limited in this senario and differential/manchester encoding require more bandwidth (0.5 bit / baud). each user have the perfect clock, therefore encoding with binary encoding is possible in this case.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0400q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "duplicate data cannot be differentiated from correct data , and it would re-execute the transaction.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0005q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would recommend tdma with reservation, since the throughput is especially good in the contention-free period after sending the reservation requests because the data can be sent continuously without collisions and the channel is fully used. \n\nfurthermore because of the reservation concept the provisioning of the line is highly adjustable because only stations with a reservation request use the channel which is extremely good for a network which should be expandable. \n\na potential weakness is that the stations need synchronized clocks which leads to an overhead.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0259q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning trees includes all routers with no circles, so the packets are not sended (infinitely) often around.\n\nif the frequently sended packets of the link state routing also contains informations on multicast groups, every is has enough information to construct a spanning tree for multicasting.",
        "answer_feedback": "the explanation behind using a spanning tree for multicast and broadcast is partially correct because though the network is loop-free, using the tree results in the minimum number of message copies required to be forwarded and not just the prevention of forwarding loops.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0328q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting allows sender to transmit concatenated sequence of multiple frames in single transmission\n\nadvantage: better efficiency\ndisadvantage: it needs frames waiting for transmission. therefore, it has end-to-end delay problem",
        "answer_feedback": "the response correctly answers all the parts of the question.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0354q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission: each character (byte) is sent one-by-one at any time and is surrounded by a start and stop bit. this allows only low transmission rates, but is a simple and inexpensive form of transmission.\n\nsynchronous transmission: here the characters are combined to frames, and headers and trailers (syn or flag) are attached. as the frames can have different lengths, protocols (character oriented, count oriented, bit oriented) are needed to be declared, defining what is part of the flag and what is part of the data. this form of transmission is more complex, however it offers higher transmission rates.",
        "answer_feedback": "the response correctly explains the differences between asynchronous and synchronous transmission.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0315q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter (cdd) is reduced to 1/10th of the original. in the given example cdd is reduced from approximately 3000m to about 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0204q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "- tcp has no packet length header, which udp does. this is not needed for tcp, because it is connection-based and once all packets have been acknowledged by the receiver, the connection is terminated. - tcp has a sequence number header, which udp does not. it is used to identify the current packet and ensure the correct order when reassembling the data at the receiver - tcp has an acknowledgement number header, which udp does not. it is used to confirm packet reception and connection setup and termination confirmation - tcp has an advertised window header, which udp does not. it is used by the receiver for flow control, indicating how much data the receiver can currently receive",
        "answer_feedback": "the response correctly states four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0031q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "in the described scenario binary endcoding should be used, because it provides a higher data throughput than manchester encoding for a given baudrate. the missing \"self-clocking\" feature is no problem, since all users have perfect clocks.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0043q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "since all users have perfect clocks. the binary encoding technique would be the most suitable one. on the strength of its efficient use of the bandwidth, this type of encoding will be very practical in congested networks.\nfurthermore it is easier and simpler method to encode the bitstreams.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0299q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "- support billions of end-systems by using longer addresses\n- coexistence with existing protocols\n- support roaming\n- reduce routing tables",
        "answer_feedback": "the response is correct as it contains accurate ipv6 objectives.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0036q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "for the given scenario binary encoding should be used.\nsince the users all have perfect clocks, the encoding does not need to to provide a self clocking feature.\nbecause the network is often congested and the links are more than saturated, a encoding with a high baud rate is preferable.\nhowever, if the network is prone to interference and noise, manchester encoding or differential encoding could be the better choice, even though it provides only half the baud rate.\nmanchester encoding could provide the benefit of \"built-in integrity codes\". this means you could identify overlapping transmissions, that interfere with each other.\nsince noise is not stated in the scenario and assuming, that a mechanism for medium access control is used to prohibit overlapping transmissions, my encoding scheme of choice would be binary encoding.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0161q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "b → c → a\n    b includes only the sequence hhhttt.\n    c includes all sequences, where there are 3 h’s. in particular the\n    sequence contained in b.\n    a includes all sequences, where there are at least 3 h’s. so in\n    particular also all sequences contained in c.",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0099q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop) <= (c to f is shorter than d to f)\nhop 2:\n(b, e, forward),\n(c, f, drop) <= (e to g is shorter than f to g)\nhop 3: \n(e, g, forward)\nhop 4: \n(g, h, drop) <= (h is the last node)",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0067q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "if all possible paths have the same load in the beginning (like a->b, a->e, a->d), then it can not be determined which path it should take for sending the packet, since all paths have the same quality, so the process may fail already. furthermore, one can argue with the fact, if both paths c->f and e->i have a current utilization of 0 packets/bytes, the packet would not even be sent to the other half of the network, which would lead to an infinite loop in the first half of the network. the destination, in our case g, therefore can't receive the packet at all.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0356q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asychronous: each charactes is wrapped by a start and stop bit. \nsynchronous: several characters are pooled to frames, defined by syns or any other type of flags.\n\nin the asychronous transmission mode multiple characters are combined in frames. the frames can be bounded by idle times, character-oriented, count-oriented, bit-oriented or by invalid characters of the physical layer. \nthe synchronous transmission is more complex, but has a higher transmission rate than the asychronous.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0041q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding is the best option in my opinion as it offers a good utilization of the bandwidth which is especially useful as the network is often congested and furthermore because the local network has a perfect clock it doesn't need self clocking. another reason would be that it's quite simple and cheap to implement.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0252q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "the purpose of reverse path forwarding and reverse path broadcast is to send (loop-free) multicast packets in multicast routing. reverse path forwarding is more reliable (it can compensate if one router of the network has an error). reverse path broadcast is more efficient, it relieves links, which are not the best path and therefore not necessary. reverse path forwarding: if the router gets a packet, it looks where the packet comes from. if it is from a link, which its (unicast) routing table would also suggest to send via this link, this link is the best path and the router distributes the packet. otherwise the packet is discarded. reverse path broadcast: if the router b gets a packet, it also looks in the routing table, if the packet comes from the best path. if it is the best path (from router a), the router looks in the routing table whether a packet is ever send from c to a. if this is not the case, the link to c is not the best path and b doesn’t send it to c. so not necessary links are relieved.",
        "answer_feedback": "the response is partially correct because both rpf and rpb explanations didn't clearly explain how the packets are forwarded in a network. additionally, the is would also look whether packets are sent from a to c in reverse path broadcast. the algorithms avoid loops not only in multicast but also in broadcast.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.6
    },
    {
        "id": "smp0167q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "least probable: b (likelihood = 0.6^3 * 0.4^3)\nsecond least: c ( we don't care about order, so there are 6!/ (3!*3!) possibilities)\nmost probably: a since it includes c but also the probability for 4, 5 or 6 h's",
        "answer_feedback": "the response is partially correct because the event c also includes the event p(b). apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0123q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "1. slow start: cwnd is increased by one with each each acknowledgement, which effectively means doubling the cwnd each rtt. when cwnd reaches ss_thresh congestion control goes to congestion avoidance phase.\n2. congestion avoidance: cwnd is increased by one each rtt.\n\neach time congestion occurs, ss_thresh is set to cwnd/2, cwnd is reset to 1 and slow-start is entered again.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0234q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "one challenge is the user mobility. in contrast to fixed and wired networks, users can move around while communicating wirelessly anytime, anywhere and with anyone. this brings additional complexity to routing mechanisms since they have to take into account that optimal paths may change from time to time and have to be recalculated. another challenge is the device portability which is a requirement for the ability of devices to connect anytime and anywhere to the network. properties like power consumption or space play a more significant role when compared to fixed and wired networks.",
        "answer_feedback": "the response is partially correct because portability is not a challenge itself. however, the description mentions the power consumption of mobile devices which is an important challenge in mobile routing.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0375q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "piggybacking means the acks are not sent separately but are inside the header of the next package that the party who is acknowledging the last package wants to send.\nso piggybacking only makes sense when both partners are sending and receiving data, i.e. we have a duplex transfer operating mode.",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0305q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "then the maximum segment length becomes 2000m, which is too long for collision recognition.",
        "answer_feedback": "the collision diameter decreases by a factor of 10 rather than becoming 2000m for a collision to be still detected.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0197q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "tcp header: 1.reliable bidirectional in-order byte stream 2.connections established and torn down 3.multiplexing/ demultiplexing 4.ports at both ends 5.end-to-end flow control 6.congestion avoidance udp 1.udp is a simple transport protocol 2.unreliable 3.connectionless 4.message-oriented 5. no flow control 6. no error control",
        "answer_feedback": "the question requirement is to identify differences between tcp and udp headers instead of general differences.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0151q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "in the first phase the cwnd starts with very small packet sizes and starts doubling the package size after each acknoledged transmission.\nafter reaching the treshhold value of package size, the second phase - congestion avoidance is active.\nnow the package size only increases linear. if a transmission fails / times out, the new slow start threshold is set to the half of the last succesfull package size.\nthe first phase is now active again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0339q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission mode: \n- each bit is transmitted individually\n- each character is bounded by a start bit and stop bit\n- simple and inexpensive\n- low transmission rate\n\nsynchronous transmission mode:\n- combine multiple bits to be transmitted at the same time\n- several characters pooled to frames -> different possibilities of frames bounding\n- complex\n- high transmission rate",
        "answer_feedback": "the response answer is correct as it correctly explains the differences between synchronous and asynchronous mode.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0070q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "using load can lead to oscillation, which means the path that seems best is always changing after the load is set to one path. \nexample: path a and path b have load 0, path a is selected, its load goes up to 1. now path b has the lower current load, so therefore the system would select path b and its load goes up ti 1. now path a is 0 again and the cycle continues.",
        "answer_feedback": "but why is oscillation a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0280q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "the extension headers are located between the regular header and the payload, the extension headers are optional and are only used of needed.\nthe main advantage of having extension headers compared to ipv4 is, that they are optional and can reduce traffic if not needed and that they allow to append new options without having to change a fixed header.",
        "answer_feedback": "the response is partially correct because the advantage part is somewhat ambiguous. extension headers are optional but they are not helpful for reducing traffic.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0164q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "event b -> event c -> event a. if we were to draw a decision tree for the six throws, we could count the number of paths that fulfill each condition. condition b would only have a single path, because it has a precise outcome attached to each of the throws. if we compare events a and c, we will notice that c describes a subset of a, thus having fewer paths to fulfill the condition. every path with exactly three h’s is included in event a, but the paths that result in 4, 5 or 6 h’s are neglected for event c.",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0221q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table holds the information which output lines/lans to use to get to a certain station. the bridge inspects the traffic (backward learning) and when the bridge receives frames with source address q on lan l it learns that q can be reached over l and creates a table entry accordingly so it can adapt to changes in topology. when the bridge gets a frame with the identical source and destination lans in its table, the frame can be immediately dropped since it was already on the right lan. when the source and destination lans differ, the frame is rerouted to the destination lan. the frame is only flooded when the destination is unknown; with this decision procedure unnecessary flooding or forwarding is prevented.",
        "answer_feedback": "the response answers all the four requirements of the question correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0291q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "- bigger adress room\n- better security \n- reduce routing tables\n- simplify headers",
        "answer_feedback": "the response is correct because all stated objectives of ipv 6 are correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0171q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service:\n-this service has no flow control and the data unit does not get acknowledged from receiver. so there are no timeouts.\nconfirmed connectionless service:\n-this service has no flow control and the data unit does get acknowledged from receiver. so there could be timeouts and retransmits.\n\nconnection-oriented service:\n-this service has flow control. is implemented in a 3-phased communication.\n1. connection\n2. data transfer\n3. disconnection",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0004q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "p-persistent csma.\nbecause it make full use of the channel's free time, it can relieve the pressure of the hardware. on the other hand, it has less collisions at high load.\nthe weakness is, it is difficult to set the p-parameter.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0085q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)(a, c, forward)(a, d, forward)\nhop2:\n(b, e, forward)(c, f, forward)\nhop3:(e, g, forward)hop4:\n(g, h, forward)",
        "answer_feedback": "the reason also needs to be provided when a packet is not forwarded to other nodes i.e. dropped by the receiver as stated in the question \"list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes.\" packets will be considered dropped if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop) ).",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "smp0335q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting is a communication protocol feature for the principle of shared broadcast mode in gigabit ethernet. \nadvantage: frame bursting has a better efficiency than carrier extension. \ndisadvantage: needs frames waiting for transmission",
        "answer_feedback": "the response is partially correct as it answers the advantage and disadvantage parts correctly, but the definition of frame bursting is too broad as it does not explain what the feature does. additionally, frame bursting can be used in other scenarios than gigabit ethernet as well.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0344q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "in asynchronous mode each byte is bounded by start- and stop bit and sent individually at any time. this is inefficient and has low transmission rate.\nsynchronous has higher transmission rate, but complex with regards to “how to detect beginning and ending of fields within a frame?”",
        "answer_feedback": "the response is correct as it answers the differences between synchronous and asynchronous transmission mode correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0270q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are optional and located between the header and the payload. \nthey can extend the ipv6 datagram by telling a router that the payload is used for identification, is fragmented or give additional information to hops.\nthe main advantages are more flexibility of messages and a reduced headersize, because they are optional.",
        "answer_feedback": "the response is partially correct because the advantages are incorrect. the header size is not reduced based on the optionality, as the options field in ipv4 could already be 0 bits long. additionally, the response does not explain what type of flexibility is gained.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0250q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding and reverse path broadcast are both broadcast algorithms that attempt to minimize the number of duplicates packets in the network compared to other algorithms like the simple flooding algorithm. the idea of reverse path forwarding is that each sender/node has an own spanning tree, but the other iss do not need to know them. the algorithm is based on a simple condition for each node. the node has to decide, whether the received packet sent over the best route, i.e. it used the edge the node would use to send it back to the sender/author or not. if this is true, the node resends this packet over all other edges, i.e. excluding the incoming one, otherwise, the packet is most likely a duplicate and it will be discarded. the reverse path broadcast goes a little further and the is sends the packet from the best route only to the nodes it is responsible for/the sender used before. if the is is on the best path between the sender and his neighbor node, i.e. it is responsible for it, it learns over time.",
        "answer_feedback": "the response correctly explains rpf and rpb and their purpose.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0245q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "one challenge are \"hidden terminals\". in this case, there are 3 nodes a, b and c and a and c cannot hear each other but a and b and b and c can. so when a sends to b due to the fact that c can't receive a c senses b as \"free\" medium and also sends to b. then at b a collision occurs which a can't detect. a is therefore \"hidden\" for c and c for a. another challenge are \"exposed terminals\". there we have 4 nodes a, b, c and d. a can reach b, b can reach a and c, c can reach b and d and d can reach c. now b sends to a and c wants to send to d. but because c signals a medium in use it has to wait, even if the medium in use is  b sending to a and a is outside the radio range of c and the waiting is not necessary. so c is \"exposed\" to b. the third challenge are \"near and far terminals\" which is about 3 terminals a, b and c where a and b are sending and c is receiving. due to the decrease of the signal strength proportionally to the square of distance the stronger signal (e.g. b's) drowns out the weaker signal (e.g. a's). the result is that c cannot receive a.",
        "answer_feedback": "in the exposed terminal description, c senses the busy channel rather than signaling it. apart from that, the answer is correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0379q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "sending must be possible in both directions in order to send data and acks (two-way-communication) and the frames must be able to contain acks.",
        "answer_feedback": "the response states both the requirements correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0030q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "differential manchester encoding should be used because it is overall more complex. \n\nsimilarly to manchester encoding, dm encoding takes advantage of splitting the interval into two, where a voltage level shift takes place (either from high voltage to low voltage or vice versa). however, manchester encoding is still too similar to binary encoding in that a 1 will always be equivalent to a voltage shift from high --> low and a 0 will always be low --> high voltage. instead, if the voltage shift occurs between intervals (either high -> low or low -> high), a 0 will be encoded. likewise, if there is no voltage shift between intervals then a 1 is encoded. by comparing the current interval to the previous interval's voltage level, a more accurate encoding technique can be realized.\n\nand unlike the binary encoding system, dm encoding does not rely on binary voltage levels to encode a bit stream. instead, merely a change in voltage level between intervals encodes the bit stream. (ex. a lack of voltage level change between the first and second interval would mean that the second bit in the stream is a 1) therefore, because the voltages only need to differ between intervals, the bit stream is less susceptible to noise/error.",
        "answer_feedback": "the preference is always for a simple solution. further self-clocking is not required here and manchester provides lower bandwidth utilization which can further complicate the congestion problem.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0232q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "network topology and access points- network topology and access points changes faster when the devices are moving around which is not the case in fixed network. security - as the network could be available even inside and outside the building, it possesses a threat to security. user mobility: the users can be moving from one network to another and want to communicate anytime with anyone without losing the network.  device portability: the device can change in a period of time but having the portability with the other device to connect anytime and anywhere to the network.",
        "answer_feedback": "the response is partially correct because the device portability is not an actual challenge beyond what is already stated in the previous challenges.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0095q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop 2:\n(b, e, forward)\n(c, f, forward)\nhop 3:\n(e, g, forward)\nhop 4:\n(g, h, forward)",
        "answer_feedback": "the reasoning behind which packets are dropped is not stated.  please go through the model solution. packets will be considered drop if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop)",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "smp0080q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "this strategy could cause problems:\nthe routing algorithm would constantly alternate between using link cf or ei, because when one of them is part of the current route, the other one seems like the better choice because it has lower utilization. so even if using only one of the links exclusively would make more sense because it may have higher bandwidth than the other one, this strategy would alternate between them.",
        "answer_feedback": "but why is alternating a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0261q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the property is, if each router knows which of its lines belong to the spanning tree, it can copy an incoming broadcast packet onto all the spanning tree lines except the one it arrived on. there is no loop in a tree. therefore in order to build a spanning tree by modifying link state routing, the loops need to be cut. assuming that a router is a vertice and when two routers are connected, there is an edge between them. after five steps of lsr, it can be abstracted as a weighted directed graph. below is the basic idea. divide the vertices in the graph into two groups, s and u. s contains vertices that has already computed shortest path. u contains vertices that the shortest path is uncertain. add following steps after regular lsr. a. originally, s only contains source vertice v, u contains the rest of them. b. pick up vertice k from u, which has shortest distance from v, put k into s. c. let k be the new intermediate vertice, changing the distances from k to the rest vertices in u. d. repeat step a and b until all vertices are in group s",
        "answer_feedback": "the response is not correct about how the link-state algorithm is modified. the link-state packet is expanded to contain multicast group information and exchange it with other nodes to calculate their multicast spanning tree. dividing the graph into two parts and calculating the shortest distance does not help in sharing the needed multicast group information of each node.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0411q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0/8 - dummy address\n10.0.0.0/8 - private network\n127.0.0.0/8 - loopback",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0191q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "depending on the location a station may not be able to make a reservation. the further a station is at the bus-head end, the less reservating frames is possible due to fifo - first in first out scheduling. the main issue is fairness as the stations do not have the same chance to access the bus.",
        "answer_feedback": "the response correctly identifies the fairness issue in dqdb and also provides an explanation for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0176q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service: transmission of isolated, independent units which are called frames. data loss is possible. l2 doesn’t correct this and only transmit correct frames.\n\nconfirmed connectionless service: no data loss, because each frame is acknowledged. timeout and retransmit is possible when a sender doesn’t receive an acknowledgement within a certain time frame.\n\nconnection-oriented service: connection over error free channel. theres no loss, duplication or sequencing errors. it also features flow control.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0239q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "the challenges are: * security:the packet of data is not much secure.through neighbor authentication, a user can know it neighboring users.for security of packet we must have to use technique of data encryption. * qos * scalability * heterogeneity * adaptation:network has to adapt to dynamic positioning of nodes.this is necessary and nodes may join the network or may leave the network dynamically. * dependability\t-",
        "answer_feedback": "the response names 5 requirements but describes only two. further, the description of security is partially correct as it does not clarify how security is a challenge in a wireless network as encryption is common in both wired and wireless communication.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.62
    },
    {
        "id": "smp0046q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding should be used, because this has the highest baud rate in comparison to the other and so we can keep the congestion the lowest. further we can implement with the bits on a higher layer a congestion control.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0386q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "the problem will occur at the receivers end which cannot differentiate between the correct and the duplicated data without given any additional information",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0308q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the diameter decreases by factor 10. the increased  bit rate leads to a reduced bit duration but the transfer speed remains the same. the result of that is a shorter maximal distance between two stations which is allowed so that collisions can still be detected.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0169q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "p(event b) is  less than p(event c)and p(event c) less than  p(event a)\nevent a is the most generic event, whereby event b and c are subsets of the probability set a. therefore, if event b or c occur, a also occurs. this makes a the most probable event. the same logic applies to c and b, whereby c is a more generic (and therefore probable) event than b.\nin detail: b occurs if the sequence hhhttt happens. this event has exactly three h's (and three t's). therefore, this event also includes event c (\"exactly three h’s\"). but, the set of valid sequences for c is bigger than c, i.e. with sequences like hththt. the sequence of the h's doesn't matter in c. furthermore, event a is also always true if c is true. but the set of a is bigger, since events like hhhhht are only in a and not in c.",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0012q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would suggest using the non-persistent csma procedure. first of all, a procedure with contention should be used to provide the fastest data transmission for the possibly high amount of devices in the future even with a high channel load.\n\nwith the non-persistent csma, the hardware of the sender does not have to recheck the network continuously, which is good in order to reduce the load of the not-so-powerful device(according to the given info).\nsecond, the performance of the throughput is the second-highest even for a large number of attempts per packet, which is good for a highly loaded channel.\n\nproblem: there may occur longer delays for the single devices than necessary. in example: the network was congested, the random timer is started and awaited, even though the network was free again immediately after the timer was started.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0193q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem with this system was the fairness. some nodes had better chanes to reserve bandwith for themselves than other nodes.",
        "answer_feedback": "the response is partially correct as it states the issue in dqdb but lacks an explanation of why some nodes have better chances of reservation rights. the possibility to reserve bandwidth depends on the distance between a station and the frame generator or the slave frame generator.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0203q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "udp is missing the sequence number, the acknowledgement number, the hl/resv/flags, and the urgent pointer fields. tcp has this fields.",
        "answer_feedback": "the response correctly states four differences between tcp and udp headers. however, the terms hl and resv should be properly named.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0137q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "there are two phases: 1) slow start and 2) congestion avoidance.\nduring the slow start (cwnd <= ss_thresh) each ack generates two packets, hence the data rate grows exponentially. in the meantime cwnd grows for each ack and when cwnd > ss_thresh, we enter congestion avoidance phase.\nduring congestion avoidance phase, the data rate doesn't grow exponentially anymore and each ack only generate one new packet. cwnd only grows until we get some timeout/congestion.\nwhenever that happens, ss_thresh is set to half of cwnd and cwnd gets resetted (ss_thresh = 0.5*cwnd; cwnd = 1).",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0329q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting is a technique where the sender waits for a certain number of frames to be concatenated into one single “big” frame and then send this “big” frame in one go. \n\nadvantage: better efficiency in data transmission, while in carrier extension introduces only trash information just to extend the frame length. \n\ndisadvantage: because the sender has to wait until the concatenation buffer is full then the big frame is only ready to send. this accidentally introduces more end-to-end delay which hampers the performance and user experience of interactive applications (e.g. live stream video, live phone and video calls, etc).",
        "answer_feedback": "the response correctly answers the frame bursting definition, its advantage and disadvantage.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0089q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1: \n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\n\nhop 2: \n(b, e, forward)\n(c, f, forward)\nhop 3:\n(e, g, forward)\nhop 4:\n(g, h, drop) -> packet drops because it only has one neighbour and node  h does not forward the message.",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.5 for reasoning (a,d, drop), (c, f, drop)",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.8
    },
    {
        "id": "smp0288q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "objectives of ipv6 are: 1.to support billions of end-systems-it has longer addresses 2.to reduce routing tables 3.to simplify protocol processing by simplified header 4.to increase security (integrated) 5.to support real time data traffic (quality of service) by flow label, traffic class,etc",
        "answer_feedback": "all five ipv6 objectives in the response are completely accurate.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0091q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a,b,forward)\n(a,c,forward)\n(a,d,drop)<=because f does not forward a broadcast packet from a to d)\nhop 2:\n(b,e,forward)\n(c,f,drop)<=because g does not forward a broadcast packet from c to f)\nhop 3:\n(e,g,forward)\nhop 4:\n(g,h,drop)<=because there is no more receiver after h",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0267q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are optional headers in ipv6 that are not limited by any size limitation as they are located in between the ip header and the data payload and therefore don't change the ip header. one header links thereby to the next header with the first header being pointed to by the ipv6 \"next header\" field. because of that flexibility, new headers may be invented as the need arises.",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0251q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "the purpose is to reduce packet duplicates due to flooding. * reverse path forwarding: the receiving router checks, if the incoming packet used the usual (proboably best) path to it. if it is the case, the packet will be forwarded to all links except the one at which the packet arrived. if a packet arrives at an unusual path (probably not the best path and a duplicate), the incoming packet will be ignored (discarded) and not forwarded any farther. * reverse path broadcast: similiar to _reverse path forwarding except _that a node gains information about the best paths between neighbouring nodes due to observation. that is, a packet will not be forwarded via every link but only via those links, which are unlikely to create more duplicates. for example a node a will not forward a packet to x coming from a node z, if it knows (due to obeservation), that there exists a best path between x and z for that packet.",
        "answer_feedback": "the response identifies the purpose of rpf and rpb correctly. the rpf explanation is partially complete because it is unclear what the \"usual path\" means and how it is determined. if a node x receives a broadcast packet from source s, node x checks its routing table to see if it would have used the same route to send a unicast packet to s, if yes the incoming packet followed the best route. the rpb explanation is also not complete as it also does not explain how nodes learn the best path between nodes, namely through the unicast routing algorithm (e.g. link state) or observing previous unicast traffic.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.6
    },
    {
        "id": "smp0199q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "1. tcp header size is 20 bytes, but udp header size is 8 bytes.\n2. tcp does flow control, but udp does not have an option for flow control.\n3. tcp does error checking and error recovery, but udp does error checking but simply discards erroneous packets.\n4. tcp has sequence number field, but udp does not.",
        "answer_feedback": "the first point is partially correct as the tcp header length varies from 20 to 60 bytes and does not have a fixed size. the second and third points are incorrect as there is no context provided for the header field related to them. the fourth point is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.38
    },
    {
        "id": "smp0371q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "a relieable in-order delivery of packets (like data link layer 2 in osi)\n\nat least an acknowledged connectionless service or an acknowledged connection-oriented service (for feedback if the packets / frames are received).",
        "answer_feedback": "the response is not directly related to the piggybacking but to sliding window protocol in general.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0358q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is a protocol which is used to configure network-data and allocate ip-adressen (manual or automatic) within a network:\nevery host can request and process ip-configurations from a \ndhcp-server. this simplifies the process of ip adress assignement and extends the functionality of the former used rarp.",
        "answer_feedback": "the response answers the definition and the usage of dhcp correctly except it does not configure network data.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0065q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "57s\nthe average arrival rate is 9 and the average service rate is 10. according to the limited buffer size 10 we can calculate pb, which means the probability that the system is full. so the probability that in the state there are less than 10 packets is 1-pb. based on the 1 minute monitoring time we can get the result 57s",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0018q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would recommend using either the non-persistent csma or the p-persistent csma with a low value for p (e.g. 0.1 or 0.05). first of all both are cost efficient (budget is tight) and using these specific csma procedures also guarantees a good throughput during high channel load. in addition to that adding new systems to the network is no problem since the network does not have to be shut down to connect additional stations to it. \none downside of this procedure would be the higher delay for the single stations.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0338q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission (byte-oriented/ block-oriented):\ndata is sent in form of byte or character. the data (byte/character) is then bounded by a start bit and a stop bit. this is considered to be the simpler and less expensive way but it only supports low transmission rates.\n\nsynchronous transmission (character-oriented/ count-oriented/ bit-oriented):\ndata is sent in form of frames. therefore, several characters are bundled to frames. the frames are defined by syn or flag. this is considered to be the more complex approach. however, it supports higher transmission rates.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0321q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting means, that the sender can concatenate a sequence of multiple frames and transmit them in a single transmission.\nan advantage is, that frame bursting has a better efficiency than carrier extension, because carrier extension extends the length of the frame from 512 bit to 512 byte but not the data and therefore ca. 90% of the frame is useless.\na disadvantage is, that while with carrier extension every frame is send immediately, with frame bursting the sender must wait until he has reached the number of frames neccessary for a transmission, e.g. 10 frames. so if you want to send 1 frame now, the sender will wait until 9 other frames arrive and then transmits the whole concatenated sequence.",
        "answer_feedback": "the response correctly answers the definition of frame bursting, its advantage and disadvantage.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0416q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "in the host block two adresses are reserved:\n- all 1´s as host acts a a broadcast address\n- all 0´s as host acts as the network",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "smp0131q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "at the beginning (during phase 1, also called slow start), the congestion window (cwnd) is set to one and duplicates with each cycle until ss_thresh is reached. once cwnd >= ss_thresh, phase 2 starts, also called congestion avoidance. here, cwnd is only incremented by one until a congestion occurs. then, the process starts again with ss_thresh = cwnd/2 and cwnd=1.",
        "answer_feedback": "the response is partially correct because it is unclear what is meant by the cwnd duplicating every \"cycle\" in the slow start phase. it is also unclear when cwnd increments in the congestion avoidance phase. the slow start phase description is missing details about how ss_thresh changes when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0313q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "collision domain diameter is the distance between the two furthest nodes. if i use csma/cd, then the distance limitation for collision domain diameter will be one tenth as large as before when i increase the speed of a network by a factor of 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0049q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "bianry encoding, since it has good utilization of bandwidth which could solve the traffic problem. on the other hand, the 3 users have already perfect clocks, the no \"self-clocking\" feature of binary coding could be neglected.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0254q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "using reverse path forwarding ensures loop-free forwarding of multicast packets. the idea behind this algorithm is: if a packet station x arrives at an is over an entry point over which the packets for station x are usually sent, this might probably be the correct and fastest route. therefore only if this is the case packets distributed over all edges. if the packet is received over another entry point it will be discarded. reverse path broadcast is a refined version of this algorithm. it differs from reverse path forwarding by the fact, that if the packets have taken the best route until their arrival at a certain node they will be forwarded to the best next edge taken from the routing table. if not, they are not sent over all edges. this is achieved by the knowledge, which other nodes usually receive their unicast packets via this note.",
        "answer_feedback": "the answer is partially correct as the purpose of rpb is not explicitly mentioned. in rpf, the optimal/best route may or may not be the \"fastest\".  in both algorithms, the packet is also not forwarded to the edge from which it was received.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "smp0073q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "according to slide 78 current \"load\" should not be used as a metric because it may lead to an \"oscillation\" of the load (meaning sender flipping paths), which should be avoided. this would lead to frequently distribution of the local information all is.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0126q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "in congestion control with tcp there are the phases slow start and congestion avoidance. during the slow start phase the number of segments sent is doubled (cwnd *= 2) starting from cnwd = 1 packet until either a timeout is detected or the ss_tresh value is reached. when the ss_tresh value is reached the phase changes from the slow start phase to the congestion avoidance phase in which the number of sent packets is iteratively increased by 1 (cwnd += 1) until a timeout occurs. if a timeout occurs in one of the two phases the ss_tresh value is set to half of the current cwnd value and the packet transmission starts again with the slow start phase with cwnd = 1.",
        "answer_feedback": "the response is correct and complete as it provides the phases' names and changes in the value of the congestion window and threshold correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0359q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is the new version of arp (address resolution protocol), basically dhcp does the same : \nthe dhcp (=dynamic host configuration protocol) is a communication protocol (for network management) on internet protocols.\na dhcp server is used for assignment : a dhcp server assigns network configurations and ip addresses to devices on a network in \na dynamic way. as a result, the devices are to work and communicate with other ip networks.\nso, dhcp simplifies installation and configuration of end systems, it can assign manual and automatic, dynamic ip addresses to devices in a network and can provide network parameter information like netmask, dns server, default router and so on.\nthe ip address assignment is for limited time available only.",
        "answer_feedback": "the definition part in the response is partially correct because dhcp is not a new version of arp. dhcp uses arp requests during the ip allocation process but they are separate protocols.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0336q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous:\n- each character is bounded by a start bit and a stop bit\n- generally low transmission rates, often up to 200 bit/sec\n- simple and inexpensive\n\nsynchronous:\n- several characters are pooled to frames and those frames are sent\n- frames are defined by syn or flag\n- more complex, but higher transmission rates",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0233q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "hidden terminal: if multiple nodes are hidden from each other, the transmission to a common node of them results in a collision at the common receiver. two nodes are hidden from each other, when they cannot sense each other (distance > detection range). near and far terminals: stronger signals drown weaker signals. that means that the distance of the nodes can influence the communication behavior because the signal strength depends on the distance to the sender.",
        "answer_feedback": "the response correctly states and describes the hidden terminal problem. the near and far terminal challenge does not specify the relation between distance and signal strength.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0348q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission:\n- each character is bounded by a start bit and a stop bit\n- simple + inexpensive, but low transmission rates, often up to 200 bit/sec\n\nsynchronous transmission:\n- several characters pooled to frames\n- frames defined by syn or flag\n- more complex, but higher transmission rates",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0008q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "non-persistent csma should be used. reason 1: it is good for the networks with a high load medium. reason 2: it offers a good throughput. weakness: the delays are longer for each single station.",
        "answer_feedback": "what is the difference between reason 1 and reason 2?",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.71
    },
    {
        "id": "smp0024q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "tcp should be used because it has a bidirectional bitstream. furthermore it provides a flow control in order to handle too musch traffic.",
        "answer_feedback": "the response is not related to the theme of the encoding type.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0159q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "you can calculate the probabilities according to the binomial distribution.event b: p = 0,013\nevent c: p = 0,2765\nevent a: p = 0,82",
        "answer_feedback": "the response does not explicitly state the order of the events but it contains the correct probabilities of all events which are sufficient to identify the correct order.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0188q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "a node a close to the frame generator can pick up a “free” token and transmit data with a higher probability than a node b far away from the frame generator if the network is highly loaded. therefore, node a has a preference when trying to send a packet compared with node b which is a fairness problem. research to improve the dqdb protocol includes bandwidth balancing schemes to increase the fairness of bandwidth allocation.",
        "answer_feedback": "the response correctly states the fairness issue in dqdb and provides an appropriate reason for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0168q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "previous defninition: \" ** \" represents power calculation, e.g. 2**2 == 4. (n¦k) means that pick up k elements from n elements, (n¦k) here is a symbol of combination.\n\nevent a: the converse-negative proposition(cgp) of event a is \"you see at most two h's\". with 1 subtractes the probility of cgp, we are able to get the result of event a.\ncalculation of event a: 1 - [ (6¦0) * (0.6 ** 0) * (0.4 ** 6) + (6¦1) * (0.6 ** 1) * (0.4 ** 5) + (6¦2) * (0.6 ** 2) * (0.4 ** 4)] = 0.7968\n\nevent b: since the proposition is \"you see the sequence hhhttt\", there is only one solution out of all possibilities.\ncalculation of event b: (1 / 6!) * (0.6 ** 3) * (0.4 ** 3) = 0.0000192\n\nevent c: you see exactly three h's, the position of each h needs to be taken into account.\ncalculation of event c: (6¦3) * (0.6 ** 3) * (3¦3) * (0.4 ** 3) = 0.27468\n\nthe likelihood in increasing order, i.e. least probable → most probable is\nevent b → event c → event a",
        "answer_feedback": "the response is partially correct because it contains the correct order of events, but the calculation part for all events is incorrect.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0212q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no this assumption does not holds for the real internet traffic because in real scenarios whenever the packet arrives then it is expected that much more packets will be received and if pick a time duration for that such as the night or day then there will be a variance in the packets arrival as we will be checking for packets during the day and which will be more also similarly for a video buffering application, the interval at which we request the packets will be different and infrequent.",
        "answer_feedback": "the response is partially correct because the arrival process' parameters can be time-dependent. in this way, the arrival rate wouldn't depend on the previous arrivals, but instead on the time of the day.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0009q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "for this scenario i would recommend tdma with reservation, since it can provide a high throughput in the contention-free period while offering a more flexible provisioning with the reservation.\ndue to the use of slot reservation, this mac can also provide good service in an expending network.\ntdma needs synchronized clocks on all systems for the time slots to work.\neven though the reservation window is contention based possibly leading to collisions, this section makes up only a small fraction of the transmission process.\nhowever, if in the reservation phase to much collisions happen, the slots will stay unused meaning a low utilization.\nin this case a p-persistent csma (/cd) would be a better fit, while p depends on the current load and number of stations and whether collision detection should be used, depends on the cable length.\n\nreasons against the other protocols:\npolling would need a centralized controller.\ntdma without reservation possibly wastes slots for systems, that don't have anything to transmit, and isn't as flexible to an increasing network size.\na token ring is expensive and only provides low throughput.\naloha in both forms doesn't provide good throughput in a high load network, since many collisions will happen.\nin csma networks with high load have also a poor throughput due to collisions.",
        "answer_feedback": "then why do you not choose p-persistent if it is better? correct though",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0003q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would use token ring, because it has good throughput even during high utilisation, which is to be expected at 20 systems and it can be expanded later, as it supports a maximum of 250 stations. but you need a central monitor.",
        "answer_feedback": "extendability might be a strong suit but it has its flaws! why is a central monitor a disadvantage?",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.71
    },
    {
        "id": "smp0183q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the mentioned problem with distributed queue dual bus is fairness. each node when it wants to send something, it has to make “reservation” on one side of a bus and then when allocated at the other side of other bus, it is able to send something. for this reason, some nodes which is located near either one or two ends of the two buses might have too much advantage and disadvantage when it comes to transmission reservation (near and far ends). only nodes which are in between may have average fairness to reach both ends of the two bus.",
        "answer_feedback": "the response correctly identifies the fairness issue in dqdb and also provides an appropriate reason for it.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0304q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter reduces by the same factor for example for a network with 10mb/s has a collision domain diameter of 3000m and when we increase the speed of the network by 10 to 100mb/s, the collision domain diameter will become 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0293q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "- support larger number of end systems than ipv4 by using longer addresses\n- reduce size of routing tables\n- simplify protocol processing by simplifying header\n- improve multicast support",
        "answer_feedback": "all four objectives of ipv6 are completely accurate.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0175q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "the 3 service classes of the data link layer are the unconfirmed connectionless service, the confirmed connectionless service and the connection-oriented service.\nthe connection-oriented service has a 3-phased communication. first the entities have to connect, then they can transmit data and after this they disconnect. there is a data flow in both directions. the sender gets an acknowledgement if the receiver receives the data, so there is no loss of data. this service offers also flow control and prevents duplication or sequencing error. \nthe other services have no connect or disconnect and no flow control. \nthe confirmed connectionless service can only ensure that there will be no loss of data because the receiver sends an acknowledgement. \nthe unconfirmed connectionless service cannot because only the sender can send data and the receiver sends nothing back.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0027q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding\n1. 3 users have perfect clocks. they  don't need a good \"self-clocking\" feature.\n\n2.binary encoding is simple, cheap and has good utilization of the bandwidth (1 bit per baud)， all users generate more traffic than the link’s capacities， so we need better  utilization of the bandwidth than manchester encoding and differential manchester encoding.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0076q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "multiple transmissions with load may lead to oscillation of the load. another problem in applying the flooding procedure is the inconsistency, i.e. varying states are simultaneously available in the network.",
        "answer_feedback": "we do not apply flooding here!\nwhy is oscillation a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0196q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "the tcp header has some additional data fields for: acknowledgment number, flags, advertised win. or urgent pointers.\nit needs more information in the header to include more features than udp.",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0053q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the differential manchester encoding might be the best option here. both manchester and differential manchester encoding have a self-clocking feature which enables users to know if a tansmission is happening at the moment (every clock cycle a change if there is an active transmission). the differential variant has a low susceptibility to noise which might be beneficial in a multi-user environment because it might lower the chances of e.g. retransmissions.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0077q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "the problem is in calculating the \"distance\" between nodes, which leads to \"oscillation\" of the load because of the links cf and ei.furthermore each node has a cpu overhead because of the changing routing tables due to \"oscillation\".",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0194q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "1. tcp has a flag for indicating that finished\n2. udp has no sequence number\n3. udp has no acknowledgement number\n4. tcp has a flag, if the data is urgent",
        "answer_feedback": "there are different types of flags available in the tcp header, but they are all within the flag header field. therefore, points 1 and 4 are similar and count as one.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0086q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)(a, c, forward)(a, d, forward)\nhop 2:\n(b, e, forward)\n(c, e, drop) not minimal spanning tree(c, f, forward)(d, f, drop) not minimal spanning tree(b, c, drop) not minimal spanning tree(c, b, drop) not minimal spanning tree(c, d, drop) not minimal spanning tree(d, c, drop) not minimal spanning tree\nhop 3:\n(e, c, drop) not minimal spanning tree(e, f, drop) not minimal spanning tree(e, g, forward)(f, d, drop) not minimal spanning tree(f, g, drop) not minimal spanning tree(f, e, drop) not minimal spanning tree\nhop 4:\n(g, h, forward)(g, f, drop) not minimal spanning tree",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0272q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers can hold additional options that are not possible in the simplified and fixed ipv6 header, replacing the options from ipv4. they are optionally placed between the fixed header and the payload. they help overcome the size limitation and allow for more options without having to change the fixed header (like we have to in ipv4).",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0155q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "1. slow start (getting to equilibrium)\neach time a segement is acknowledged increment cwnd by one.\ncontinue until reach ss_thresh or packet loss.\n2.congestion avoidance:\nif ss_thresh is set to 50% of the current size of the congestion window (ss_thresh = cwnd/ 2),\ncwnd is reset to 1 and slow start is entered.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.in the congestion avoidance phase, the cwnd is increased linearly before congestion occur is also not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0333q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting: allows sender to transmit concatenated sequence of multiple frames in a single transmission\n\nadvantage: more efficient than carrier extension\n\ndisadvantage: needs frames waiting for transmission",
        "answer_feedback": "the response answers all three parts of the question accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0117q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. to use temporarily valid tsaps\n   + easiest realization\n   - too many tsaps will quickly use up all the limited port numbers\n2. to identify connections individually\n   + each individual connection has a individual sequence number\n   - assigned sequence number are saved in endsystems. if endsystem switched off, the information disappear\n3. to identify pdus individually\n   + sequence numbers basically never gets rest\n   - higher usage of bandwidtrh and memory",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0118q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. use temporary valid tsaps: +tsap valid for one connection only -not always applicable because of process server addressing method\n2. identify connections individually with unique sequence numbers: +unique identification of connections remembered by ess -ess must be capable of reliably storing this information\n3. identify pdus individually with individual sequential numbers for each pdu: +seqno basically never gets reset -higher usage of bandwidth and memory\n(f.23, 24)",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0208q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no it does not hold for real internet traffic. take video traffic as an example. client fetches data from server and fill them in its buffer. data could come more and more if the previous of them has been transmitted and filled successfully. if not successfully, the retransmission can happen. therefore each time interval are dependent on others, i.e. they are not independent.",
        "answer_feedback": "the response is correct as it correctly associates the probability of a packet arrival happening at a node with previous arrivals at the node.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0301q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the size of \"collision domain diameter\" is dreduced by about 10 times, e.g. from ca.3000m to ca.300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0396q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "duplicates can lead to network congestion.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0399q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "duplicate packets arriving at receiver may cause a transaction to be completed multiple times.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0374q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "duplex operation",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0013q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i recommend csma/cd. due to \n1.cost efficient\n2.practically no waiting time during low utilization\n\npotential weakness :if all 20  systems try to sending，the utilization will be lower.  and as  the number of systems increases, the performance will get worse.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0322q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting enables the sender to transmit concentrated sequence of multiple spaces in a single transmission. therefore a buffer waits for a set of packets to send them all once together.\n an advantage of frame bursting is the high efficiency due to the amount of data that can be sent in one transmission. in the carrier extension only 9% user data is possible to send which leads to a low efficiency. \na disadvantage of frame bursting is the long time it takes to be transmitted. if you just want to send two packets you have to put some additional data or rubbish inside because the frame only will send if the whole frame is filled with data. the higher latency is introduced through the packing/filling of the buffer, depending on the implementation, either the two packages get stuck or transmitted with a higher latency with rubbish frames to fill the buffer.  this causes a delay. therefore the carrier extension is better to send less packages and does not lead to a delay.",
        "answer_feedback": "the response answers all three parts of the question correctly. however, 9% efficiency of the carrier extension feature is only for the worst case. the efficiency depends on the  size of actual data sent which can be between 46-1500 bytes.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0066q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "the routing could have poor performance if the traffic volume change over time. it could also have a high delay when the shortest path is high-loaded.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0072q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "it would cause problems because links / connections on the path could be overloaded or get disconnected / failed. this would result that packets could be lost or need a different path. furthermore, the current load on a link could change after the best path was found.",
        "answer_feedback": "why would a path get overloaded?\nwhen a current load on a link changes, the best path changes too, there is no problem with this.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0156q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "slow start: cwnd starts at 1 and doubles after every roundtrip till ss_thresh or packet loss is reached.\ncongestion avoidance: after this congestion avoidance is reached and cwnd grows by 1 every round trip till congestion occurs. than it gets reset to 1 and ss_thresh = cwnd /2. at this point slow start is used again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0100q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\nfrom a:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop) <= forward over b is not part of unicast a > c and a-> f\n\nhop 2:\nfrom b:\n(b, e, forward)\nfrom c:\n(c, f, drop) <= forward over c is not part of unicast a -> d, a->e and a-> g\n\nhop 3:\nfrom e:\n(e, g, forward)\n\nhop 4:\nfrom g:\n(g, h, drop) <= only link is the receiving link",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0242q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "when we have mobile routing some problems begin to appear. one of them is called “hidden terminals” and this is caused because the nodes are not within each others transmission rate, causing that they are invisible to each other and they have to communicate through a third node ,which is within range of both of this nodes, the issue with this case is that because they can´t know at first if the other node is sending something, collisions may occur. another challenge is the near and far terminals , in which if two nodes are sending signals at the same time, the stronger signal will drown out the weaker signal, making the receiver not being able to receiver the weaker signal.",
        "answer_feedback": "the response states the hidden terminal challenge correctly except that nodes communicate 'to' the common node, not 'through' the common node. the near and far terminal challenge description is incomplete because it does not mention the signal's relation with increasing distance.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0016q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "csma/cd\nrecommand reason:\n1. the csma/cd can reach high speed to transfer the medium.\n2. csma/cd can deal with collision\n\npotential weakness:\ncan not avoid collision and need to listen the link while transferring the medium.",
        "answer_feedback": "why is dealing with collisions an advantage? and why is listening to the link a disadvantage?",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.86
    },
    {
        "id": "smp0022q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would recommend non-persistent csma because it is expected that multiple stations want to send at the same time (high channel load) and it provides good throughput even during high utilization. one weakness of this mac procedure is, that they are long delays for single stations.",
        "answer_feedback": "what is another reason? you only gave 1",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.71
    },
    {
        "id": "smp0384q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "every transmission must contain an ack.",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. a duplex connection is needed, so that data and acknowledgments can be sent both ways.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0116q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. using temporarily valid tsaps:\nthis method uses tsap that are valid for only one connection which makes it easy to identify duplicates. this method is not always possible, e.g. with process server addressing the server needs a designated/known tsap\n\n2. identify connections individually:\neach connection is assigned a new seqno and end-systems remember already assigned seqno. it does not work with connectionless oriented systems and end-systems have to be capable of storing the already assigned seqno. it's easy to implement this method.\n\n3. individual sequential numbers for each pdu:\neach pdu gets a seqno assigned which results in higher usage of bandwidth and memory. they are enough seqno so that they basically never get reset.",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0144q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1 is slow start. here the sender tries to send from a small amount of packets to as much packets as possible. for each send the sender increase the amount of packets exponential until the receiver no longer acknowledge the packages. after that the phase 2 is congestion avoidance starts where the sender increase the amount of packets linear instead of exponential. this happens until the receiver no longer acknowdledge and then the slow start threshold is set to 1/2 of the congestion window size.",
        "answer_feedback": "phase 2 starts when cwnd>=ss_thresh, not when congestion occurs. \nin the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached is also not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0236q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "challenges: hidden terminals, exposed terminals, near and far terminals hidden terminals:  each terminal has its own maximal detection or transmission range. nodes a and c cannot hear each other, and the transmissions of nodes a and c may collide at node b, then nodes a and c are hidden from each other. hidden terminals can cause more collisions, waste of resources, etc. exposed terminals: assumed terminal b is able to hear a and c, c can hear b and d. if b sent to a, c wants to send to d is not a or b. at this time c must wait, indicating that a medium is being used, but a is outside the radio range of c, then c is \"exposed\" to b. there is a problem of underutilization of channel.",
        "answer_feedback": "the exposed terminal description part is partially correct because the reason behind the busy medium is incorrect. c wants to send data to d but senses the medium busy and waits. the wait is unnecessary because d is outside the range of b. therefore, c and b are exposed to each other.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0038q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the binary encoding technique should be used. because the chosen scenario doesn't need a self-clocking mechanism. the binary encoding also provides a good utilization in the network.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0011q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would choose a token ring mac due to its great throughput during high net utilization and deterministic maximal waiting times. however, delays may occur while waiting for a token and it being a bit more expensive than csma.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0247q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding and revers path broadcast are used to forward multicast packages without using loops (and therefore not creating duplicates on the way). in reverse path forwarding every node has its own spanning tree. when a package is received by an intermediate station, the station checks if it would send packages to the sender over the used link. if that is the case, then it should be the best route and the intermediate station forwars the package to all connected nodes (except the incoming edge). if it is not the case, then it gets discarded, because it is very likely a duplicate, from another node. reverse path broadcast is an improvement on reverse path forwarding. instead of forwarding packages to every node (if conditions for forwarding are met) it only forwars it to the node, from where packages would normally arrive from.",
        "answer_feedback": "the purpose of reverse path forwarding and reverse path broadcast is not limited to the multicast but also used in broadcast. in reverse path forwarding, only the sender needs to know the spanning tree, and it makes use of unicast information to forward the broadcast package. the explanation of rpb is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "smp0174q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "1.\tunconfirmed connection less service: has no flow control, connect or disconnect; sender’s frames are transmitted as it is without taking in account possible loss during transmission with no acknowledgement from receiver. suitable with communication channels with very low error rate.\n2.\t confirmed connection less service: sender’s transmitted frames get acknowledged by receiver, may result in duplicate and sequence errors; still no flow control, connect or disconnect. better reliability than unconfirmed connection less service.\n3.\tconfirmed connection oriented service: starts with connect, then data transfer and end with disconnect. uses flow control to synchronize frame sequence and prevent loss due to speed mismatch. reliable compared to 2 types of connection less services.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0192q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "depending on where a node is connected to the two busses at some spots it is more likely to be able to reserve a time slot and send something than at other spots. making fairness the biggest problem of this solution for connecting subnetworks since the probability to be able to send depends on the position in the queue.",
        "answer_feedback": "the response correctly answers the question.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0093q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward); (a, c, forward); (a, d, forward).\nhop 2:\n(b, e, forward);  (b, c, drop) from a to  c ,via b is not the shortest; \n(c, b, drop),from a to b ,via c is not the shortest; (c, d, drop), from a to d ,via c is not the shortest; (c, e, drop), from a to e ,via c is not the shortest; \n(c, f,  forward).  \n(d, c, drop) ,from a to c ,via d is not the shortest; (d, f, drop) ,from a to f ,via d is not the shortest.\nhop 3:\n(e, c, drop), from a to c ,via e is not the shortest; (e, f, drop), from a to f ,via e is not the shortest; (e, g, forward).",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0227q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table possesses information about the stations and in which  lan they are located.the bridge works in promiscuous mode, that means that it receives any frame on any of its lans and with the information stored on these frames of how the stations can be reached, it will create a table entry. in the forwarding process if the source and destination lans differ the frame will be rerouted to the destination lan (the information of where this destination is found is on the table).",
        "answer_feedback": "the response does not mention that if a packet arrived over link l from source s, it would use the same link l to forward packets destined for s. the response does not state the benefit of using the bridge table information. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0092q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop 2:\n(b, e, forward)\n(c, e, drop) <= because e never send a packet to a from c\n(c, f, forward)\n(d, f, drop) <= because f never send a packet to a from d\nhop 3:\n(e, g, forward)\n(e, f, drop) <= because f never send a packet to a from e\n(f, e, drop) <= because e never send a packet to a from f\n(f, g, drop) <= because g never send a packet to a from f\nhop 4:\n(g, h, drop) <= h is the last node and there is no other link",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0370q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "the receiver must have data to send back to the sender so he can attach the ack information to that data. if he has no data to send, the service can be jammed. to prevent this, a receiver timeout can be added so that after the timeout has expired and no data was sent, an ack packet is sent independently",
        "answer_feedback": "the response does not answer the underlying requirement for piggybacking. the response states a possible situation in piggybacking and how to overcome it.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0007q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "my choice would be csma/cd since it enables the ability to add up stations easily and also has almost no waiting time in times of low utilization. \none downside of csma/cd is, for increasing distances, the efficiency is deacreasing.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0063q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "from the problem we recognise that the number of packets arriving is lambda=9 pkts per second and number of packets being serviced is µ=10 pkts per second. dividing the lambda by µ gives us the utilization. in the case of an equilibrium in a finite buffer, the probability of having less than 10 packets can be calculated from the formula of the blocking probability (slide 31). as this formula would give us the probability of the system being full, we would then need to subtract it from 1. finally, this would then be multiplied by 60 (as 1 minute contains 60 seconds) to give the number of seconds in which we expect the system to have less than 10 packets in the queue. the calculated blocking probability is 5,08% and therefore the probability of the system not being blocked 94,92%. 94,92% of 60 seconds is 56,952 seconds which is the estimated time of the system having less than 10 packets in the queue.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0058q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "the given example is a finite buffer case, so a m/m/1/10 queue. with the given numbers, the utilization rate is 9/10 = 0,9. so if on an average 9 packets arrive and 10 can be served, there should never be 10 packets waiting in the queue. however, by calculating the blocking probability (the probability that the system is full) with the given formula, pb = 0,0508 which is ca. 5%. so there is a 5% probability, that the system is full and 10 packets are waiting in the queue. for 1 minute (60 seconds) 5% are 3 seconds. if i say that the system is in a state with 10 packets waiting in the queue for 3 seconds, i would expect the system to be in a state with less than 10 packets waiting for 57 seconds.\nif i take a look at the system throughput and insert the values in the formula, the result is 8,5428‬. this means 9-8,5428 = 0,4572 packets don't make it per second and therefore 0,4572*60 = 27,432 packets are dropped per minute. if 9 packets arrive per second, 27,432/9 = 3,048 seconds in which the system is full. this leads to the same conclusion as above, that the system is for ca. 57 seconds in a state with less than 10 packets waiting.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation. the additional validation is also correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0225q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "transparent bridges store destination addresses and start with an empty forwarding table.this table is populated by using backward learning (once the bridge receives a frame from an unknown source over router x, it stores the address information of the source). whenever a frame is sent to an unknown destination (no table entry), that frame is then flooded and the destination responds to the bridge to create a table entry. transparent bridges are invisible to other components during the forwarding process, thus simplifying other components.",
        "answer_feedback": "the response has the following errors a) transparent bridges store not just the destination but also the corresponding outgoing lan along with the timestamp. b) the stated backward learning process is incorrect. c)yes, the transparent bridges are invisible but that is not the benefit derived from using selective forwarding instead of flooding.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0097q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "(sender, receiver, drop) \nhop 1:\n(a, b, forward)(a, c, forward) \n(a, d, forward)\nhop 2:\nnode b: \n(b, c, drop) <= c is not on the best path to a\n(b, e, forward)\nnode c:\n(c, b, drop) <= b is not on the best path to a\n(c, d, drop) <= d is not on the best path to a\n(c, e, forward)\n(c, f, forward)\nnode d:\n(d, c, drop) <= c is not on the best path to a\n(d, f, forward)\nhop 3:\nnode e:\n(e, f, drop) <= f is not on the best path to a\n(e, g, forward)\nnode f:\n(f, e, drop) <= e is not on the best path to a\n(f, g, forward)\nhop 4:\n(f, h, forward)",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0395q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "if you have too many duplicates the performance goes down and the network gets overloaded.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0258q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "-the property of spanning trees, that it is a subset of subnets including all routers with no loops, makes them appealing for broad- and multicasting.   -if link state routing is used and each is/router knows the complete topology, including which hosts belong to which groups,then the spanning tree can be pruned  from bottom of each path to root, all routers are removed that do not belong to the group.",
        "answer_feedback": "the response correctly identifies the spanning-tree property that makes it appealing for broadcast and multicast. the second part does not answer how the link-state is modified. it assumes hosts have already discovered which nodes belong to which group, which is not correct. in the link-state additional multicast-group information is added and send to all other nodes.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0229q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the forwarding table maps stations to lans and has a timestamp for each of its entries.\nwhen the bridge receives a frame with the source address q on lan l in the backward learning phase, it adds a table entry q can be reached over l. if this entry already exists, the timestamp is updated, the timestamps are used to regularly delete old entries.\nwhen the bridge receives a frame in the forwarding process, it looks up the lan of the destination. if the source lan and the destination lan differ it reroutes the frame to the destination lan. if the destination address is not available in the forwarding table the packet is flooded.\nthe benefit of this is that the bridge is not visible to other components in the network, this simplifies the other components.",
        "answer_feedback": "the stated benefit is related to transparent bridges in general, but the question asked for the benefit of using bridge table information during forwarding, which is reducing duplicates. additionally, there is one more condition during forwarding where the packet will be dropped when the source lan = destination lan. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0200q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "sequence number, acknowledged number, urgent pointer, advertised window",
        "answer_feedback": "the response is partially correct as it does not state whether these fields exist in udp or tcp.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0216q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table holds information about which device/system can be reached on which lan. the table initially is empty and during backwards learning, the bridge monitors each frame, checks its source address and creates a new entry in the table with the source address and the lan from which the frame arrived (if necessary).  when receiving a frame, the bridge checks its table to determine if the receiver is on the same lan as the sender. if that is the case, the frame is dropped by the bridge, because bridging in not needed. if the receiver is on a different lan, the bridge forwards the frame to the correct lan, if the bridge doesnt know which lan the receiver is on, it tries to find that out by using flooding.",
        "answer_feedback": "the response does not mention the benefit of using the bridge table in selective forwarding. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0337q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "in the asynchronous transmission mode each character is bounded by a start bit and a stop bit. in the synchronous transmission several characters are pooled to frames, that are defined by syn or flag.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0044q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding. beacause it has a good utilization of the bandwidth.",
        "answer_feedback": "the response does not provide the second reason behind using the binary encoding in the given scenario which is the lack of need of self-clocking making binary encoding a better option.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0389q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "without additional safeguards duplicate packets could trigger an action (i.e. bank transfer) a second time.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0366q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "if you send data in both direcions, you can add the acknowledgment ,for earlier packages, on the next data package.",
        "answer_feedback": "the response identifies the underlying requirement duplex connection correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0388q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "without additional means the receiver\ncannot differentiate between correct\ndata and duplicated data.",
        "answer_feedback": "the response is correct. the response can also state what will be the consequence in such a scenario.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0186q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the main problem with dqdb is fairness. while stations in the middle might have a chance of 50% to send data, stations at the beginning or at the end can have advantages/disadvantages depending on the situation.",
        "answer_feedback": "the response correctly identifies the fairness problem in dqdb which is due to the station location.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0006q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would recommend using csma/cd. carrier sense is useful when the channel has a high load since the necessary overhead gets really small in comparison to the amount of prevented collisions. cd is also useful since it reduces the wasted time after a collision which is important since high load means more collisions. the weakness of the procedure is that it scales badly with range because the maximum range is dependend on the frame size and vice versa.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0244q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "1. hidden terminals: for example there are 3 nodes a, b, c. a cannot hear c and vice versa, and b is located between a and c. b can hear a and c. when a sends to b, c still thinks that b is free, thus start sending to b as well. this results in a collision in b. 2. near and far terminals: assume there are 3 nodes a, b, c. b and c are located near to each other, while a is located farther from them. when both a and b send to c, b's stronger signal drowns a's weaker signal, thus making c cannot hear/receive a.",
        "answer_feedback": "the response correctly states two challenges of mobile routing.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0010q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "personally i would recommend token ring\npro:\n1. the token ring can guarantee a good throughput during high utilization.\n2. even all stations wants to send at the same time, the maximal waiting time is fixed.\ncontra:\n1.it required a central moniter to avoid lost token, and costs more when adding new stations.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0413q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "class a:\n1.0.0.0 up to 127.255.255.255\nreserved addresses:\n(1-126).0.0.0\n(1-126).255.255.255\n127.0.0.0 to 127.255.255.255 (loopback adresses)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0273q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are headers that can provice additional information for a packet. they are located between the fixed header field and the payload.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. the advantage is missing in the response.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0060q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "if the equilibrium has been already reached then assuming that the packets during this 1 minute are evenly distribute, the system would be most of the time in the state where less than 10 packets wait in the queue.\nwe calculate the probability that there are packets p(0) for 0 -9 using this (1-r)^n-1\nthen we",
        "answer_feedback": "the first step of calculating probabilities for 0, 1, …, 9 packets to be in the queue is correct, but it is incomplete. additionally, the final step of multiplying it with the time frame to receive the expected number of seconds is missing in the response.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0075q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "the \"load-metric\": choose the path with the lowest utilization would lead to an oscillation between different path options. everytime a path is choosen and used afterwards its utilization goes up and thus a differet path is chosen. this requires a lot of computational overhead since the path will be constantly evaluated.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0222q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table assigns each adress the bridge knows about to a network. when the bridge is asked to forward a packet to a receiver, it looks at the table to see to which network it has to send the packet. that way packets that have the same source and destination network can be ignored by the bridge and packets with a different source network can be sent on the direct path to that network. initially the table is empty, but the bridges listens to all packets of the networks it is connected to and  whenever a packet is sent, the bridges wirtes an entry into its forwarding table containing the sender adress and the its network. if the bridge is asked to send a packet to an adress it has no entry for, it floods the packets in all other connected networks.",
        "answer_feedback": "the response does not mention the benefit. additionally, the table contains station, outgoing lan, and the timestamp which is not clear from the first line. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0220q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table holds the information to what lan/other bridge a package should be send to in order to reach its destination. \n\nif a frame is received and\n- its destination lies in, or is routed over the over the same lan from where it is received it is dropped.\n- the destination is unknown the network is flooded\n- otherwise the package is rerouted to the next lan according to the table.\n\nthis makes the bridge self sufficient and other components of the network does not need to know about the bridge. \n\nwhenever a frame is received the bridge knows that the source can be reached over the incoming lan and creates a table entry or updates its table accordingly. \nto update for changes in the topology a timestamp is used for each entry and refreshed for each corresponding received frame. if a timestamp gets to old it is assumed that the entry is valid anymore and flooding is used the next time a frame with a corresponding destination is received.",
        "answer_feedback": "the response does not mention the benefit of using the bridge table in forwarding packets, i.e. fewer duplicates. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0079q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "yes, taking the current load into account can lead to route flipping, i.e. packets of the same connection take different paths to the same destination.\nif such a flip occurs while nodes a and g are communicating with each other, a higher delay due to packet reordering might be the case or - if the receive window is too small - retransmissions may be necessary.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0262q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "properties of spanning tree for broad- and multicast:  * the spanning tree does not have any cycle  * a connected graph can have more than one spanning tree  * all possible spanning trees of the graph have the same number of edges and vertices  * the spanning tree is minimally connected, means it generates less complexity modifying link state routing to construct a spanning tree:  * all is sent link state packets periodically containing information on distance to neighbours, information on multicast groups, which will be broadcasted to all others  * each is calculating a multicast tree from the now locally available and complete state information  * based on the information about the multicast tree is determines the outgoing lines and on which packets have to be transmitted",
        "answer_feedback": "the response correctly identifies the spanning-tree property that makes it appealing for broadcast and multicast and how the link-state algorithm is modified to construct a  multicast spanning tree.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0198q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "-    since udp is a simple protocol that actually sends ip packets with limited header additions to the receiver where the packet is forwarded to the application directly, i.e. w/o reordering, etc. the udp header consists only of \n     essential needs for data transmission, i.e. a sender and receiver port, packet length, and an optional checksum.\n-    in difference to that tcp it is more complicated, since the goal is to receive exactly the same data as transmitted by the sender, i.e. fully complete and in the right order of the packets. to achieve a reliable connection some \n     additional parameters vs. udp have to be added in the header:\n      o\tsequence number: to get the right order of the packets\n      o\tacknowledgment number: needed together with sequence number for connection setup to get the starting sequence number (3-way handshake)\n\t        o\tvarious flags, e.g. syn-flag for 3-way handshake\n      o\tadvertised win. or win: needed for flow control",
        "answer_feedback": "the response correctly identifies four differences between tcp and udp headers.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0177q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "the data link layer offers these :\n\n-unconfirmed conn.less service ->  no flow control , no connect or disconnect , sender will never get an acknowledgement from receiver (radio/broadcast).\n\n-confirmed conn.less service -> no flow control, no connect or disconnect , duplicates and sequence errors may happen due to “retransmit”\n\n-the connection oriented service -> no loss, no duplication, no sequencing error ,flow control  (3phased communication : connection, data transfer and disconnection)",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0001q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would choose csma/cd. you can easily add up stations, it is cost efficient and has practically no waiting time during low utilization. on the downside, if distance increases, efficiency of csma decreases.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0278q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "the extension headers are optional additions to the fixed header. they are located between the fixed header and the payload.\nas a main advantage compared to ipv4 the optional headers allow to append new options without needing to change anything in the fixed header.",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0298q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "- extending the address space of ipv4 (longer addresses), to support billions of end systems.\n- simplify protocol processing (simplified header)\n- increase security (security means integrated)\n- allow multicast",
        "answer_feedback": "the response is correct as all four ipv6 objectives are completely accurate.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0215q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table bridge holds information of the following: table: station → lan. this means it stores information on how to reach a certain source address and over which lan it can be reached. this table is updated with backward learning. the bridge works in promiscuous mode and receives any frame on any of its lans. the bridge receives frames with source address q on lan l. this means q can be reached over l. this information is then stored in the table. in the forwarding process this can be used to forward it to the next bridge which then can forward it according to its own table. the benefit of that is that an urgent packet can be directly forwarded without any routing required.s",
        "answer_feedback": "the response incorrectly explains how this information is used in the selective forwarding and the stated benefit is also incorrect. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0173q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "unconfirmed connectionless service (=frames are transmitted as independent units --> data can be lost)\nconfirmed connectionless service (=frames still transmitted independently but with acknowledgement)\nconnection oriented service (=3 phases: connection --> data transfer --> disconnection)",
        "answer_feedback": "the response answers the services' names and differences correctly.  but there is no common theme of the differences between them. the last point should also discuss the presence or absence of acknowledgment.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0409q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0 - 0.255.255.255\n\n10.0.0.0 - 10.255.2555.255\n\n100.64.0.0 - 100.127.255.255\n127.0.0.0 - 127.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0113q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "-1- to use temporarily valid tsaps (unique ports).\nadvantage:  it can eliminate the need for duplicate because we use unique port each time.  \ndisadvantage: require large number of unique ports (names) for some period of time.\n\n-2- to identify connections individually.\nadvantage: git rid of duplicate between different connections by assigning each of them a sequence number.   \ndisadvantage: end systems must be capable of storing  sequence numbers (need storage for that ) as well as it is more complicated because if the connection is lost we need to remember what happened in the past (store information)\n\n-3- to identify pdus individually:\nadvantage:  assign a seqno for each packet for certain time, after this time i can reuse this seqno and drop  any duplicate packets. \ndisadvantage: higher usage of bandwidth and memory",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0387q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0059q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "less than 60 seconds, more than 50 seconds (50-60 seconds),\nbecause the buffer size has 10 and 9 packets go in 10 packets go out. the buffer size of 10 is never exceeded.\n\n- steps involved :\n1.arrival process: how customers/requests arrive?(time between requests ,inter-arrival time)\n2.service process: how much demand do requests generate?(service time of single requests)\n3.how many places in queue?\n4.how many service stations?\n5.how are queues processed?(first-come-first-serve (fcfs), shortest job first, priority queue, and so on)",
        "answer_feedback": "the required justification is missing and a broad time interval is provided but the precise time in seconds was expected.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0369q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "before using piggybacking extension, there should be duplex operation. furthermore, a new packet should arrive quickly then the acknowledgement is piggybacked onto it; otherwise, if no new packet has arrived by the end of this time period, the data link layer just sends a separate acknowledgment frame. \n\nalso, the sliding windows protocol will utilize the bandwidth of the communication channel with piggybacking, frames may contain implicit acknowledges. for example, the intuitive seqno. is 0, then the next seqno. and the next ack-seqno to be expected is given.",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0025q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "um die bandbreite des überfüllten netzwerks perfekt auszunutzen, sollte binary encoding verwendet werden. dieses ist einfach und günstig zu realisieren und ermöglicht 1 bit per baud. voraussetzung ist dabei der perfekte takt der nutzer, da binary encoding kein self-clocking-feature besitzt. (diffenrential) manchester encoding ist komplexer und ermöglicht nur 0,5 bit per baud.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0357q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is a network management protocol that is primarily used to automatically assign an ip address to each device/host on a network so they can communicate with other ip networks or endpoints in the network.",
        "answer_feedback": "the response is partially correct because the dhcp usage part is not specific enough. dhcp is used to assign automatic, manual, and dynamic ip addresses in a network.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0323q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "when using frame bursting within a shared broadcast mode, the stations wait until they have a min. number of frames to send and then send them all at once in a single transmission as a sequence of multiple frames. it is more efficient as carrier extension, especially if the station has continiously a lot to send. otherwise the frames have a lot of waiting time to be ready for a transmission.",
        "answer_feedback": "the response correctly explains the frame bursting concept, an advantage and a disadvantage.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0355q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous: \n•\teach character is framed by a start bit and an end bit\n•\tslow transmission\n•\tno gaps between data\n\nsynchronous:  \n•\tcharacters are pooled in frames, which are defined by flags or syns (synchronous idle characters)\n•\tfast transmission\n•\tgaps between data",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0302q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter decreases by the factor of 10. that means:\nnew collision diameter = old colision diameter / 10",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0107q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. use temporarily valid tsaps\nadvantage: simple to implement almost no additional overhead\ndisadvantage: “well-known” tsap's exist with which the server is addressed, so changing tsap's is not possible in this situation\n\n2. identify connections individually\nadvantage: distinction is made at connection level and not at packet level, so less overhead\ndisadvantage: the end system has to reliably keep a record of connecion-seqno pair\n\n3. identify pdus individually\nadvantage: able to handle duplicates and ordering of packets \ndisadvantage: the range of sequence numbers could be insufficient and cause duplicates if the packet rate is very high and/or the \"lifetime\" of packet is very long.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0274q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are the way to put additional information in the packet and are placed between fixed header and payload. the main advantage compared to ipv4 is that they are optional and extensible, so they don't consume additional space and can be modified easily later on (should the specification change).",
        "answer_feedback": "the response answers the description and location of extension headers correctly. as even the option field in the ipv4 header is optional, there is no added advantage over the ipv4 option field in terms of space consumption.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0324q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting is used to increase the throughput of data in a network without changing the cables or connection within it.\nthe wait time is used by the clients to burst up a sequence of up to three packets, then they take their waiting period.\nit should not be used with more than 3 clients because too much data can kill the throughput for the whole network.\n\nadvantage:\nbetter efficiency\n\ndisadvantage:\nneed frames waiting for transmission",
        "answer_feedback": "the response answers the advantage and disadvantage part correctly. however, the definition is incorrect as it contains details, such as a maximal burst of three packets and a recommendation not to use it with more than 3 clients, that do not hold for frame bursting in general.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0098q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop 2:\n\n(b, e, forward)\n\nb would not forward the packet from s to c because b knows that from c to s the packet would never go through b\n(c, f, forward)\nsimilar reason, c would not forward the packet from s to d and s to b\nd would not forward the packet from s to c and s to f\nhop 3:\n\n(e, g, forward)\ne would not forward the packet from s to c and s to f\nf would not forward the packet from s to c and s to e\nhop 4:\n(g, h, forward)\ng would not forward the packet from s to f",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "smp0307q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter is decreased by the same factor, the network speed is increased by, i.e. if the collision domain diameter in a 10mb/s network was 100m, the collision domain diameter in the same network with 100mb/s would be 10m. \n\nthis is because the sender still must be able to recognize a collision during simultaneous sending.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0068q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "on a network with strong load fluctuations, finding the best path can create a ping pong effect, when the load on a chosen path increases, maybe causing the routing to not terminate. this also can result in flipping paths. this is called oscillation.additionally, utilization with sent packets/bytes is not relative to the link capacity, meaning, e.g., a half used 10gbit/s link would be less likely choosen to a fully used 1gbit/s link.\nin low latency scenarios with low bandwidth need, a connection with many hops but with low current load would be preferred, resulting in a probably higher latency.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0377q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "we require atleast a (semi)duplex data transfer",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0281q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers in ipv6 contain supplementary (additional) information used by network devices to decide how to direct or process an ipv6 packet and they are located between fixed header and payload. they allow to append new options without changing the fixed header.",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0090q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop 2:\n(b, e, forward)\n(c, f, forward)\nhop 3:\n(e, g, forward)\nhop 4:\n(g, h, drop) <= h has only one neighbor (g) from which it got the message",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop)  will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0000q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "due to the expected channel load being high, there is not necessarily the bandwidth available to coordinate access to the channel. thus a medium access procedure based on random access should be chosen. with random access and a high channel load also the problem for collision arises and handling of collision detection becomes necessary.\ni would recommend using csma/cd as it has (1) a low overhead and (2) utilizes the bandwith to its fullest when possible. one weakness of csma/cd is the edge case of possible long waiting times when short frames are transmitted of very long distances which renders the built-in collision detection essentially useless.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0119q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. use temporarily valid tsaps\n+ easy and quick\n- does not identify the unique packets inside a connection.\n\nfolie 23 / 10 transport layer",
        "answer_feedback": "only one method mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.5,
        "normalized_score": 0.33
    },
    {
        "id": "smp0087q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, drop) <= c will forward to f because c has a shorter distance to f than d to f\nhop 2:\n(b, e, forward)\n(c, f, drop) <= e will forward to g because e has a shorter distance to g than f to g\nhop 3:\n(e, g, forward)\nhop 4:\n(g, h, drop) <= h can not forward anywhere",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0414q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "according to slide 45 of the lecture \"internet protocol: ip addressing – interior and exterior gateway protocols\", following adresses are reserved:\nreserved for current network:0.0.0.0 - 0.255.255.255\nreserved for loopback adresses to the local host:127.0.0.0 - 127.255.255.255\nmoreover, the first and last adress of every network can't be used, because they are for network and broadcast: (1-126).0.0.0 and (1-126).255.255.255.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0331q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting allows sender to transmit concatenated sequence of multiple frames in a single transmission.\n\nadvantage as compared to carrier extension is:\n-better efficiency\n\ndisadvantage as compared to carrier extension is:\n-it needs frames waiting for transmission",
        "answer_feedback": "the response gives the correct definition of frame bursting, including an advantage and a disadvantage.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0162q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "least probable --> most probable\nb,c,a\n\np(b) = 1 * 0,6^3 * 0,4^3 = 0,0138\np(c) = (6 over 3) * 0,6^3 * 0,4^3 = 0,2765\np(a) = p(k=3)+p(k=4)+p(k=5)+p(k=6) = 0,8208",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0157q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "least probable -> b -> c -> a -> most probable\n\nevent b is a fixed sequence, so there are no variations possible to increase the likelihood of the event happening. it is therefore the least probable of the three events.  \nevent a has to be more probable than event c, because it includes all results of event c, and more.  \nc's sample space is a subset of a's sample space, and b's sample space is a subset of c's sample space, meaning that a is the most likely event and b the least likely.\nwith events a and c being more probable than event b, and event a being more probable than event c, the order is clear.",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0341q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "in asynchronous transmission, each character contains a start bit as prefix and a stop bit as suffix.\nin a synchronous transmission, several characters are grouped together in a frame, which are defined by a syn or flag.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0226q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the table holds the infromation which source can be reached over which lan. during the backwards learning process the bridge creates table entries, when it recieved a frame. when it gets a frame from source x over lan y, a new entry will be created that x can be reacher over y. during the forwarding process the bridge deciedes based on the information table over which lan the frame should be routed (in case the source an the destination lan are the same, the packet can be dropped). if the table does not hold any information about the destination point, it will be flooded. since the bridge keeps track of which lan contains which station (mac address) it usually only has to forward a frame to the destination lan containing this station without having to send it to all connected lans.",
        "answer_feedback": "the response answers all the four requirements of the question correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0295q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "ipv6 aims to:\n- support billions of end systems, through longer adresses;\n- reduce routing tables;\n- simplify protocol processing, since headers have less fields;\n- provide multicasting;\n- be open for change in future, through extension headers.",
        "answer_feedback": "all the objectives of ipv6 mentioned in the response are completely correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0139q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phases of congestion control:\n1) slow start\n2) congestion avoidance\ncwnd is incremented by one when a segment is acknowledged and\nincreasing (exponentially bc more and more segments are sent in same time interval) until it reaches ss_thres or until a packet is lost. \nwhen ss_thresh is reached only one segment is sent per roundtrip time-> cwnd increses not as fast as before.\nwhen congestion occurs ss_thres is reduced by 50%of cwnd and cwnd is reset to one and slow start is repeated until proper sending rate is discovered.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0279q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are optional fields in ipv6 address, placed between the header and the playload. the main advantage compared to ipv4 is that extension headers allow for extra information to be headed, overcaming the address size limitation",
        "answer_feedback": "the response is partially correct because the advantage part is somewhat ambiguous. extension headers help to overcome the fixed header size instead of the address size of the ipv4 packet.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0287q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "- support more end-systems by using longer addresses\n- reduce the size of the routing tables\n- simplify the protocol, to allow routers to process packets faster.\n- integrate security\n- provide multicasting\n- support real time data traffic",
        "answer_feedback": "all six ipv6 objectives are completely correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0319q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter will be increased.",
        "answer_feedback": "the response is incorrect as it states that the diameter increases. instead, for collisions to be detected, the diameter decreases by a factor of 10.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0187q011",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "the problem with \"distributed queue dual buses\" is the fairness problem. the question that comes up here is how it can be fair, that everybody gets the same access to the data, or respectively depending on the location does it makes a difference in terms of fairness.",
        "answer_feedback": "the response correctly answers the question.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0078q004",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "using current load could be not the lowest cost path.",
        "answer_feedback": "but this is no problem at the receiver end",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0257q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning trees are appealing to broad- and multicasting scenarios, because they allow the packets to only travel one path (except travling backwards). this removes the need for looking up specific tables as in rpf / rpb.",
        "answer_feedback": "it is true that there is a unique path between nodes but that not only does away with the need to look at routing tables in rpf/rpb but reduces duplicates by removing loops(unnecessary links). no explanation was provided for modifying the link-state algorithm to construct a  multicast spanning tree for nodes.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0104q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. tsap only valid for one connection; some tsap are well known\n2. identify each connection by seqno; endsystem must store this information\n3. identify each pdu by seqno; higher usage of bandwidth and memory",
        "answer_feedback": "few advantage and disadvantage are missing.",
        "verification_feedback": "partially correct",
        "max_score": 1.5,
        "normalized_score": 0.67
    },
    {
        "id": "smp0039q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding should be used here. \nthere is no need for \"self-clocking\" when the users have perfect clocks.\nit utilizes the full bandwith.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0390q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "without additional measures in a network duplicate packets can not be differentiated from the correct packets and therefore a transaction would be re-executed by the duplicates.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0057q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first we note down some parameters: there is\na buffer size of n = 10,\nan arrival rate of λ = 9 packets per second,\na serve rate of μ = 10 packets per second,\na utilization of ρ = λ / μ = 0.9\n\nnow we can use n and ρ with the very last formula on slide 30 to calculate the probability p_n of the system being in a state where there are n packets waiting in the queue. we're interested in the sum of all probabilities except for the case n = 10, i.e. we can either calculate p_0 + p_1 + ... + p_9 or simply calculate 1 - p_10. finally we have to multiply the result by 60 seconds to find out to how many seconds of a minute this percentage corresponds to. so the system spends\n(1 - p_10) * 60 seconds = circa 56.951 seconds\nin a state in which there are less than 10 packets waiting in the queue.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0294q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "some of the objectives are: support billion of end-systems, reduce routing tables, simplify protocol processing, increase security, support real ti,e data traffic, provide multicasting, support mobility, be open for change, coexistence with existing protocols",
        "answer_feedback": "all the ipv6 objectives mentioned in the response are completely accurate.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0330q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "frame bursting is a shared broadcast mode of gigabit ethernet which concatenates multiple frames and send them in one transmission. \ndisadvantage: frames must wait for transmission until enough frames are queued for sending so that the minimal length is achieved\nadvantage: better efficiency because in carrier extension mode short frames are extended with non-sense bits to achieve the minimal transmission length",
        "answer_feedback": "the response correctly answers all the parts of the question.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0397q025",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "they congest the network by creating unnecessary traffic.",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0047q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "cdma\nin cdma, all the stations can transmit data simultaneously. it allows each station to transmit data over the entire frequency all the time. multiple simultaneous transmissions are separated by unique code sequence. each user is assigned with a unique code sequence. which means the rate of data is high.",
        "answer_feedback": "the question asks for the type of encoding to be used, not for access types.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0320q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the “collision domain diameter” is the distance two station can have and still detect a collision while sending. it depends on the minimum frame size, the speed of the signal through the medium and the bit rate of the network. if the bit rate increases while nothing else changes in csma/cd a frame is transmitted in less time than before. in this time the signal travels a shorter distance thus decreasing the “collision domain diameter”. if the speed of the network increases by a factor of 10 the “collision domain diameter” shrinks by a factor of 1/10",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0141q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase1 slow start:\nevery received ack increases the cwnd by one until the threshhold of ss_thresh.\nphase 2 congestion control:\nwhile avoiding congestion, every rtt increases the cwnd by one. when a congestion occurs the ss_thresh is set to half the current window size. (cwnd) and cwnd are set to 1 and we move back to phase 1.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0202q012",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "1. udp is connectionless and the tcp is connection oriented.\n2. udp does not control the errors, this means that if there was a with the order of the packets or one of them got lost, the udp won´t correct anything and will send it exactly the same to the application layer. instead, the tcp corrects all the errors and transmit the packets reliably.\n3. the udp needs few resources. the tcp instead has higher resource requirements for buffering, status information and timer usage.\n4. the udp transmission is fast because it is connectionless. the tcp instead needs to wait for the connection establishment and the disconnection to send any message.",
        "answer_feedback": "the response is incorrect as the question asked for the differences between headers, but the answer enumerates differences between tcp and udp protocol instead.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0284q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "ipv6 is made for supporting more addresses allowing billions of end-systems. it also gives the possibility to increase security and to simplify protocol processing. additional ipv6 provides multicasting beneath a few other objectives.",
        "answer_feedback": "the response contains four correct objectives of ipv6.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0015q001",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would recommend the company to set up their lan using csma/cd. i see this medium access procedure as the most suitable for this scenario because it is cost efficient, which is great if the funding is tight, and also it is possible to connect new stations in the future without any downtime. a weakness of this procedure however is that the more the system is used, the more collisions occur and therefore, the throughput decreases. accordingly, in addition to my recommendation i would tell the company to monitor the throughput as more stations join the system. in the future, they should consider changing to token ring at some point as the throughput with this method performs better with more stations.",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 3.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0385q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "to be able to take advantage of the piggybacking extension in the sliding window protocol, a full duplex communication channel with both parties actively sending messages is required. otherwise, the implicit acks cannot be added to outgoing data frames.",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0256q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "all intermediate stations periodically have to send link state packets via broadcast to all others. the link state packets contain the distance to the neighbors and additional information about the multicast group.  each is then calculates a multicast tree on the locally available data and determines the lines on which packets must be sent.",
        "answer_feedback": "the response does not mention the spanning-tree property that makes it appealing for broadcast and multicast. the explanation for modifying the link-state algorithm to construct a  multicast spanning tree for nodes is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0026q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "binary encoding due to the good utilization of the bandwidth",
        "answer_feedback": "the response does not provide the second reason behind using the binary encoding in the given scenario which is the lack of need of self-clocking making binary encoding a better option.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "smp0096q005",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forw.)(a, c, forw.)(a, d, forw.)\nhop 2:\n(b, e, forw.)(c, f, forw.)\nhop 3:\n(e, g, forw.)\nhop 4:\n(g, h, forw.)",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop) ).",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "smp0378q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "we need a duplex operation. this means that sender and receiver both sends and receives frames. then ack and data can be merged into one frame and sent together.",
        "answer_feedback": "the response answers the underlying requirement correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0316q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the maximal distance between stations reduces by a factor of 10.\n\nex. : 64 byte sent with 10 mb/s: max distance of 5.12 km\n        64 byte send with 100 mb/s: max distance of 112 km",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0340q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "the asynchronous transmission mode needs a start and a stop character before and after each byte. therefore it has low transmission rates. but it is very simple and inexpensive.\nthe synchronous transmission mode has higher transmission rates. it works by pooling several characters to frames defined by syn or flag. therefore it is more complex than the asynchronous transmission mode.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0364q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "with the “dynamic host configuration protocol” a host can find out about the ip address to a dedicated hardware address. it simplifies the installation and configuration of end-systems and it is used for manual and automatic ip address assignment. it may also provide additional configuration information such as dns server or netmask information.",
        "answer_feedback": "the response answers the definition and the usage of dhcp correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0290q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "1. enlarge the available address pool:\n    by increasing the ip address length from 32 bits to 128 bits, a greater number of addresses can be assigned to end systems.\n2. simplify protocol processing:\n    any previous shortcomings in ipv4 can be removed and optimized in ipv6.\n3. provide multicasting:\n    packets can now be sent to multiple destination addresses, which makes multicasting possible.\n4. better security:\n    security means are already integrated in ipv6.",
        "answer_feedback": "the response correctly states four objectives of ipv6 with explanations.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0228q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table contains information, which source addresses can be reached via which output line. \nwhenever a bridge receives a frame from one of its lans, it extracts the source address and updates its entry for this address with the corresponding lan and time stamp. \nafter some amount of time all entries, which have not been renewed are purged to prevent outdated information from being used. \n\nknowing via which output line to forward a frame, the bridge does not have to resort to flooding thus reducing the total network load. \n\nan advantage of transparent bridges is that the bridge is invisible to the network which simplifies other components.",
        "answer_feedback": "the response does not mention how a packet from source s received over lan l can be interpreted as \"destination s can be reached over l\" which forms the base for backward learning. also, a benefit of the transparent bridges in general is stated which was not required. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0350q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous mode: each character is bound between a start bit and a stop bit. -> simple and inexpensive but low transmission rate. \n\nsynchronous mode: several characters form into one frame, frames defined by syn or other flags.  -> more complex but higher transmission rate.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0163q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "b -> c -> a\nb is the least likely, as there is only 1 combination of all 2^6 combinations possible which is exactly this combination.\nc is more likely than b as there are more than 1 combination possible (e.g. hhhttt, ttthhh) (10 total).\na is more likely than c as all combinations that are valid under c are also valid under a plus for example the combination (hhhhtt) which makes it a strict supergroup to the group of combinations valid under c.",
        "answer_feedback": "the response correctly states the sequence of the three given events. c's justification is partially correct as the total number of possible combinations for c is 20, not 10. the justification provided for a is also partially correct as c is a more strict subgroup than a.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0108q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "there are two separate problems that need to be considered here: duplicates within a single connection or duplicate connections. as duplicate packets within a connection are easily handled by seqeunce numbers and the focus of the lecture seemed to be on duplicate connection, i will focus on those.\n1. different port(tsap) for each connection: kind of defeats the purpose of ports as multiple ports would be bound to a single thread. also servers that communicate on a well known port cannot use this methode. solves the problem of duplicate connections without using additional bandwidth\n2. count prior connections: requires endsystems to keep track of this counter. low effort as this would only be required in the connection establishment stage\n3. count prior packets: requires a realtively high bandwidth and memory. could replace the already used sequence number within the protocol to avoid for example out-of-order packets",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0255q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding :  purpose:variation of the spanning tree,each sender has its own spanning tree,but is do not need to know the spanning trees algorithm:has this packet arrived at the is entry port over which the packets for this station/source are usually also sent? yes: -assumption: packet used the best route until now   action: resend over all edges (not including the incoming one) no: -assumption: packet did not use this route (it is not the best route)     action: discard packet (most likely duplicate)   reverse path broadcast: purpose:has packet arrived at the is entry port over which the packets for this station/source are usually also sent? yes: -packet used the best route until now -resend over all edges(not including the incoming one) no: discard packet did not use this route (it is not the best route)   algorithm: packet from s(ource) to d(estination) like reverse path forwarding with specific selection of the outgoing links has this packet arrived at the is entry over which the packets for this station/source s are usually also sent? yes: packet used the best route until now?      yes: select the edge at which the packets arrived and from which they                 are then rerouted to source s (in reversed direction)       no:  do not send over all edges (without the incoming one), i.e., not as              in reverse path forwarding (rpf) no: discard packet",
        "answer_feedback": "the response correctly explains  rpf and rpb but the stated purpose is incorrect. it should be to reduce the number of duplicates and unnecessary packets in flooding/broadcasting by inspecting the optimal unicast paths.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "smp0154q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "first, we set our ss_thresh to a number. then we are sending one packet until its ackknowledged. after the packet is ackknowledge we increase the cwnd by one. we repeat those steps until we reached our ss_thresh. after we reached ss_tresh, tcp slows down increasing cwnd.",
        "answer_feedback": "phases name not mentioned. what happens when congestion occur in either of the phases.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.63
    },
    {
        "id": "smp0114q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. temporary valid tsaps\nfor each new connection, a new, unique, temporary valid tsap only for this connection is created and thrown away at disconnection and never used again.\nadvantage: simple and effective (transport process just can't be reached by delayed duplicates)\ndisadvantage: does not work if the service should be reached via a designated, known tsap.\n2. identify connections individually\neach connection is assigned a unique identifier and identifiers that have already been used are remembered by the end systems, so that when the connection is initiated it can be checked whether the identifier has already been assigned before (= duplicate).\nadvantage: designated tsaps possible (e.g. for well-known services).\ndisadvantage: storage requirements: end systems must permanently store the necessary information and have it available again, for example after a shutdown or crash.\n3. identify pdus individually\neach pdu is assigned an individual sequence number.advantage: fixed tsap possible, no persistent backup of information necessary.\ndisadvantage: more complex, lifetime of packet must be estimated well, because too small a value range for identifiers (sequence number) leads to duplicates not being recognized.",
        "answer_feedback": "the response is correct",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0054q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "56.95 seconds.\nthis is m/m/1/n finite buffer case and n = 10. the question is asking about the time length that the system to be in a state in which there are less than 10 packets waiting in the queue, which also means that system is not full. therefore, we should calculate the probability that system is full first, which is pb = pn = p10. then, we can know the probability that less than 10 packets waiting in the queue which is 1-p10. in the case, we monitor exactly one minute after the system reaches equilibrium. with the probability (1-p10) we get, we would expect 56.95 seconds.",
        "answer_feedback": "the response correctly states the non-blocking time and provides a valid justification for the calculation.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0055q003",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "assuming 9 packets arrive each second and 10 are served. on average the buffer should never be full leading to a 60s time where there are less than 10 packets in the queue.",
        "answer_feedback": "the stated justification is incorrect as the given rates are not constant and can vary through time, so an average needs to be calculated for the given time. therefore, the stated time is also incorrect.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0410q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "class a:\n0.0.0.0. - 127.255.255.255",
        "answer_feedback": "not all addresses in class a are reserved",
        "verification_feedback": "incorrect",
        "max_score": 0.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0214q013",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, because sometimes many users want to access the server at the same time, while at other times, only few request the server. for example a livestream of a football match: everybody sends requests to the server at kickoff, but only few do after the game (to watch the highlights). that means that the arrivals are not independent. they can depend on other events.",
        "answer_feedback": "while the response explains the event point of view, internet traffic is generally bursty, independently of specific events. this makes the packet arrival at a node depend on the previous arrivals.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0125q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases of congestion control are:\n1. slow start\n2. congestion avoidance\n\nin the slow start phase, the sender sends as many segments as the size of the cwnd. every time a segment is acknowledge the cwnd increases by one. so, in the slow start phase the number of sent packets increases exponentially. when the cwnd reaches the ss_thresh or there is a packet loss, the system changes to congestion avoidance phase.\nin the congestion avoidance phase, each time congestion occurs ss_thresh becomes cwnd/2 and cwnd is reset to 1. then, the slow start phase restarts again.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost. the explanation of the congestion avoidance phase is also partially correct as it does not mention how the congestion window increases in this phase, exponentially or linearly.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0283q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "-to support more end-systems than ipv4\n-to reduce routing tables and simplify protocol processing\n-to increase security\n-to support real time data traffic",
        "answer_feedback": "the response is correct because all stated objectives of ipv 6 are correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0318q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "when the speed of a network is increased by a factor of ten, while letting everything else remain the same, the collision domain diameter reduces by the same factor. so, the diameter will decrease by a factor of 10 (that is, divide by 10)",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0420q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "according to rfc 6890 the following address blocks are reserved (https://datatracker.ietf.org/doc/html/rfc6890#section-2.2.2):\n127.0.0.0/8 with the range 127.0.0.0 - 127.255.255.255 loopback adresses\n100.64.0.0/10 with the range   100.64.0.0–100.127.255.255 if carrier-grade nat is used this is the shared address space between a service provider and its subscribers\n\n10.0.0.0/8  with the range 10.0.0.0 - 10.255.255.255 private network adresses\n\n0.0.0.0/8 with the range 0.0.0.0 - 0.255.255.255 host adresses at this network with 0.0.0.0 being this host\n\nadditionally these adresses are reserved:\nx.0.0.0 network adresses, where x is 0-127 (excluding 0.0.0.0 and 127.0.0.0 as reserved rfc addresses)\nx.255.255.255 broadcast adresses, where x is 0-127 (excluding 0.255.255.255 and 127.255.255.255 as reserved rfc addresses)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0050q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the users can use both manchester or differential manchester encoding. the reason behind as fol:\n1. both of them uses .5 bit per baus so channel capacity is reduced.\n2. less susceptible to noise due to interfearance.",
        "answer_feedback": "the binary encoding is the better option because of better bandwidth utilization and no self-clocking requirement.",
        "verification_feedback": "incorrect",
        "max_score": 2.5,
        "normalized_score": 0.0
    },
    {
        "id": "smp0312q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter would be 10 times smaller which would have many collisions as a consequence, making it inadvisable to choose these dimensions.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0112q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "method 1: to use temporarily valid t saps\ngenerate unique (transport) service access point (tsap) for each communication and they are valid for one connection only\nadvantages:\n- you can always generate new tsaps\ndisadvantages:\n- some tsaps are standardized(\"well-known ports\") and cannot be used\nmethod2: to identify connections individually\neach connection is assigned a new sequence number and end systems story assigned sequence number and remember them\n\nadvantages:\n- duplicates from another connection with a sequence number does not interact with other connection with a different sequence number\ndisadvantages:\n- only works with connection-orinted service\n\nmethod 3: to identify pdus individually: individual sequential numbers for each pdu",
        "answer_feedback": "disadvantage of third method not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.5,
        "normalized_score": 0.83
    },
    {
        "id": "smp0422q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0\n127.0.0.0 to 127.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0408q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "for each x ∈ {1,...,127} the network address x.0.0.0 and the broadcast address x.255.255.255 are reserved.\naccording to rfc 6890addresses 10.0.0.0-10.255.255.255 are reserved for private-use networks\naddresses 100.64.0.0-100.127.255.255 are reserved for shared address space\naddresses 127.0.0.0-127.255.255.255 are reserved for loopback",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0352q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission – characters are transmitted individually, by encapsulating them within start and stop bit. its simple and inexpensive but has low data transmission rates\nsynchronous transmission – several characters are combined into a frame and encapsulating frame within syn or flag symbol. its complex but offers higher data transmission rates.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0327q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "t1.allow sender to transmit concatenated sequence of multiple frames in single transmission .\n2.needs frames waiting for transmission .\n3.better efficiency .",
        "answer_feedback": "the response is correct as it answers all parts of the question.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0105q006",
        "question": "discuss 3 methods (each with at least one advantage and disadvantage) that address the problem of duplicate packets on the transport layer in a connection-oriented service.",
        "reference_answer": "1. to use temporarily valid tsaps -method: -tsap valid for one connection only -generate always new tsaps -evaluation -in general not always applicable:-process server addressing method not possible, because -server is reached via　a designated/known tsap - some tsaps always exist as \"well-known\" 2. to identify connections individually -method: -each individual connection is assigned a new seqno and -endsystems remember already assigned seqno -evaluation -endsystems must be capable of storing this information -prerequisite: -connection oriented system (what if connection-less?) -endsystems, however, will be switched off and it is necessary that the information is reliably available whenever needed 3. to identify pdus individually: individual sequential numbers for each pdu -method: -seqno basically never gets reset -e.g. 48 bit at 1000 msg/sec: reiteration after 8000 years -evaluation -higher usage of bandwidth and memory -sensible choice of the sequential number range depends on -the packet rate -a packet's probable \"lifetime\" within the network",
        "provided_answer": "1. use temporarily valid tsap \n+ easy to implement (just need a new tsap per connection that can be chosen during handshake)\n- cant use temporarily valid tsap because server uses \"well-known\" tsaps that cant change\n- only very limited tsap space \n\n2. identify connections individually\n+ multiple individual (distinguishable) connections are possible in parallel over the same tsap \n- endsystems must store the chosen sequence numbers for each connection for the duration of the whole connection\n- only for connection-oriented systems\n\n3. identify pdusindividually\n+ high flexibility, due to fine-grained detection of duplicates independent of a connection or tsap\n- high seqnr space needed (prerequisite: how big should the initial space even be? is the connection alive for years or just seconds?) -> higher usage of bandwidth and memory",
        "answer_feedback": "the response is correct.",
        "verification_feedback": "correct",
        "max_score": 1.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0342q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission:\n each character is bounded by a strat bit and a stop bit.\n+ simple and not expensive\n- low transmission rates, often up to 200 bit/sec\n\nsynchronous transmission:\n several characters pooled to frames.\n frames defined by syn or flag.\n+ higher transmission rates\n- more complex",
        "answer_feedback": "the response correctly answers the differences between synchronous and asynchronous transmission mode.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0170q009",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "p(b) less than p(c) and p(c) less than p(a)\n\np(a) must be smaller then p(c) because cases whith more then 3 h's are invalid. p(c) must be smaller then p(b) because the h's and t's must be sorted.",
        "answer_feedback": "the response correctly states the sequence of the three given events. however, the justification states the opposite which is incorrect.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0423q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0–0.255.255.255\n10.0.0.0–10.255.255.255\n100.64.0.0–100.127.255.255\n127.0.0.0–127.255.255.255",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0240q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "1. hidden terminals  exposed terminals， near and far terminals 2.hidden terminals： there are maybe 3 nodes. because of the maximal range. nodes a and c cannot  hear each other. they can only hear b. the transmissions of a and c may collide at b. so they are hidden from each other. this is a waste of resources and it may lead more collisions.\n\t exposed terminals:  there are 4 nodes. b can hear a and c. c can hear b and d. when b sends to  a and c sends to d, c must wait because there is signal that a medium is being used. but because a is out of the range of c . so this wait is unnecessary. c  is exposed to b . this leads to the problem of underutilization of channel and lower effective throughput.",
        "answer_feedback": "c does not need a signal that the medium is busy because it can use its carrier sense to detect b's transmission.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0351q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "asynchronous transmission: in this type of transmission, each character is bounded by a start and end bit. this is simple but offers low transmission rates upto 200bits/sec.\n\nsynchronous transmission: in this type of transmission, several characters are pooled  into frames and these frames are added syn or flag, this offers more transmission rates than the asynchronous.",
        "answer_feedback": "the response answers the differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0419q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "0.0.0.0–0.255.255.255\n127.0.0.0 - 127.255.255.255\n10.0.0.0–10.255.255.255 (reserved for private networks, not routed through the internet)\n100.64.0.0–100.127.255.25 (reserved for private networks, not routed through the internet)",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0253q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding and reverse path broadcast are used for broadcast routing (a sender send a message to all recievers(1:all communication)). the sender has its own spanning tree to calculate the routes. the receivers however do not. so they have to deciede how to handle the received packets. so they check if the received packet was received through the edge, which is usually used by packets from the sender. if this is not the case, the packet will be discarded. however if it is the case, in reverse path forwarding, the packet will be resend over all edges.  with broadcast routing on the other hand the receiver checks if the received packet used the best route until this point and only forwards it over those edges which belong to the best routes,",
        "answer_feedback": "the response correctly explains rpf and rpb. however, the response lacks the purpose which is to minimize the number of duplicate packets during broadcasting. in both algorithms, the packet is also not forwarded to the edge from which it was received.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.7
    },
    {
        "id": "smp0363q023",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is a newer version of rarp. \nsystems use this protocol to resolve their own ip address in a network from their hardware/mac address. \na specific dhcp server assigns the ip addresses and is contacted to resolve them.",
        "answer_feedback": "the response answer is partially correct because the statement regarding the dhcp server is correct. however, dhcp is more a replacement of rarp and not a new version. also, arp is used to resolve the ip address from the mac address.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0249q016",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding (rpf) and reverse path broadcast (rpb) are techniques used in routers. they enable loop-free forwarding of multicast packets in multicast routing. reverse path forwarding:  in this procedure, each node i checks whether an incoming packet from source q has been received on the connection on which node i also transmits its packets to q. if this is the case, then the packet is assumed to have been transmitted on the shortest route and it is forwarded on all other lines. if, on the other hand, a packet was received on a line other than the one on which data is transmitted to the sender, then it is assumed that it is a duplicate that did not take the shortest route. this duplicate is then discarded instead of being forwarded. reverse path broadcast:  rpb is an improvement on rpf. rpb not only evaluates the shortest path with respect to the interface where the multicast packets are received, but also influences the forwarding of data to the interface of the router. as a result, multicast packets are only forwarded to the interfaces where the next router is located in the reverse direction on the shortest path to the data source. rpb specifically checks whether the incoming packet arrives at the is through which the packets for this station/source are normally also sent.  if not, the packet is discarded directly. if yes, it will be further checked if the packet has taken the best path so far. if yes → select the edge at which the packets arrived and from which they are then rerouted to source s (in reversed direction) if not → do not send over all edges (without the incoming one)",
        "answer_feedback": "the purpose of reverse path forwarding and reverse path broadcast is not limited to the multicast but also used in broadcast. the explanation of rpf and rpb is correct.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0303q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the possible distance is reduced by factor 10.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0311q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter is shortened by factor 10. assuming the collision domain diameter is 3000m at 10mb/s. if the speed is increased to 100mb/s, the collision domain diameter will be 300m.",
        "answer_feedback": "the response is correct as it answers the change in the diameter scale accurately.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0277q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "each ipv6 data packet consists of a header and the payload in which the user data is located. compared to ipv4, the internet protocol v6 is characterized by a significantly simplified packet format. in order to facilitate the processing of ipv6 packets, a standard length of 40 bytes was specified for the header. optional information that is only required for special cases is outsourced to so-called extension headers, which are embedded between the header data area and the payload. therefore the main advantage is that options can be inserted without having to change the header. the ipv6 packet header now comprises only eight header fields with ipv4 thirteen fields were used.",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0178q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "- unconfirmed connectionless service\n- confirmed connectionless service\n- connection-oriented service\n\nthe first class offers no flow control or feedback if a frame arrived to its destination. the second class offers no flow control, but the sender resends the frame, if an error occured, which is noticable due to implicit acknowledments. the third class resends the frames, too, but detects additionally duplicates and offers flow control due to \"states\" of sender and receiver and 3-phased communication.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0134q007",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "2 phases: slow start, congestion avoidance at first the cwnd size is set to 1 segment. after each acknowledged segment it will be doubled until it reaches a certain ss_thresh. (slow start)\n\t if the threshold is reached the cwnd will only increase linearly by 1 segment until a timout occurs. (congestion avoidance) the timeout causes the cwnd to reset to one, the ss_thresh to become cwnd / 2 and to enter the slow-start phase again.",
        "answer_feedback": "the slow start phase's explanation is partially correct as it does not mention what happens when a packet is lost before ss_thresh is reached. here the slow start threshold also becomes half of the congestion window, and the congestion window becomes 1. the explanation of the congestion avoidance phase is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "smp0045q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "the encoding technique is binary encoding. \nall users have perfect clocks, so no need for \"self-clocking\". \nbinary encoding has good utilization.",
        "answer_feedback": "need to specify which utilization.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0219q014",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "-the table holds the next hop, i.e. the next lan (output line), for each station. is the station not known or the table is initialized flooding will be used.\n-\tbackward learning: bridge can learn about the other lans with every received frame from each lan it is connected to.\n-\tthe decision procedure is as follows: if the \n      o\tsource and destination lans are identical, the frame is dropped, if the\n      o\tsource and destination lans differ, the frame is rerouted to destination lan and if the\n      o\tdestination is unknown, flooding is applied.\n-\tbenefit: the network is transparent and adaptive.",
        "answer_feedback": "the response correctly states what information the bridge table contains and how the selective forwarding uses this information. in the backward learning process, the bridge learns about the mapping between outgoing lans and stations, not just about connected lans. the stated benefit is not related to the selective forwarding process.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "smp0136q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "initial value of cwnd is one and increases by one in phase 1 slow start, when a segment is acknowledged. this phase continues until value of cwnd reaches ss_thresh which equals to advertised window size or data packet loss occurs.\ncwnd increases by only one in each roundtrip time in phase 2 congestion avoidance until congestion occurs. when congestion occurs, ss_thresh is set to 50% of the current cwnd and then cwnd is reset to one and slow-start is entered.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0326q021",
        "question": "what is \"frame bursting\"? also, give 1 advantage and disadvantage compared to the carrier extension.",
        "reference_answer": "frame bursting reduces the overhead for transmitting small frames by concatenating a sequence of multiple frames in one single transmission, without ever releasing control of the channel.\nadvantage :it is more efficient than carrier extension as single frames not filled up with garbage.\ndisadvantage :need frames waiting for transmission or buffering and delay of frames",
        "provided_answer": "in frame bursting the sender can transmit several frames in one single transmission. \nthe advantage of the frame bursting is definitely a lot higher efficiency than the carrier extension has (which loses around 90% for collision detection). \nthe disadvantage of frame bursting is that the frames have to wait for their transmission.",
        "answer_feedback": "the response gives the frame bursting definition, its advantage and disadvantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0426q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "the host itself:\n0.0.0.0 (00000000.00000000.00000000.00000000)\n\na host at the same network:\n0.x.x.x (00000000.yyyyyyyy.yyyyyyyy.yyyyyyyy)\n\nbroaodcast on another network:\nx.255.255.255 (yyyyyyyy.11111111.11111111.11111111) for x in range [0,127]\n\nloopback:\n127.x.x.x",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0149q008",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the name of first phase in slow start(getting to equilibrium) and the name of the second phase is congestion avoidance. for slow start, ss_thresh is a constant value and each time a segment is acknowledged, we increment cwnd by one everytime until it reaches the threshold ss_thresh(cwnd >= ss_thresh) for which it slows down the increase of cwnd. for congestion avoidance, ss_thresh is set to 50% of the size of congestion window(ss_thresh = cwnd/2) and cwnd is set to 1(cwnd = 1)",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "smp0235q015",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "hidden terminal problem: having three nodes a, b and c where a and c are in range of b, but not in range of each other, if a and c send at the same time to b, there will be interference at b, but they dont know because they are out of range of each other. exposed terminal problem: the constellation of the exposed terminal problem are two sender-receiver pairs where the senders are in range of each other, but not the receivers. if s1 sends data to r1, s2 will assume that the channel is occupied and cannot send data, while in theory it could because r2 is out of range of s1.",
        "answer_feedback": "the response correctly states and describes the hidden and exposed terminal problems in wireless networks.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0373q024",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "data and acknowledgements are send in both directions (sender to receiver and receiver to sender). the data and acknowledgements are bundled into one package.",
        "answer_feedback": "the response is correct as it implicitly answers the requirement of duplex communication.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0172q010",
        "question": "name the 3 service classes the data link layer offers and explain the differences between the classes.",
        "reference_answer": "1.unconfirmed connectionless - no ack, loss of data possible, no flow control, no connect or disconnect.\n2.confirmed connectionless - with ack, no loss of data (timeout and retransmit instead→ duplicates and sequence errors possible), no flow control, no connect or disconnect.\n3.connection-oriented - no data loss, duplication or sequencing errors. instead a 3 phased communication with connect and disconnect, and flow control",
        "provided_answer": "-unconfirmed connection less service\n-confirmed connection less service\n-connection-oriented service \n\nfor unconfirmed data is send by data request (data.req) and receiver gets the data stating an indication.\nthe data is send immediately on the contrary to the connection-oriented service. in unconfirmed conn. less service, you have to expect that \nthe sent packet arrives but you have no feedback acknowledge-signal (ack) whether the packet arrived. \n\nfor confirmed conn. less service, when data is send via data request and arrived (data indication), the receiver answers to the sender by an \nacknowledgement (ack) , so there is a feedback signal stating that data arrived successfully. \n\nso far (for unconfirmed and confirmed connection less service), data is send and acknowledged (for confirmed conn. less) immediately. \nthere is no difference for connection, data or disconnection phases. by using connection-oriented service, you have requests and indications for connection\nestablishment, data transfer and the disconnection. instead of just sending data, you send a request first for establishing a connection, then\nthere is an indication (=able to receive) on the receiver and the receiver sends a response back, after that the sender has a confirmation.\nthere is the same principle for the phases 'data transfer' and 'disconnection'. \nwith connection-oriented service the system is able to send more than 1 bit bidirectional\nbetween sender and receiver and vice versa.",
        "answer_feedback": "the response answers the services' names and differences correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0407q026",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "reserved for host\n0.0.0.0/8 - 0.255.255.255/8 \nreserved for loopback addresses/broadcast\n127.0.0.0/8 - 127.255.255.255/8",
        "answer_feedback": "correct",
        "verification_feedback": "correct",
        "max_score": 0.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0040q002",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "because it is given that all users have pefect clocks, we can use a simple and cheap binary encoding technique. it will also be a very efficient use of the given bandwidth.",
        "answer_feedback": "correct.",
        "verification_feedback": "correct",
        "max_score": 2.5,
        "normalized_score": 1.0
    },
    {
        "id": "smp0286q019",
        "question": "what are the objectives of ipv6? please state at least 4 objectives. ",
        "reference_answer": "to support billions of end-systems.\nto reduce routing tables.\nto simplify protocol processing with simplified header.\nto increase security.\nto support real time data traffic (quality of service).\nflow label, traffic class.\nto provide multicasting.\nto support mobility (roaming).\nto be open for change (future): extension headers for additional change incorporation.\nto coexistence with existing protocols.",
        "provided_answer": "more addresses\nrefactor of header, enables future modifications\nipv4 allow broadcast and unicast, ipv6 supports anycast (e.g. nearest node)\nno checksum\nno fragmenting\nincrease security\nsimplify protocol processing",
        "answer_feedback": "the response correctly answers the four objectives of ipv6.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0309q020",
        "question": "what happens to the \"collision domain diameter\" if you use csma / cd and increase the speed of a network by a factor of 10, eg from 10mb / s to 100mb / s (all else being equal)?",
        "reference_answer": "diameter decreases by a factor of 10, e.g 300m to 30m.",
        "provided_answer": "the collision domain diameter will be increased to 10times compared with the distance in 10mb/s.",
        "answer_feedback": "the diameter is decreased by a factor of 10 instead of increased.",
        "verification_feedback": "incorrect",
        "max_score": 1.0,
        "normalized_score": 0.0
    },
    {
        "id": "smp0260q017",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "a spanning tree has no loops, includes all routers (of the subnet) and has a root is (intermediate system). this is appealing for broad- and multicasting, because you only need to send the data to the root is. from there every node (or a specific set of nodes) can be reached. link state routing constructs a spanning tree. for multicast routing, the information, which systems belong to one group, must be provided. therefore the link state packets are expanded to contain the information on multicast groups. these are then propagated from a predefined root is to calculate the tree. a spanning tree has no loops. link state routing constructs a spanning tree, it needs to know which systems belong to a group.therefore the link state packets are expanded to contain the information on multicast groups. these are then propagated from a predefined root is to calculate the tree.",
        "answer_feedback": "the stated property may be correct for specific types of spanning trees but is not the general property of a spanning tree. not all spanning trees need to have a root node. the reason why a spanning tree is used in multicast and broadcast is the lack of loops, which reduces the number of duplicates needed. the modification description of the link-state algorithm is correct, except that it does not need to be propagated from the root node.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "smp0266q018",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "the extension headers in ipv6 are additional data contains in an ipv6 packet, located between the fixed header and the payload. \nthe main advantage compared to ipv4 is that it allows to add new options without changing the fixed header.",
        "answer_feedback": "the response answers the description, location of extension headers, and advantage correctly.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    },
    {
        "id": "smp0347q022",
        "question": "what is the difference between asynchronous and synchronous transmission mode in the data link layer.",
        "reference_answer": "asynchronous transmission: every character a self-contained unit surrounded by a start bit and a stop bit, which is an easy and cheap pattern, but causes low transmission rates.\n\nsynchronous transmission: several characters pooled to a continuous stream of data (frames), frames defined by syn or flag, higher complexity, but higher transmission rates. requires synchronization between sender and receiver.",
        "provided_answer": "the asynchronous transmission puts on each byte (character) a starter bit and a stop bit. that way is cheap and easy to implement, but the transmission rate would be low.\n\nthe synchronous transmission puts several bytes (characters) to a frame. syn or flags define these frames at the end and beginning of the frame. this mode is more complicated but has a higher transmission rate.",
        "answer_feedback": "the response correctly explains the differences between asynchronous and synchronous transmission.",
        "verification_feedback": "correct",
        "max_score": 1.0,
        "normalized_score": 1.0
    }
]
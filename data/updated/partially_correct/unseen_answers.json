[
    {
        "id": "ba0f888392a24c789d5465d6cf83b921",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i'll choose csma/cd, because it costs efficient, it can detect the collision,but it has short frame.",
        "answer_feedback": "why is the collision detection an advantage? why is the short frame an disadvantage?",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.71
    },
    {
        "id": "631ec5f5b9824a7187ce95c88b0d20c9",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i recommend the token ring, because (1) only one system can send at a time (the one with the token), so the channel load is reduced and (2) the token ring procedure is collision-free and works decentralized. \npotential weakness: the token can be lost if the system which is currently holding the token unexpectedly disconnects from the network.",
        "answer_feedback": "actually, the token ring needs a central monitor (see slide 73, lan slide set).",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.86
    },
    {
        "id": "27bd9e4bc7ed4a61855153ba4f048c4d",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "token ring\nadvantages: still expandable, high usage, due to token ring: sending only possible when sender has ring; prevention of collisions, no random waiting time\ndisadvantage: more expansive than other mac procedures",
        "answer_feedback": "why is high usage an advantage? extendability might be a strong suit but it has its flaws!",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.79
    },
    {
        "id": "0632012c4c3443dd93391906b49d75ce",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "token ring,\n+, good throughput - even during increased utilization\n+, expandable\n\n-, delays because of waiting for token",
        "answer_feedback": "extendability might be a strong suit but it has its flaws!",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.86
    },
    {
        "id": "35f08ec0d5d145279ba820b579de6063",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "i would recommend to use token ring for the following reasons:\n- as they expect the channel load to be high it is no advised to use csma/cd or a variant of it as that will cause a lot of collsions. whereas token still performs reasonable well during increased utilization\n- the other requirement is that it should support 20 systems and should be expandable later. token ring can support a maximum of 250 stations and can be extended with coax or optic fiber later on (for increased transmission rate). \n\none potential weakness is:\n- as their funding is tight csma could still be considered as it is a lot more cost efficient than token ring.",
        "answer_feedback": "extendability might be a strong suit but it has its flaws!",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.86
    },
    {
        "id": "b1c313aaa9ec4a51b6e4a38e21516730",
        "question": "a company is planning to set up a new lan at one of their locations and is looking for an appropriate medium access procedure. however, the funding is tight so they expect the channel load to be high compared to the hardware they can provide. currently, they would like to have 20 systems sharing the channel, but it should be expandable later on. which of the mac procedures introduced in the lecture (polling, tdma with or without reservation, token ring, pure or slotted aloha, 1-persistent csma, p-persistent csma, non-persistent csma or csma/cd) would you recommend?give 2 reasons for your decision and 1 potential weakness of your recommendation in 2-6 sentences.",
        "reference_answer": "0.5 p for a sensible choice out of: token ring, p-persistent or non-persistent csma, csma/cd or tdma with reservation 1p for the drawback and 1p for an advantage.the following properties may be considered: scalability, waiting time, extendability, cost effectiveness, constraints, hardware requirements, compatibility, throughput, overhead, complexity and prioritization capabilities",
        "provided_answer": "csma/cd:\nreasons:\n1. there are 20 systems sharing the channel, so it should be random access.\n2. stations know whether the channel is in use or not before trying to use it, so it should be with carrier sense\n\npotential weakness:\n1. csma/cd has no maximum waiting time.",
        "answer_feedback": "why exactly should it be random access, what advantages has it for sharing? the other csma procedures are also with carrier sense, why then choose csma/cd?",
        "verification_feedback": "partially correct",
        "max_score": 3.5,
        "normalized_score": 0.43
    },
    {
        "id": "477d2f072f734d6bb621393387ad6a6c",
        "question": "assume you have a local network with 3 users that are all interconnected and have perfect clocks. typically the network is often congested as all users generate more traffic than the link’s capacities. which of the encoding techniques introduced in the lecture should be used in this network to encode bitstreams? give two reasons for your answer in 2-4 sentences.",
        "reference_answer": "binary encoding, as it is the most efficient in terms of bandwidth since you get a full bit per baud instead of only 0.5. additionally, you do not have to deal with clock drift and various ticking rates as all clocks are perfect. therefore, self-clocking / clock recovery is not as necessary. simple and cheap is also acceptable as one of the reasons.",
        "provided_answer": "we can use bit encoding - it has a good utilization of the bandwidth, and it can work because the users have perfect clocks. \nanother technique we can use is manchester encoding - is it not sensitive to  מoise on the line and therefore can deal with more users using the line.",
        "answer_feedback": "manchester encoding is not correct as we do not require self-clocking, also bandwidth utilization is less. (note: as per the notification in the quiz slide, an additional  incorrect answer will also be counted while providing grading )",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.5
    },
    {
        "id": "5db28d57875c4ebebe8d5e363769e814",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "first we need to calculate the utilization. in this scenario the utilization is quite high with 90%. however we want to know the time that the buffer has less than 10 entries. this means that not the case if the buffer is full. we can calculate probability for that using the above-mentioned utilization. the probability is about 5%. so it’s likely that the system will most likely have the full minute less than 10 packets.",
        "answer_feedback": "the response is partially correct because calculating the probability when the buffer is full is correct. however, it lacks the step where the probability is multiplied with the time to get the expected number of seconds, that is 56.9512 seconds.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "e0e9a43eb7b643fe8a675aba18461116",
        "question": "consider a single server queueing system with a buffer of size 10. let us assume that 9 packets arrive per second and 10 packets are served per second on an average. assume you monitor the system for exactly one minute after the system reaches equilibrium. how many seconds would you expect the system to be in a state in which there are less than 10 packets waiting in the queue? you need to justify your answer by showing steps involved; calculations, however, need not be included. headers.",
        "reference_answer": "since we have a buffer size (n) of 10, we will always have less than 10 packets waiting in the queue unless there are exactly 10 packets in the queue. therefore, we first calculate the probability of the system being full/having 10 packets in the queue. this is also called “blocking probability” or p_b.\np_b = ((1 - utilization) * utilization^n) / 1 - utilization^(n+1) = ((1-0.9) * 0.9^10) / (1 - 0.9^11) = 0.0508\nalternatively to the blocking probability, it is also valid to directly calculate p(x less than 10) = (1 -p_b) by summing up the probabilities for 0, 1, …, 9 packets to be in the queue. to calculate the expected time where the system is not blocked in the 60-second observation time-frame, we simply multiply the time frame with p(x less than 10) or the complement of p_b (0.25p) = 60 * (1-p_b) = 56.9512 seconds",
        "provided_answer": "λ = 9     less than equal to packets arriving per second\nµ = 10   less than equal to packets served per second\nn = 10   less than equal to buffer size\n\n=> ρ = 9/10\n\nthe probability that there less than 10 packets in the system is e(n less than 10).\n\ne(n less than 10) = 1- e(10) = 1 - blocking probability\n= 1 - 0.457324\n= 0.954276\n\nso in 60 seconds, there are less than 10 packets in the queue for e(n less than 10) * 60 = 57.2561 seconds.",
        "answer_feedback": "the steps stated are correct but the obtained blocking probability and the final time are not correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "ee6e7073d7c24a2bb95bede53f4aa7f4",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "ja, da es zu sogenanntem oszillierendem verhalten kommen kann wenn die aktuelle auslastung einer leitung als metrik benutzt wird, wodurch permanent die route gewechselt wird. dies passiert dadurch das ein packet über route x zu g geschickt wird, wodurch die auslastung dieser route steigt, was wiederum a dazu animiert eine andere route zu wählen -> usw.",
        "answer_feedback": "but why is oscillating a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "a8b173eb40ac4073aa7cec081c6b12f7",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "when there are multiple transmiisions, with load may lead to an oscillation of the load, i.e., if a wants to send a message to h under the condition that cf is overload and ei is avaliable, it will choose ei to transmit message, when cf is avaliable, it will choose cf. hence, routing tables may oscillate frequently.",
        "answer_feedback": "but why is oscillating a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "f43de9e3373e4af89e2db8dc5728c113",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "a könnte viele packets in einer kurzen zeit senden und damit g (oder einen der zwischenknoten) überlasten. flow control muss also beachtet werden.",
        "answer_feedback": "but this is not a problem specific for the routing strategy",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "6fe79c2d01194a8cb269f1d2f54bb8f0",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "it could be a problem that the packets are oscillating. so the packets will never arrive to g.",
        "answer_feedback": "oscillating does not mean, that packets are never arriving in g!",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "abcc8400d43845d2a0d224f3b9929c78",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "using metrics like load or utilization can lead to 'oscillations' - which means that every time the load or utilization changes, the path taken will change, and the load and utilization will change while packets are being routed.",
        "answer_feedback": "but why is oscillating a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "b519f276308344fba72d3e4742750ee1",
        "question": "consider the following network topology from the lecture:with routing, we want to find the best path for our packets. for this, we first need to define a metric to evaluate the quality of a path. one possible choice could be the current load (i.e. the current utilization in terms of sent packets/bytes) on this path. assume that a wants to send data to g, could this routing strategy cause any problems at the receiver end? please explain your answer in 1-2 sentences.",
        "reference_answer": "yes, using the current load to find the best path can lead to fluctuations/oscillations when there is more than one path between any pair of end systems in the network (here: cf and ei). this can cause packet reorderings at the receiving side.",
        "provided_answer": "yes this strategy could lead to problems as it could lead to oscillations. if there are two possible path (i.e link cf or link ei) the choice of which path to take could flip around as choosing one path increases the load on that path and in return making the other path more favorable increasing the load on this other path, so the decision on which path to take could swap around repeatedly.",
        "answer_feedback": "but why is oscillating a problem?",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "6f95174a3466467f84710807a514cf38",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:(a, b, forward)(a, c, forward)(a, d, forward)\n\n\n\n\nhop 2:(b, e, forward) (b, c, drop) <= a->c is shorter\n\n(c, b, drop) <= a->b is shorter\n\n(c, e, drop) <= a->b->e is shorter\n(c, f, forward)\n\n(c, d, drop) <= a->d is shorter\n\n(d, c, drop) <= a->c is shorter\n\n(d, f, drop)  <= a->c->f is shorter \nhop 3: \n\n(e, c, drop) <= a->c shorter\n\n(e, f, drop) <= a -> c-> f is shorter\n\n(e, g, forward)\n\n(f, d, drop) => a->d is shorter\n\n(f, e, drop) => a -> b-> e is shorter\n\n(f, g, drop) => a -> b -> e -> g is shorter \nhop 4:\n\n(g, f, drop) => a->c->f is shorter\n\n(g, h, forward)",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "87ebea20f832442a92639697dbac1ab6",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward), (a, c, forward), (a, d, forward)\n\nhop 2:\n(b, e, forward)\n(c ,f, forward)\n\nhop 3:\n(e, g, forward)\n\nhop 4:\n(g, h, forward)",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop) .",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "58bfe839c1f44dc4a6721516a0dea74c",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\n\nhop 2:\n(b, c, drop), c hat das paket bereits empfangen.\n(b, e, forward)\n(c, b, drop), b hat das paket bereits empfangen.\n(c, d, drop), d hat das paket bereits empfangen.\n(c, e, drop), e bekommt pakete von a normalerweise über b.\n(c, f, forward)\n(d, c, drop), c hat das paket bereits empfangen.\n(d, f, drop), f bekommt pakete von a normalerweise über c.\n\nhop 3:\n(e, c, drop), c hat das paket bereits empfangen.\n(e, f, drop), f hat das paket bereits empfangen.\n(e, g, forward)\n(f, d, drop), d hat das paket bereits empfangen.\n(f, e, drop), e hat das paket bereits empfangen.\n(f, g, drop), g bekommt pakete von a normalerweise über e.\n\nhop 4:\n(g, f, drop), f hat das paket bereits empfangen.\n(g, h, drop) h hat keine nachbar, an die das paket weitergereicht werden kann.",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop)  will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "b7400185afd94f8cbf01c2f329a467e9",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop1: \n(a, b, forward)\n(a, c, forward)\n(a, d, drop) // d will receive the packet and won't forward it \n\nhop 2: \n(b, e, forward)\n(c, f, drop) // f will receive the packet and won't forward it \n\nhop 3: \n(e, g, forward)\n\nhop 4: \n(g, h, drop) // h will receive the packet and won't forward it",
        "answer_feedback": "the reason should explain why it is not forwarded, for example, (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a.  for (g,h,drop), it has no other neighbor",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.8
    },
    {
        "id": "fd8bbe7105284be8baf8f62f0b95b326",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1: \n(a, b, forward)(a, c, forward)(a, d, forward)\nhop 2:\n(b, c, dropped) c would not send packets to a via b, costs 4, direct path to b costs 2(b, e, forward)(c, b, dropped) same reason as before(c, d, dropped) c would not send packets to a via d, costs 4, direct path to d costs 2(c, e, dropped) e would send packet via b(c, f, forward)(d, c, dropped) same reason as (c, d)(d, f, dropped) f would send packet via c, costs of 1 instead of 3\nhop 3:\n(e, f, dropped) e would send packet via b, costs of 1 instead of 2 (over f and c)(e, g, forward)(f, e, dropped) same reason as before(f, g, dropped) g would send packet via e, because costs of 1 instead of 2\nhop 4:\n(g, h, forward)",
        "answer_feedback": "the provided flow appears more similar to rpf than to rfb.  in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "6b26ecb4abba4853bd60baf4308116e4",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a,c,forward)(a,b,forward)(a,d,forward)\nhop 2:\n(b,e,forward)(c,f,forward)\nhop 3:\n(e,g,forward)\nhop 4:\n(g,h,drop) => dropped because the package arrived from the port with shortest path to s but there is no other port to forward the package to.",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.5 for reasoning (a,d, drop), (c, f, drop) ).",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.8
    },
    {
        "id": "7bf37f373a0340e5830fded62a295f9a",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop1\n(a,b, forward)\n(a,c, forward)\n(a,d, forward)\n\nhop2\n(b,e,forward)\n(c,f,forward)\n\nhop3\n(e,g,forward)\n\nhop4\n(g,h,forward)",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.6
    },
    {
        "id": "ab6e09685e35475b86d2c2bb6c1e60e6",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1\n(a, b, forward)\n(a, c, forward)\n(a, d, forward)\nhop 2\n(b, e, forward)\n(c, f, forward)\nhop 3\n(e, g, forward)\nhop 4\n(g, h, forward)",
        "answer_feedback": "packets will be considered dropped if it is not forwarded further by the receiver node.(-0.75 for reasoning (a,d, drop), (c, f, drop) and (g, h, drop) ).",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.7
    },
    {
        "id": "f8ae04f88ac643efbe0e71f7660c189d",
        "question": "consider the following topology from the exercise. this time, node a wants to distribute a packet using reverse path broadcast (rpb). assume that every is knows the best path to a and also whether they are the next hop of their neighbors on the unicast path to a.please list all the packets which are sent together with the information whether they will be forwarded or dropped at the receiving nodes. use the following notation: (sender, receiver, drop) for dropped and (sender, receiver, forward) for forwarded packets. please group these tuples according to the number of hops the packets have travelled so far. for dropped packets, please specify the reason why the packet has been dropped in a few words.example for the notation:hop 1:(c, a, forward)(c, b, drop) <= describe reason herehop 2:(a, d, drop) <= describe reason here",
        "reference_answer": "hop 1 :(a, b, forward),(a, c, forward), (a, d, drop) <= reason: remaining neighbors c and f do not use d as the next hop to get to a hop 2 :(b, e, forward),(c, f, drop), <= reason: remaining neighbors d, e, g do not use f as the next hop to get to a hop 3 :(e, g, forward)hop 4 :(g, h, drop) <= reason: h is only connected to g, packet is not forwarded to incoming link",
        "provided_answer": "hop 1:\n(a, b, forward)(a, c, forward)(a, d, forward)\nhop 2:\n(b, e, forward)(b, c, drop) <= not the minimal route / part of minimal spanning tree. c would use (c,a)(c, b, drop) <= not the minimal route / part of minimal spanning tree. b would use (b, a) (c, e, drop) <= not the minimal route / part of minimal spanning tree. e would use (e, b, a)(c, f, forward)(c, d, drop) <= not the minimal route / part of minimal spanning tree. d would use (d, a)(d, c, drop) <= not the minimal route / part of minimal spanning tree. c would use (c, a)(d, f, drop) <= not the minimal route / part of minimal spanning tree. f would use (f, c, a)\nhop 3:\n(e, c, drop) <= not the minimal route / part of minimal spanning tree. c would use (c, a)(e, f, drop) <= not the minimal route / part of minimal spanning tree. f would use (f, c, a)(e, g, forward)(f, d, drop) <= not the minimal route / part of minimal spanning tree. d would use (d, a)(f, e, drop) <= not the minimal route / part of minimal spanning tree. e would use (e, b, a)(f, g, drop) <= not the minimal route / part of minimal spanning tree. g would use (g, e, b, a)\nhop 4:\n(g, f, drop) <= not the minimal route / part of minimal spanning tree. f would use (f, c, a)(g, h, forward)\nhop 5:\nno further transmissions because no more routes except to g available.",
        "answer_feedback": "in  rfb, (a,d, drop) and subsequent flow will change accordingly. also (c, f, drop) and (g, h, drop) will occur. please consult the model solution.",
        "verification_feedback": "partially correct",
        "max_score": 2.5,
        "normalized_score": 0.4
    },
    {
        "id": "53f831ca87d84ab781d5f69454dddae0",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "phase 1: slow start \nphase 2: congestion avoidance \n\nin the beginning of phase 1 the cwnd is increasing exponentially starting at cwnd=1 by doubling cwnd after every transmission until a threshhold ss_thresh is reached. from this point onwards, cwnd is increased linearly until congestion occurs. this initiates phase 2, in which ss_thresh is set to the half of the value of cwnd at the moment when the congestion occured (ss_thresh_new = cwnd/2). afterwards cwnd is reset to 1 and phase 1 starts again with the new value of ss_thresh.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost. the congestion avoidance phase starts when the cwnd becomes equal to the threshold, not when the congestion starts.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.62
    },
    {
        "id": "33fb973f368749d8852cc0be6af51a7c",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "phase 1: slow start\n              in this phase, every time the segment is acknowledged, cnwd plus one until it reaches ss_thresh or packet loses, but when cnwd is not smaller than ss_thresh, cnwd will increase much slower.\n\nphase 2: congestion avoidance \n            in this phase, the new ss_thresh is half of the cnwd, and cnwd will be reset to one, then slow start starts.",
        "answer_feedback": "the response correctly states the name of the two phases. the slow start phase's explanation is partially correct because though it mentions that packet loss can occur before ss_thresh is reached, it does not provide details of the changes in the value of ss_thresh and the congestion window. also, a linear increase of the congestion window happens in phase 2, not 1. the second phase does not state when the threshold and congestion window changes are done.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "9d5a3e937992436d91610224083c2154",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases of congestion control are called slow start and congestion avoidance. in the first phase grows the cwnd exponentially until it reaches ss_thresh. from this moment, the second phase begins and the cwnd grows only linear. if a timeout happens, cwnd is reset to one and ss_thresh is set to the half of the (former) cwnd. then the two phases start again.",
        "answer_feedback": "the slow start phase's explanation is partially correct as it does not mention what happens when a packet is lost before ss_thresh is reached. here the slow start threshold also becomes half of the congestion window, and the congestion window becomes 1. the explanation of the congestion avoidance phase is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "a3c11b128cec4b999cde4c41c0deea1c",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "phase 1 is called slow start. in this phase, the congestion window (cwnd) grows exponentially until the slow start threshold (ss_thresh) is reached, and then it grows linearly. then, everytime congestion occurs, phase 2 or congestion control starts. in this phase, ss_thresh is set to 50% of the current cwnd value. cwnd is then set to 1 and slow start starts again.",
        "answer_feedback": "the response is partially correct because the second phase is congestion avoidance and not congestion control. the slow start phase is missing details about how ss_thresh changes when a packet is lost. also, in the congestion avoidance phase, it's unclear how the cwnd increases, till which condition it's done, and also when the ss_thresh is set to half of the current cwnd.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.38
    },
    {
        "id": "6f5c9d7f6fcc4c0daaa085b3cb61a8ba",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "in the first phase, the slow start, cwnd grows exponentially with base 2. \nwhen cwnd equals ss_thresh, the second phase, the congestion avoidance, starts, where cwnd now only grows linearly. \nwhen congestion occurs, ss_thresh is set to cwnd / 2 and cwnd is reset to 1 and the system is back in phase 1.",
        "answer_feedback": "the response is correct, except that it is not clear whether the congestion and the corresponding changes occur in phase 2 or both phases.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "ef074d2d3a544e9eb229b33d270d6e01",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases of congestion control are a slow start and congestion avoidance. lets assume the slow start threshold is x. after initialization, the \"slow start\" begins with checking if one segment arrives at the sender (receiving ack) and increases the number of segments until the procedure throws an error. the new ss_thresh is half of the last segments that arrived successfully (cwnd/2). then in phase two, the congestion window is reset to 1, and the process starts with a new ss_thresh (cwnd/2).",
        "answer_feedback": "the response states the two phases of congestion control correctly. however, it's unclear how cwnd is incremented. the response also lacks details about how and when ss_thresh changes in both phases.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "819a664a753e4f0ebc14d02babc7bd81",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "first, in the \"slow start\" phase, the sender sends one segment, then two, four, eight segments, etc. (always doubling the cwnd), until the ss_thresh is reached. then, in \"congestion avoidance\" phase, the sender only increments the cwnd linearly (+1). if a congestion occurs, the ss_thresh is set to 50% of the current size of the cwnd, the cwnd is set to 1, and the sender starts again with slow start.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "6a081dc2d8144936915fd22ece5aa846",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "1. slow start: after the initializtion, cwnd is increased by 1 each time when a segment is acknowledged. this continues until cwnd == ss_thresh or a packet gets lost. when cwnd >= ss_trhesh, tcp slows down the increase of cwnd. especially, slow start increases the rate exponentially if each ack generates 2 packets. 2. congestion avoidance: each time congestion occurs, ss_thresh is set to ss_tresh = cwnd / 2 and cwnd is reset to one s.t. cwnd = 1. after that, slow-start is entered.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost. in the congestion avoidance phase, the extent of slow down of the congestion window rate is not precisely mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "e48263e414fc444ab613293ae86cc3fb",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences .",
        "reference_answer": "slow start (cwnd less than ss_thresh): \nin the slow start phase, cwnd is incremented by one every time a segment is acknowledged. this results in an exponential growth as cwnd is essentially doubled after each round trip time (rtt). this is done until either a packet is lost or ss_thresh is reached. when cwnd >= ss_thresh, the congestion avoidance phase is entered. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1. \n\ncongestion avoidance (cwnd >= ss_thresh):: \nin the congestion avoidance phase, cwnd is incremented more slowly. there are different incrementation strategies, but they usually grow linearly, e.g. only increment cwnd by 1 after all sent segments have been acknowledged. this is done until a packet is lost. typically, this means that cwnd less than ss_thresh and the slow start phase is entered again. \nafter a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1.",
        "provided_answer": "the two phases are slow start and congestion avoidance. at the slow start, the cwnd is initialised with 1 and then ex the slow start treshold (ss-thresh) is set on the advertised window size. while in the slow phase, the cwnd is counted up exponentially, but smaller than the ss_thresh. the congestion avoidance phase is reached, when the cwnd is as big as the ss_thresh. after that, the cwnd is increased linearily. whenever there is a timeout, then the ss_thresh will be set on half the amount of the cwnd, and cwnd will be reset at 1 again and phase 1 starts again.",
        "answer_feedback": "the response is partially correct because the slow start phase's description is missing how ss_thresh changes when a packet is lost.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "761da792fe0e461abec7e3d4f4221ae8",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the congestion control consists of two phases: slow start and congestion avoidance. after the initialization of cwnd and ss_thresh, the slow start tries to discover the proper sending rate as quickly as possible by incrementing the cwnd by 1 for each acknowledged package. this is continued until the ss_thresh is reached or a packet gets lost, then the congestion avoidance starts. now each time a congestion occurs, the ss_thresh is set to cwnd/2, the cwnd is reset to 1 and the slow-start is entered again.",
        "answer_feedback": "in the congestion avoidance phase, the cwnd is increased linearly before congestion occurs is not mentioned.  congestion avoidance starts only when the threshold is reached , not when packet loss occurs.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.68
    },
    {
        "id": "39f345cfe0d34f13bb6391be4ae55cac",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the two phases are \"slow start\" and \"congestion avoidance\". to make sure the network is not overloaded immediately, a tcp sender will start to send \"slowly\": first one segment, then as long as the segments get acknowleged double the rate each time, until the ss_thresh value is reached. this means after the first ack is received, the sender will send two segments at once, then four, eight, etc until the ss_thresh value is reached or no ack is received. if the ss_thresh value is reached (phase 2) the sender will increase the rate linearly by one each time. if a packet times out the ss_thresh value is set to 50% of the current rate and the cycle is repeated with phase 1.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached. this needs to be explicit for both the phases.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "c65ebb109af14c89bfced5206c1977bc",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start (cwnd < ss_thresh)\nphase 2: congestion avoidance (cwnd >= ss_thresh)\nin phase 1, cwnd is initialized to 1, then it increases exponentially until it reaches to ss_thresh.\nin phase 2, cwnd increases one by one until it reaches the congestion, then new ss_thresh will be set to 2. then cwnd is reset to 1 and phase starts.",
        "answer_feedback": "\"then new ss_thresh will be set to 2(half of current cwnd). then cwnd is reset to 1 and phase starts(which phase starts??).\"\nin the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "ff38c95d4c5d4bb5a9d795446670fbe1",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the goal of the slow start phase is to quickly find a good sending rate. \nfor each ack that is received, the cwnd is incremented, effectively doubling the cwnd within the round trip time.\nthe congestion avoidance phase starts as soon as either a packet loss occured or cwnd is greater or equals to ss_thresh and the cwnd is only incremented once each round trip time. \nwhen a timeout occures, ss_thresh is set to half of cwnd, cwnd is reset back to one and the slow start phase is entered again.",
        "answer_feedback": "congestion avoidance phase starts only when  cwnd >= ss_thresh. packet loss can occur in both phases, resulting in ss_thresh = cwnd / 2 and cwnd = 1",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "04ccef7128e74ef1a1c1c9b0846fd178",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1 - slow start:\nfor each received ack, the cwnd is increased by one until the ss_thresh (threshold) is reached.\nphase 2 - congestion control:\nduring congestion avoidance the cwnd increases linear by one per rtt. if a timeout occurs (congestion) the ss_tresh is set to half of the current window size (cwnd) and cwnd is set to 1. then slow start will begin again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "52d29d98e18543f1a123359e92b32b95",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start\nphase 2: congestion avoidance\n\nphase 1: start with a cwnd with one and double it every time a/the acknowledgment/s comes until the ss-thresh(default: advertised window size) is reached or a congestion occurs.\n\nphase 2: if a congestion didn't occur increase cwnd by one each time. until a congestions occurs. then set ss_tresh to the half of the cwnd right now. and repeat phase 1.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "b4e2a0c56155424aaadbbe00679de1b6",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the two phases of congestion control are the \"slow start\" and the \"congestion avoidance\" phase. in the slow start phase, the cwnd is incremented by one whenever a segment is acknowledged until the the cwnd reaches the value of ss_thresh or until packet loss occurs. in the congestion avoidance phase, the ss_thresh value is set to cwnd / 2 whenever congestion occurs. afterwards, cwnd is reset to one in that phase.",
        "answer_feedback": "in the congestion avoidance phase, the cwnd is increased linearly before congestion occurs is not mentioned.in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "6042178a75504a03b95d3b817d08aafd",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "1) slow start\ncwnd verdoppelt sich nach jedem roundtrip (exponentiale erhöhung)\nss-thresh bleibt während slow start gleich. \n2) congestion avoidance\ncwnd wird nach jedem roundtrip um mss/cwnd erhöht (lineare erhöhung)\nwenn congestion eintritt wird ss_tresh = cwnd/2 gesetzt und cwnd auf 1 gesetzt.",
        "answer_feedback": "\"ss-thresh remains the same during slow start. \" not always as congestion can occur in this phase also. after a packet is lost / congestion the following adaption is made in both phases: ss_thresh = cwnd / 2. then cwnd is reset to 1",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "d3fc1d4d6c2d431a80fbe6ee85bfe7f7",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start(getting to equilibrium)\nphase 2: congestion avoidance.\n\nin phase 1, cwnd is < ss_thresh, and initialize cwnd=1,  and then it increases expotentially until reach the ss_thresh, in phase 2, cwnd>=ss_thresh, it increases slowly one by one until reaches the congestion, then set the new ss_thresh=cwnd/2, and reset the cwnd=1 and continue start from phase 1.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "deeffb080d7d4651a96af5a2870b6df7",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1. slow start -> discover proper sending rate\nwhen starting traffic on a new connecting or when experiencing an increase in traffic after congestion, the cwnd is initalized with one.\nwhenever a segment is acknowledged, the cwnd is incremented by one until eather ss_thresh is reached or packet loss is experienced.\nphase 2: congestion avoidance\nafter leaving the slow start phase (cwnd >(=) ss_thresh), cwnd may be incremented by 1 mss every rtt to a maximum of smss.\nwhen a timeout occurs, meaning a congestion is experienced, ss_thresh is set to half the current cwnd. cwnd is reset to one and slow-start is entered again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "80770f18ce89499d9f3a9be6d1fca1a5",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "slow start: in slow start phase, cwnd is increased by one from 1 each time a segment is acknowledged i.e. cwnd is increased exponentially, but untill cwnd reaches ss_thresh (cwnd = ss_thresh) or when there is a packet loss. the increament is lowed down when cwnd >= ss_thresh i.e. cwnd is increased successively. \ncongestion avoidance. when congestion occurs, the size of ss_thresh is set to 50% of the current size of the congestion window i.e. ss_thresh = cwnd / 2 and cwnd is reset to 1. after that, slow start phase is entered.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached. also \"the increament is lowed down when cwnd >= ss_thresh i.e. cwnd is increased successively.\" happens in the congestion avoidance phase.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "7ec9f23baf274ac3a173a4f245b02c3e",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the two phases are called \"slow start\" and \"congestion avoidance\". when cwnd is smaller than ss_thresh the slow start phase is in action and cwnd is rapidly increased in a short amount of time by incrementing it by one each time a segment is acknowledged resulting in doubling the rate exponetially by doubling it every rtt. if cwnd is greater (or equal) than ss_thresh the congestion avoidance phase starts where as long as non-duplicate acks are received the cwnd may be increased by 1 mss every rtt (aimd). when a timeout occurs ss_thresh is set to cwnd/2 and cwnd is set to 1 and another slow start phase is entered resulting in alternating slow start and congestion avoidance phases.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "44b6f3be922b4b7ba8531388aa99fb8d",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1:slow start \nphase2: congestion avoidance\nin the slow start :each time a segment is acknowledged,  increment cwnd by one (cwnd++)\ncontinue until  reach ss_thresh or packet loss\nin the phase 2:each time congestion occurs: ss_thresh is set to 50% of the current size of the congestion window: \n ss_thresh = cwnd / 2\ncwnd = 1",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.in the congestion avoidance phase, the cwnd is increased linearly before congestion occur is also not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "f1898ed509f54de69b0628b719c86bbb",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start\nthe congestion window is increased exponentially, for every acknowledge the congestion window is increased by 1. \nphase 2: congestion avoidance\nthe congestion window is increased by 1 for every round trip. if a congestion happens it is reset to 1 and the ss_thresh is halfed",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "291460fcc69849eca71182c9a59ff017",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "cwnd = 1 mms, ss_thresh = window size\n\nphase 1: slow start\ncwnd < ss_thresh\n\nphase 2: congestion avoidance\ncwnd >= ss_thresh",
        "answer_feedback": "changes in both ss_thresh and cwnd in both the phases need to be explained.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "782da21a639142e69b485adc2fb97454",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start:\n -1- initialize cwnd =1\n\n -2- each time a segment is acknowledged, increment cwnd by one (cwnd++)\n\n -3-  continue until reach ss_thresh, packet loss\n\nphase 2: congestion avoidance: \n  timeout = congestion\n  each time congestion occurs: ss_thresh is set to 50% of the current size of the     congestion window:  ss_thresh = cwnd / 2 and  cwnd is reset to one: cwnd = 1     and  slow-start is entered",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.in the congestion avoidance phase, the cwnd is increased linearly before congestion occurs is not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "d79fd62aa45e4439b0a9d0e7f26a9ff9",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "slow_start (cwnd <= ss_thresh)  cwnd is doubled each rtt which is equal to an increase by one for every acknowledged segment.  phase continues until ss_thresh is reached or packet loss occured congestion avoidance (cwnd >= ss_thresh)additive increase multiplicative decrease cwnd+1 per rttif timeout occurs ss_thresh = ss_thresh / 2, and cwnd = 1enter slow_start again",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "491709da634b4a019f73c20483eb748a",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the phases are slow start and congestion avoidance.\nin the slow phase, the cwnd starts getting bigger in size, first slowly, then rapidly, until the ssthresh is reached. once reached, the congestion control phase begins, where the cwnd slowly grows in size until a congestion occurs (timeout). in this case the slow start phase is entered again, the cwnd is reset and a new ssthresh is calculated (half of reached cwnd before timeout.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "511a59eb34ed4b70826aa064791cfbe6",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "2 phases: slow start and congestion avoidance. in the slow start phase,  the cwnd is doubled from 1 to 2, 4, 8, after each ack is received,  when cwnd >= ss_thresh, addiitively to 9, 10, 11... until timeout(congestion) or packet loss. when congestion occurs, ss_thresh is set to 50% of the current size of cwnd, cwnd is set to 1. repeat again with slow start.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "f45994b97aad412ab04c764b01cf7062",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start (cwnd < ss_thresh)\ncwnd wird mit 1 initialisiert. senderate, sprich cwnd, wird solange langsam erhöht, bis aufstauung (congestion) entsteht.\nphase 2: congestion avoidance (cwnd >= ss_thresh)\nss-thresh wird auf cwnd/2 gesetzt, wobei cwnd der aktuellen fenstergröße entspricht.anschließend wird cwnd wieder auf 1 gesetzt und zur \"slow start\"-phase übergegangen.",
        "answer_feedback": "in phase 1, cwnd increases exponentially. in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.in the congestion avoidance phase, the cwnd is increased linearly before congestion occurs is not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.63
    },
    {
        "id": "d39c509b1c514acc94b772817224f9d4",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "the first phase (\"slow start\") doubles the cwnd after every rtt until ss_thresh is reached. after that, the second phase (\"congestion avoidance\") starts and furthermore only increases cwnd +1. each time a congestion occurs, the ss_thresh is set to 50% of the current cwnd and cwnd is reset to 1, after which \"slow start\" phase is entered again.",
        "answer_feedback": "in the slow start phase, what happens to the cwnd and threshold when the packet is lost before the threshold is reached.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "2aab0210604040a4917d3988056aec72",
        "question": "in the lecture you have learned about congestion control with tcp. name the 2 phases of congestion control and explain how the congestion window (cwnd) and the slow start threshold (ss_thresh) change in each phase (after initialization, where cwnd = 1 and ss_thresh = advertised window size) in 1-4 sentences total.",
        "reference_answer": "slow start: ss_thresh is constant, increment cwnd by one every time a segment is acknowledged until ss_tresh is reached, then slowed increase of cwnd congestion avoidance: cwnd is reset to 1 after adjusting ss_tresh = cwnd / 2",
        "provided_answer": "phase 1: slow start(getting to equilibrium)\nphase 2: congestion avoidence \nin both phases,when timeout occurs, ss_thresh is set to 50% of the current size of the congestion window, cwnd is reset to one, and slow-start is entered.and each time a segment is acknowleged , cwnd increase by one ,when cwnd=ss_thresh or packet loss , congestion avoidence is entered from slow-start .",
        "answer_feedback": "at what rate cwnd increases in the congestion avoidance phase is not mentioned.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "40a50ed0871e41fe96c0e19d7f3ba215",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "from less probable to most probable: b, c, a.\nevent b is very unlikely, because it is requiring a strict sequence of heads and tails, which can be calculated by 0.6^3 * 0.4^3 = 1.4%.  event c is more likely than c, because it just requires 3 heads, which is less strict than b and includes b, it can be calculated by bincoef(6, 3) * 0.6^3 * 0.4^3 = 27.7%. a is more likely than c, because it is less strict and having at least three heads as well includes c, having exactly three heads. it can be calculated as the sum for all k=3 to 6: bincoeff(6, k) 0.6^k * 0.4^{6-k} = 81.1%.",
        "answer_feedback": "the response correctly answers the events' order with appropriate justification, but the final result of the probability calculation of events c and a is incorrect. the correct values are 27.648% (rounding mistake) and 82.08%, respectively.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "644acd5953ec4041865c0d84876a2c0d",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "event b\nevent c\nevent a\n\nevent b: this is because the probability of seeing exactly in sequence hhhttt is very low as there can be many different combinations such as hthhth, hththt and others similar to that but for having the sequence hhhttt there is only a single combination so the probability is very low.\n\nevent c: then the probability of seeing exactly three h's as the probability for showing up a head is 0.6 so there is more chances that a head shows up so the probability of head is more so exactly three h's probability is also low.\n\nevent a: the probability of seeing head at least three is more because the probability of head is more 0.6 so the probability of a tail is 0.4 so we consider for this circumstance 0 t, 1t, 2t and 3t so summation of all these gives us the probability of at least three h's",
        "answer_feedback": "the response correctly states the sequence of the three given events. the justification for the events c and a is incorrect as the exact probability of h is not relevant (except when p(h) = 1 or 0) as c is a subset of a.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "d320327c66d34c839f45290e1606d3f1",
        "question": "let us assume that you flip a coin 6 times where the probability of heads (h) showing up is 0.6. please arrange the following events in the increasing order of their likelihood (i.e., least probable → most probable): ● event a: you see at least three h’s ● event b: you see the sequence hhhttt ● event c: you see exactly three h’s include justification in your answer headers.",
        "reference_answer": "the correct sequence is bca , where b is the least probable. one of the following justifications should be given:\n\t\t● event b is a subset/part/special case of c, and c is a subset/part/special case of a\n\t\t● event b is more specific/strict than c and c is more specific/strict than a\n\t\t● an actual, correct calculation of the probabilities:\n\t\t○ p(b) = 0.6 * 0.6 * 0.6 * 0.4 * 0.4 *0.4 = 0.6^3 *0.4^3 = 0.013824 \n\t\t○ p(c) = (6 choose 3) * p(b) = 0.27648 \n\t\t○ p(a) = p(c) + p(y=4) + p(y=5) + p(y=6) = 1 - p(y=0) - p(y=1) - p(y=2)\n\t\t= (6 choose 3) * 0.6^3 * 0.4^3 + (6 choose 4) * 0.6^4 * 0.4^2 +(6 choose 5) *\n\t\t0.6^5 * 0.4 + (6 choose 6) * 0.6^6\n\t\t= 0.27648 + 15 * 0.020736 + 6 * 0.031104 + 1 * 0.046656\n\t\t= 0.8208 \n\t\t○ the answer may be rounded to up to 2 decimal places, e.g. p(b) = 0.01 or\n\t\tp(b) = 0.014\n\t\t○ it is also sufficient to give a formula without the actual calculation, if it is apparent that p(b) less than p(c) less than p(a), e.g. by stating p(c) = 20 * p(b)",
        "provided_answer": "b -> c -> a\n\nb is the least propable, because there is only this one combination out of 64 possible combinations. the propability is 1,38% ( 0,6*0,6*0,6*0,3*0,3*0,3). c is more propable, because out of the 64 combinations, 20 combinations can satisfy this condition (formula would be 6!/3!*3!) and results in 27,63% propability. the most propable case is a, because it contains b and has the propabilities of having 4 hs, 5hs and 6hs added onto it, which results in 82,08% propability.",
        "answer_feedback": "the response correctly answers the order of the events with appropriate justification but the probability of event c is incorrect. the correct value is 27.648% (rounding mistake).",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "5634bcd481474cf3ad93fc38b0efba31",
        "question": "please explain the problem with \"distributed queue dual buses\" that was discussed in the lecture in 1-3 sentences.",
        "reference_answer": "depending on your position in the bus station have a disadvantage/advantage when reserving transmission rights.",
        "provided_answer": "before sending data from node a to node b, a has to reserve a frame in the bus where a comes after b. outer nodes are restricted to sending only in one direction, while nodes in the middle may make reservations in both directions and thus have a higher chance to get a reservation.",
        "answer_feedback": "the response is partially correct as the nodes located close to the generator have a higher chance of getting a reservation rather than the \"middle\" node. so unidirectional or bidirectional alone does not decide fairness.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "51be16f927014204866a3b9b8c3593cc",
        "question": "state at least 4 of the differences shown in the lecture between the udp and tcp headers.",
        "reference_answer": "possible differences :\nthe upd header (8 bytes) is much shorter than the tcp header (20-60 bytes)\nthe udp header has a fixed length while the tcp header has a variable length\nfields contained in the tcp header and not the udp header :\n-sequence number\n-acknowledgment number\n-reserved\n-flags/control bits\n-advertised window\n-urgent pointer\n-options + padding if the options are\nudp includes the packet length (data + header) while tcp has the header length/data offset (just header) field instead\nthe sender port field is optional in udp, while the source port in tcp is necessary to establish the connection",
        "provided_answer": "a udp header has a length of 8 bytes whereas a tcp header has a length of 20 bytes. a udp header has a field for the packet length, unlike a tcp header. a udp header doesn’t contain a sequence number, while a tcp header does. a udp header neither contains an acknowledgement number but a tcp header has an extra field for that.",
        "answer_feedback": "the response correctly identifies and states the four differences between tcp and udp headers except that the tcp header can be between 20 and 60 bytes long.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "cbf4789710d040c7859ea335a9224d9a",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "it’s not realistic, because in the real-world the high traffic in the internet depends often on the day and the time of the day. for example, weekend or holiday and morning, afternoon or evening. so, it can be that in the morning there are many zeros in the time slots and the evening there much ones, because for example everyone is watching netflix in the end of working day or is doing some other internet things. so there can be more than one on’s in time interval delta t.",
        "answer_feedback": "one can use a function instead of a constant to model the arrival rate to reflect such large-scale behavioral patterns like having more traffic in the evening. the arrivals would not depend on previous arrivals then, only on the time of the day, which is known. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "bc240e66eec147f58e7ac2e864b192cf",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption can not hold for real internet traffic because the underlying assumption of independence is false. over a higher timescale the behavior of the user is undergoing changes. for example a user checks his mails in the morning for which packets arrive but then he goes to work and in that time no packets arrive. another example disproving the assumption of independence is the on/off bursty traffic while watching videos. for some time packets arrive continuously and then if the buffer is full no packets arrive until the buffer is empty again and needs to be refilled.",
        "answer_feedback": "the first example in the response is partially correct because the arrival process' parameters can be time-dependent. that can model such intra-day variations like people going to work. knowing previous arrivals no longer has to capture this information for us, thus making the inter-arrival times independent in this regard. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "0e58cbd3ed094438abe64299d02fcf79",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, because sometimes many users want to access the server at the same time, while at other times, only few request the server. for example a livestream of a football match: everybody sends requests to the server at kickoff, but only few do after the game (to watch the highlights). that means that the arrivals are not independent. they can depend on other events.",
        "answer_feedback": "the arrival depends on other events in such cases but the dependency can also be observed in the normal scenario when no such event is happening. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "ebe7b34d7e2144908f4cb6e63f97470b",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "no, it is not true for real time internet traffic. the arrivals of packet is not independent on time interval as while loading or streaming something the next video is loaded automatically if the previous video is about to end.eg. youtube,netflix etc.. this proves that it is not independent of the time interval.",
        "answer_feedback": "the response correctly associates the probability of arrivals at a node with previous arrivals. however, the example given does not illustrate this well because the next video's auto-load can be turned off in the application setting. a better example would be on-demand video streaming in general, as the traffic is bursty depending on the segment loading.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "1eaca04860e44ee5b98b495ca47f5220",
        "question": "to model the packet arrivals as a poisson process, we assumed that the arrivals for each time interval δt are independent. does this assumption hold for real internet traffic? explain your answer in 2-5 sentences. ",
        "reference_answer": "no. real internet traffic often comes in bursts. therefore, arrivals are not independent because the probability of an arrival happening at a node is influenced by previous arrivals at the node. for example, on-demand video streams selectively load the next video segments when needed. this means the actual network utilization depends on the current playback state on the client-side. the packet arrivals are not independent, as it is likely that there is a low utilization directly after the next segments have been loaded.",
        "provided_answer": "this assumption does not hold for real internet traffic. real traffic is for example dependent on the daytime. furthermore the application is relevant. some might use bursty traffic.",
        "answer_feedback": "the response is partially correct because the arrival process' parameters can be time-dependent. in this way, the arrival rate wouldn't depend on the previous arrivals, but instead on the time of the day.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "8face0c9b01e4ab0a31e60ce262e142a",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "at the start, the bridges table is empty, it uses flooding for an unknown destination. during the backward learning process, the bridge works in promiscuous mode as it receives any frame on any of its lans, then the bridge receives frames with sources address q on lan l, q can be reached over l and therefore create table entry accordingly.",
        "answer_feedback": "the response correctly describes how transparent bridges build their bridge table. however, the response does not provide information on how the table is used during the forwarding process and what benefits this brings.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "bc0333d46f4a40ab8ecccfa236fbcdf2",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table stores the information, which station it can reach over which lan (output line). the bridge works in the promiscuous mode, which means that it receives every frame of each connected lan and during the backwards learning phase when the bridge receives frames with a source address s on a lan l it \"learns\" that s can be reached over l and creates a table entry accordingly. these entries are associated with timestamps and updated when new frames were received from the source (e.g. s). to forward a frame the bridge will look at the source and destination lans and drop the frame if they're identical (and therefore prevent unnecessary traffic) but if they are different the bridge can look up in the table to which lan the frame has to be rerouted. only if the destination is unknown the network will be flooded with the frame. because the bridge is not visible as such for the other components of the network, these other components are simplified and they don't have to deal with the forwarding process.",
        "answer_feedback": "the stated benefit is related to transparent bridges in general, but the question asked for the benefit of using bridge table information during forwarding, which is reducing duplicates. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "5315d21e3fbe4b389134a50743810e81",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the invisible bridge contains a table which holds information about which address can be reached in which of the connected lans around it. this table is initially empty, but then filled during the process of backward learning - when the bridge receives a packet from a lan l with the sender address a, it can be concluded that a is part of the lan l and therefore routable on this network. as the name clearly states, the bridge in the network is transparent as such, instead it is just addressed with the network receiver address by any senders in one lan, so that it then can use its table to figure out in which destination-lan the package should be sent. so one can conclude that the table prevents flooding from the transparent bridge and therefore unnecessary traffic. the other overall feature of the usage of a transparent bridge is the decreased complexity of transmission for all nodes in the combined lans, because they can just sent packages to all nodes in all connected lans without having to deal with the routing between the lans by itselves.",
        "answer_feedback": "the response does not mention how flooding is done when there is no entry for a packet destination in the table, so flooding can not be prevented completely. apart from that, the response is correct. it also additionally states the benefit of the transparent bridges in general, which was not required.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "79f192ddf4824d5d919b4f49a39bcb40",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "all bridges inspect all the traffic and build up tables (bridge tables), these tables hold information to manage the traffic and each entry contains an address and the lan that leads to that address.\n\nthe bridge table is initially empty and uses flooding for an unknown destination. \nduring the backward learning phase (learning process) the bridge works in promiscuous mode and receives any frame on any of its lans. if the bridge receives frames with source address q on lan l and q can be reached over l, then it will create table entry accordingly. \nthese tables are adapted to changes in topology. each entry is associated with a timestamp (frame arrival time), and the timestamp of an entry (z, lan, ts) is updated when the frame received from z. \nthe table scanned periodically and old entries purged if no update for some time, usually several minutes (e.g., because the system moved and reinserted at a different position, or flooding was used if the machine was quiet for some minutes).\n\nthe main benefit of bridge tables in the forwarding process is to increase reliability by connecting lans via various bridges in parallel.",
        "answer_feedback": "the response incorrectly mentions the benefit of using multiple transparent bridges but the question asked for the benefit of using bridging information in forwarding frames. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "4c290bd0081f4d619305f53264c31c2d",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "the bridge table contains mappings of station to the output line that has to be used to reach the station. the bridge uses promiscuous mode to observe the sent frames and if a frame from a specific source station is sent over a connected lan the bridge knows that this station can be reached over that lan and the bridge table is updated. in the forwarding process the destination is looked up in the bridge table and the frame is rerouted to the correct output lan, if it differs from the current lan. if the station is not found, flooding is used. a benefit of this setup is that the stations can transparently reach other stations in a different network like they were in the same.",
        "answer_feedback": "the stated benefit is related to transparent bridges in general, but the question asked for the benefit of using bridge table information during forwarding, which is reducing duplicates. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "86e6b9ad11e843329076a97542f94ac7",
        "question": "transparent bridges manage a bridge table for the forwarding process. please describe what information the table holds and how it is modified during the backwards learning phase. how is the table used in the forwarding process and what is one benefit of that? please answer the question in 2-5 sentences. ",
        "reference_answer": "1.a mapping between destinations/stations (macs) and outgoing lan interfaces.\n2.this table is initially empty and received packages are flooded on every line. when a bridge receives a frame (as the bridge runs in promiscuous mode it listens in on all the traffic arriving at its lan links) with source address q on lan l, it adds the timestamped entry “q can be reached over l” to the table and the next time a packet with destination q arrives, it is forwarded on link l. the time-stamp is used to update or purge old entries. therefore, it learns by observing the incoming traffic.\n3.to do selective forwarding instead of flooding. \n4.i)less duplication/unnecessary flooding is prevented.\nii)less congestion.\niii)better bandwidth usage than flooding.",
        "provided_answer": "this bridge table has mac addresses and ports of bridge in it. at the very beginning, the table is empty, then for example, bridge sees that a frame on port 1 coming from source address a, it knows that a must be reachable via port 1, then it makes an entry in its table.\n\nbridge receives a frame, then it looks up the corresponding destination on its table, if the destination is found, and source address and the destination is identical, the frame would be dropped, if not identical, the bridge will forward this frame to its destination. but if the destination is not found, it will flood.\n\nthis table increases the reliability.",
        "answer_feedback": "the response states reliability as the benefit but it is not mentioned how the table usage increases the reliability. apart from that, the response is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "ee695615d03e412c902731d6057cfe76",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "hidden terminal because there no cable connecting every terminal together it can happen that two or more station can not reach each other and therefor hidden. this can be a problem if for example a terminal has to be quiet so it doesn’t disturb the communication of a neighbor but it can’t get the communication request signal from the communication partner because it is hidden. this can be solved by using a busy signal or by listening to acknowledgments from the neighbor. near and far terminals a signal from a station gets weaker with distance by the inverse square law. this lead to the situation that nearer stations are overpowering stations which are further away and drowning there signal. as a result stations which would normally be able to communicate with each other can’t do so anymore. this can be a severe problem and can only be handled with precise power control.",
        "answer_feedback": "the response correctly describes the near and far terminal problem. in the hidden terminal, two stations cannot reach each other because they are out of one other's detection range, not just because they are wireless nodes.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "2d892e47e54c4281971127dc3b171a4a",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "1. application layer - the discovery of services - you will need service awareness and need places for the services security\n\t - outside you can always be attacked, or the mobile routing could be disturbed.",
        "answer_feedback": "the response states application layer related challenges, but there is no clear relation to the wireless network routing challenges. the second point does not specify what is meant by outside. even the optical fiber lines of wired networks are laid outside, even in seas.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "44a81e9660c9442081383d1b307e26dd",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "- the network structure is changing fast, so the routing tables must be adapted to these changes. the routing algorithm needs to converge fast.\n\t - because all nodes share the same communication medium (the ether), the signaling overhead needs to be minimized, to reduce the load in the medium.",
        "answer_feedback": "in the second challenge, it should be made explicit that the usable frequency is limited.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.88
    },
    {
        "id": "d0cebb8817eb47bc93fffb46565e5c56",
        "question": "what are the challenges of mobile routing compared to routing in fixed and wired networks? please name and describe two challenges.",
        "reference_answer": "possible challenges:\n1.adaptation: the network has to handle the dynamic positioning of the nodes/topology changes. additionally, nodes can leave or join the network anywhere (within signal range) at any time.\n2.security: interception of packets or injection of faulty packages is easily possible in wireless networks. this may necessitate encryption and authentication.\n3.medium access control: wireless networks feature new possibilities for inference and collisions of the transmitted signals. see the following correct example challenges:\ni)hidden terminal: nodes’ transmissions may collide at other nodes without them noticing, because they are out of detection range of each other (a and c in this example) and therefore sense the medium to be free even though there is an overlap of the transmission ranges. \nii)exposed terminal: nodes (c in this example) may not realize they could send collision-free, because a node in their detection range (b) is sending and they, therefore, detect the medium as busy, but the sending node (b) is out of the detection range of the destination node (d) so that no collision would occur.\niii)near and far terminals: signal strength decreases proportionally to the square of distance, so closer nodes may drown out the weaker signals of nodes farther away.\n4.quality of service (qos): due to the rapidly changing network topology, imprecise network information, and resource constraints of participating nodes, it is challenging to provide the desired qos. additionally, signal quality may also decline due to noise and occlusion.\n5.scalability: since it is not possible to know the number of participating nodes beforehand, it is vital that routing protocols, etc. are capable of dealing with increasing network sizes and workloads. \n6.heterogeneity: nodes may have different capabilities, responsibilities, and constraints, e.g. processing capacity, transmission ranges\n7.dependability: providing consistent, performant, and reliable routing behavior that higher-level services can trust is challenging in such a dynamic environment. \n8.power consumption: as most mobile devices are battery-powered, power consumption becomes an important optimization factor in routing, etc.",
        "provided_answer": "- hidden terminal problem:\nassume we have 2 senders s1,s2 and one receiver r build like this:\n\ns1 → r ← s2\n\nthe radius of s1 can just sense the receiver and s2 can also just sense the receiver. \n\ns1 is sending something to r. but since s2 cannot sense s1 it assumes the receiver is free and starts sending to r too. hence s1 is hidden to c the collison detection fails → hidden terminal problem.\n\n- exposed terminal problem:\n\nassume we have 2 senders s1,s2 and two receiver r1, r2 build like this:\n\nr1 ← s1 --- s2 → r2\n\nnow s1 sends to r1. s2 wants to send to r2 but it gets the signal from s1 that it is sending data at the moment. since s1 is sending to r1 and s2 can not sense r1, it assumes r2 is busy, and hence waits unnecessarily.  --> exposed terminal problem",
        "answer_feedback": "the response related to the hidden terminal is partially correct as s1 assumes the medium instead of the node to be free. the description of the exposed terminal problem is partially correct as well. s2 senses the medium is busy and waits, not because it assumes r2 busy. the wait is unnecessary as s2 wants to send data to r2, and r2 is out of the range of s1.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "d0ca8535cda14a3a9ee73730e5fb708b",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "the reverse path forwarding guarantees that the packet used the best route when this packet arrived at the is entry port. reverse path broadcast is based on rpf  to suitable reduce of overhead. rpf (for a packet arriving at an is)  -has this packet arrived at the is entry port   over which the packets for this station/source are usually also sent?    yes:  -assumption:   packet used the best route until now  -action:     resend over all edges (not including the incoming one)     no:  -assumption:   packet did not use this route (it is not the best route)  -action:     discard packet (most likely duplicate)  rpb: -has this packet arrived at the is entry port   over which the packets for this station/source are usually also sent?    yes:  -packet used the best route until now?    -yes: select the edge at which the packets arrived and from which they are then rerouted to source s (in reversed direction)  -no: do not send over all edges (without the incoming one),  i.e., not as in reverse path forwarding (rpf)     no:  -discard packet (most likely duplicate)",
        "answer_feedback": "the response correctly explains rpf and rpb but it lacks the purpose. the purpose of both algorithms is to minimize the number of duplicate packets during broadcasting.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "e50cea44b9de4d4cb589aa238d077ee1",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding: used for ensuring loop-free forwarding of multicast packets in multicast routing and to help prevent ip address spoofing in unicast routing.  checks if the packet arrived at the is entry port over which the packets for this station/source are usually sent. if packet is assumed taking the best route: resend over all edges (not including the incoming one). if packet is assumed not taking the best route: discard packet.  reverse path broadcast: used to check if the set of shortest paths to a node forms a tree that spans the network.  if the packet arrives at the is entry over which the packets for this station/source are usually sent: checks if packet used the best route until now: if yes, select the edge at which the packets arrived and from which they are then rerouted to source. if no, do not send over all edges (without the incoming one). if the packet is not for this station/source: discard packet.",
        "answer_feedback": "the purpose of the rpb algorithm is missing in the response. additionally, the purpose is not limited to unicast and multicast but instead used widely in broadcast too.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.9
    },
    {
        "id": "412d33d69aac410f8b3087780f682df9",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "-prevent routing loops/ cycles in the network   rpf: -each node has a route to every other node -each node only forwards a broadcast packet received from the same port used to send packets back towards the sender -so the packet is forwarded only if it comes from the same route that would be used to reply to the source   rpb: -improvement of rpf if the packet arrived at the is entry over which the packets for this station/source s are usually also sent and packet used the best route until, then select the edge at which the packets arrived and from which they are then rerouted to source s in reversed direction, if it’s not the best route then not send over all edges without the incoming one. -if not then discard packet.",
        "answer_feedback": "the response is partially correct as the explanation of rpf incorrectly states that \"each node has a route to every other node\" and also does not state over which links the packet are forwarded in rpf. the purpose and explanation for rpb are correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "9cc8281805254a9a96af9a6e26fa9d13",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "they are techniques to forward multicast packets in networks. they use information the is has about the network structure (derived from normal unicast packets) to guess where to send the multicast packets. if a packet in rpf arrives over the \"usual\" path over which the sender sends, the is will distribute(flood) the network with the packet. if the packet arrives not over the usual path, the packet will be dropped. in rpb, if the packet arrives over the \"usual\" path, the is will send it over the path that unicast packets \"usually\" take and not flood the network. if the packet arrives not over the usual path, the packet will be dropped.",
        "answer_feedback": "the response is partially correct because it lacks the purpose of both algorithms which is to minimize the number of duplicate packets during broadcasting. in both algorithms, the packet is also not forwarded to the edge from which it was received.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.7
    },
    {
        "id": "cdc11cf37050491db8db7f96c5470fe7",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding (rpf) and reverse path broadcast (rpb) are algorithms that are used to distribute packets with more than one receiver in a network. simple approaches are individual sending to every destination or flooding. these simple approaches aren’t optimal for distributing packets to n receivers. in rpf each router has information which path it would use for unicast packets. if a router receives a package, it checks whether it received the package via the optimal route, and only forwards it to every other reachable router (except from the router it received the package from). in rpb however, packages are only forwarded according to the routing tables (via the best routes), thus reducing the load of the network.",
        "answer_feedback": "the response does not state why rpf and rpb are more optimal than flooding. the explanation for rpf is correct. the explanation for rpb is incomplete as the answer does not specify what \"according to the routing tables\" / \"via the best routes\" means.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.6
    },
    {
        "id": "df43125070a24576829ec9b68e51630b",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding is an algorithm to allow loop free forwarding of packets (especially for multicast). the source ip of an incoming packet is looked up in the routing table. if the packet would be send on this interface if the source ip would be the destination, the packet is forwarded on all edges but the incoming one. packets that don't arrive via the shortest route may be ignored. reverse path broadcast is also used for loop free forwarding and works similar to rpf. though it does not send the packets out on all edged but selects those edges that are on the shortest path (in reverse) to the source of the multicast packet.",
        "answer_feedback": "the explanation of rpf is partially correct because the packets which did not use the best route will be discarded and not maybe discarded.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.8
    },
    {
        "id": "55878e05a2bd4a05aa55f65155299bd2",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "reverse path forwarding prevents multicast traffic from entering routing loops by looking up a table which holds all routers the multicast packet already visited. the packet is then forwarded to all routers that are not in the table. reverse path broadcast is an extension of rpf: in this case packets are only forwarded to this interfaces, where the next router is on the shortest path to data origin.",
        "answer_feedback": "the response correctly identifies the purpose of rpf but the provided explanation is incorrect. in rpf, the packet used the unicast information stored in the routing table to check whether the broadcasted packet took the same route that it would have taken to send a unicast packet in the reverse direction. no explanation is provided as to what forms the shortest route in rpb.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.4
    },
    {
        "id": "bc56a60a68e14da1bb5764a5d93edab5",
        "question": "what is the purpose of reverse path forwarding and reverse path broadcast? how do they work?",
        "reference_answer": "purpose: both implement a more efficient kind (in terms of duplicate packets) of broadcasting than flooding / to minimize the number of duplicate packets in the network when broadcasting.\n\nreverse path forwarding:  each node has a routing table stemming from unicast routing algorithms. when receiving a packet of sender s from neighbor n at node x, check the routing table and only forward the packet to all adjacent nodes (except for n) when you would send packets to s over n → the assumption is that the packet used the best route until now.\nreverse path broadcast: nodes monitor unicast traffic to learn which paths in the network they are a part of, that is node x knows that is on the best path between two nodes a and b if it receives unicast packets coming from a and going to b or visa versa. in other words, each node knows which spanning trees it is part of in the network. reverse path broadcasting works identical to reverse path forwarding with the exception that it only forwards packets on edges that are part of a spanning tree (again excluding the incoming line to n).",
        "provided_answer": "in both,packet used the best route with specific selection of the outgoing links. reverse path forwarding:packet used the best route and resend over all adjacent edges (not including the incoming one). reverse path broadcast:packet uses the best route and sends packet to adjacent nodes but select the edge at which the packets arrived and from which they are then rerouted to source in reversed direction and include the arrival node.",
        "answer_feedback": "the response explains the difference between the two correctly. the response does not state the purpose behind using the algorithms, namely to reduce duplicates in the broadcast. while both use the best route, how these routes are known is not explained.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.4
    },
    {
        "id": "1705402a8eb043c38b06e2765e60b390",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "property: global knowledge of the multicast group’s spanning tree (multicast tree)  initially only local knowledge   all is send link state packets periodically  -containing information     distance to neighbors     expanded by information on multicast groups -by broadcast to all the others each is calculates a multicast tree -from the now locally available and complete state information based on the information about the multicast tree - is determines the outgoing lines - on which packets have to be transmitted",
        "answer_feedback": "the response is partially correct because it lacks the attractive property of spanning trees.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "1cd35454bf2c417fa400fa017c12b825",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "spanning tree is known to the is as, generates a minimum number of packet copies , that is generates a copy of a packet for each required outgoing line and all spanning tree lines except incoming one have to be defined. it has to know the multicast basic principle, that all is have to know the multicast tree. so all is nodes send link state packets periodically.  the is defines the outgoing lines and which packets have to be transmitted.",
        "answer_feedback": "while it is correct that a spanning-tree generates minimum copies of the message, it is not clear from the answer what the response meant by \"is generates copy for each outgoing and spanning tree line\". the link-state modification for constructing spanning trees does not explain how each node shares its multicast information with others by adding it to the link state packet.  each node then has the complete information to build a multicast spanning tree.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "f1c2ba021c854f7b8188648615453ff3",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "you use reverse path forwarding with pruning. after the tree is set up the broadcast tree you know who belongs to the multicast. - if all child nodes aren't part of the multicast tree the parent knows it itself isn't part of the multicast tree. (bottom up) you can modify link state routing by not only considering the \"distance\" between neighbors but also information on multicast groups.",
        "answer_feedback": "the desirable property is not because it makes reverse path forwarding possible. instead, it is loopless and thereby reduces duplicates when broadcast- and multicasting. we do need to add the information to which group each is belongs to in the link-state packet but it is not stated how it is propagated and used to construct the multicast spanning tree.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "8e71f33e7fc94aa794a4e049c8c33eba",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the spanning tree algorithm determines the packets for the broad and multicasting while the link state packets will be sent, the containing information will be expanded by information on multicast groups - every is calculate now its multicast tree",
        "answer_feedback": "though it is correct that a spanning tree determines the path in multi-/broadcast, it does not answer why they are used. the reason is no loops in the spanning tree leading to reduced unnecessary duplicates.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "ec9d5d69e13e45b68381315abf9a8479",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "1. there is no loop",
        "answer_feedback": "the response lacks the explanation of the link state's modification to construct spanning trees. to calculate the spanning trees for multicasting, you also have to know which nodes belong to which groups. the link-state packets have to be expanded with multicast group information so other nodes can construct multicast trees by themselves.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "6668c253363c4fdda2cdaefcb2cb4048",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "the advantage of using a spanning tree for broad-/multicasting is that no duplicate messages are sent. this reduces network load while providing the exact same performance, only at the cost of lower reliability. if we want to construct a spanning tree using link state routing, each node, after having received the link state packets from all other nodes, calculates a spanning tree using the received information. the node will then use the connections from the calculated spanning tree to distribute multicast packets efficiently.",
        "answer_feedback": "the response correctly answers why a spanning-tree usage is ideal in multicast and broadcast. the explanation for modifying the link-state algorithm to construct a  multicast spanning tree for nodes does not state how a node gets to know about the other members of the multicast group and how this information is propagated to other is.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "97e3683c5df9481e984d95b5cd28587d",
        "question": "which property of spanning trees makes them appealing for broad- and multicasting? explain how you can modify link state routing to construct a spanning tree for multicasting.",
        "reference_answer": "property: there is a single unique path between every pair of nodes in the tree. alternatively, you can say that spanning trees are subnets of a network that do not contain loops but contain all nodes. this means that no unnecessary duplicates are distributed in the network when forwarding packets using that tree structure.\n\nspanning tree with link state routing: each intermediate system knows which multicast groups it belongs to, but initially doesn’t know which other is belong to the groups. therefore, you can add multicast group information to the link state packet and each node can construct multicast trees once the full network topology and group information are distributed in the whole network, as each node then has the complete state information stored locally (e.g. with prim or kruskal)",
        "provided_answer": "property: subnets of subnets can be displayed and addresses which enables more possibilities for multi-/broadcast for distribution of information\n\nmodification of link state routing for spanning tree multicast: \n\n- all is have to know the multicast tree. →which group belonging \n\n- information distribution via link stated routing.\n\n- all is send updates (link state packages) periodically\n\n→calculate the own tree\n\n→determine possibilities for transmission",
        "answer_feedback": "the desirable property is not correctly stated. yes, a spanning tree is a subnet of the subnet, but what makes it unique is that it does not contain loops and thereby reduces unnecessary duplicates during multicast and broadcast. additionally, the link-state packet needs to contain multicast group information so that each node can discover its fellow group member.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "3bb5caaf9fc845a788e22dacecf0e58b",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are located between header and payload. they can contain options or other information which extend the header. the main advantage of the extension headers in ipv6 compared to ipv4 is that they are optional. in ipv4 there is a part for the options reserved but in ipv6 when there are no options the space of the extension headers can be used for a longer payload. so the extension headers are more efficient.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. the stated main advantage is incorrect as the option field in the ipv4 header is already optional, without any reserved space.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "ad0294d1afab4203af6120013a2a792f",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "the header in ipv6 has a fixed length and is designed to be used for easy processing, it only contains information needed for routing. any additional information is stored in extension headers. they carry optional information and can be found in between the fixed header and the playload. since the whole ipv6 packet is only allowed a certain size, these additional extension headers take up space of the payload. the main advantage of extension headers is that they can be added optionally and help to overcome size limitation.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. as even the option field in the ipv4 header is optional, the first stated main advantage is incorrect. the other advantage is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "b5831bd49c404b738285de0805995658",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "- located between fixed header and payload\n- are optional, modularly including additional information, e.g. routing information, authentication, or destination options\n- ipv6 has a fixed sized header",
        "answer_feedback": "the response answers the description and location of extension headers correctly. the ipv6 header has a fixed size but the response should state what advantage is concluded from this fact, so it is only partially correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "1cc46e82e9e3414095585aabfa39689b",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are optional headers that can augment the main header. they are located between the main header and the payload. their main advantages are that they cause less overhead since they can be omitted if not needed and that new headers can be added in the future.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. as even the option field in the ipv4 header is optional and could be 0 bits long, there is no added advantage over the ipv4 option field in terms of unnecessary overhead. the other advantage is correct.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "af39577d2fad44869d982a2e538eaae6",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are extensions for the normal header. you can support multiple addresses or specify more options for your header and packet, like e.g. authentication.\n\nthe extension headers are located between the normal header and the payload, they will be attached to the normal header. \n\nthe biggest advantage of extension headers is the possibility to use broadcasting.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. the advantage is incorrect as ipv6 does not support broadcast.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "6f3aaf1a49454cf0ba12df7d36be88c8",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are optional headers located between the fixed header and payload. as they are optional, less data can be transferred by leaving them out. they also help overcome size limitations and allow appending new options without changing the fixed header in the future.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. as even the option field in the ipv4 header is optional, there is no added advantage over the ipv4 option field in terms of the amount of transmittable data.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "891c052cb92f4220835e374f813586b8",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers contain of additional information like routing and fragmentation for the network device to decide how to process the ipv6 packet. extension headers are placed between fixed header and payload. ipv6 options are placed in separate extension headers that are located between the ipv6 header and the transport-layer header in a packet. they help to overcome size limitation and allow to append new options without changing the fixed header. the main advantage is efficiency: since there is no extra space for options between fixed header and payload there is a smaller header and therefore more space for payload. this way it is much faster.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. the stated main advantage is incorrect as even the option field in the ipv4 header is optional. but as additionally stated in response it provides the flexibility to add extra options without changing the fixed header size. this is a correct advantage.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.75
    },
    {
        "id": "cde51d06259043508a447890068733d4",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers are optional headers that store additional information.\nthey are located between the fixed header and the payload.\na lot of the information that is stored in extension headers in ipv6 is stored the fixed header in ipv4. because of that the 'space' for the information is always reserved in ipv4, even if you don't need it. in ipv6, because extension headers are optional, you don't have to reserve any space for this information, if you don't need it.",
        "answer_feedback": "the response is partially correct because the stated advantage is incorrect. after all, the options field in ipv4 is optional and also allowed to be 0 bit long, so there are no extra space benefits based on it.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "07a237df6ae24853832056c9a102003b",
        "question": "what are extension headers in ipv6 and where are they located in a packet? what is the main advantage of extension headers compared to ipv4?",
        "reference_answer": "extension headers are used to extend the fixed ipv6 header with additional, optional network layer information. if present, they are located between the fixed header/main header and payload/upper-layer header/ transport-layer header.\n\nmain advantage: one of the following advantages are considered fully correct:\n1. it allows the appending of new options without changing the header.\n2. ipv6 packets with optional headers are typically processed faster/simpler by intermediate devices as most of the options are ignored (except “hop-by-hop extension”) while they are processed by all routers in ipv4 unless ordered otherwise.",
        "provided_answer": "extension headers allow to extend the new, simplified and fixed-size ipv6-header with additional options. these headers are located between the standard header and the payload (upper-level headers and user data). this approach allows to add several additional options without reserving space in the standard header for such optional data,allowing the standard header to be smaller.",
        "answer_feedback": "the response answers the description and location of extension headers correctly. in ipv4, there is also no reservation of space for unused options. the main ipv6 header is most often larger than the ipv4 header in practice. some benefits result from the main header having a fixed instead of a smaller size.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "ceadc243bd3645e7b71489deabfd3ea9",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is used to manually/automatically assign ip addresses to physical devices inside of a network with the help of a dhcp server. a client with no ip address sends a broadcast dhcp discover packet to everyone on the network. the server will respond with a dhcp offer, where he offers an ip address to the client. the client will then respond with a dhcp request (telling the server he wants the ip address). the server will assign the ip address to the client for a certain time period (dhcp ack). after this leasing time, the client has to renew the leasing of the ip address otherwise the dhcp server will remove the ip address of the client again.",
        "answer_feedback": "the response is partially correct because the dhcp definition part is missing in the answer. there is an explanation about how dhcp works but that is not part of the question requirement.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "da0cb1165e6643eba2946471fa8a85af",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "the dhcp protocol is a protocol to configure systems that join a network.\nit is used to assign ip addresses to systems within the network. \nif a system joins the network it can ask the dhcp server for network configuration and an ip address that it should use in the future.",
        "answer_feedback": "the response is partially correct because it lacks a dhcp usage.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "542ffb3bc2074150a8ed1e8b08a9155f",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "it is used to assignip addresses to hosts in a network.",
        "answer_feedback": "the response does not give a definition and does not specify how dhcp assigns the ip addresses, i.e. dynamically or automatically.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "f3ca8adfa8f94552af4bdba3ebf072b5",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp is a network management protocol which configures end devices on ip networks (mostly lans) by assigning them an ip address and other network configuration parameters.",
        "answer_feedback": "the response only states the definition/description of dhcp correctly. the precise usage is missing in the response.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "c5f4942e4d10425b844db460a2edcd90",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "it’s a network protocol used on ip networks to dynamically assign an ip address and other information to any device (host) on a network so they can communicate using ip.",
        "answer_feedback": "the response only states the definition/description of dhcp correctly. the precise usage is missing in the response.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "cb53f4a90127434fa0bc19054c1ddef3",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "dhcp extends the functionality of rarp. it is used for automatic ip address assignment.",
        "answer_feedback": "the response only states the definition/description of dhcp correctly. the usage is missing in the response.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "ce7fff8b7ce1467d8fb9178b30f18804",
        "question": "what is the “dynamic host configuration protocol (dhcp)”? what is it used for? ",
        "reference_answer": "the dynamic host configuration protocol (dhcp) is a network management protocol used in internet protocol (ip) networks, whereby a dhcp server dynamically assigns an ip address and other network configuration parameters to each device on the network. further, dhcp has largely replaced rarp (and bootp)\n\t uses of dhcp are: simplifies installation and configuration of end systems. allows for manual and automatic ip address assignment. may provide additional configuration information  (dns server, netmask, default router, etc.)",
        "provided_answer": "the dhcp is used to add clients into a network by giving them the required information/addresses.",
        "answer_feedback": "the response partially describes dhcp as it lacks specifics, like what information is shared, to be considered complete and precise.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.25
    },
    {
        "id": "8b92b2a5ffe7419a940b355abcecaed8",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "requirement: the interval of two adjacent frames, which are sent by sender, is short.\nso that we can use piggybacking to response these two frames with one acknowledgement. \nthe communication has to be duplex (so the protocol must not be \"utopia\").\nand the receiving buffer from the sender must be ,so that it is able to store the ack plus the additional data!",
        "answer_feedback": "the response contains a duplex connection as one of the requirements, but having to send two frames within short intervals is incorrect. also, the same data and acknowledgments are tied together in piggybacking. therefore, the total buffer space requirement should ideally remain almost the same as when they are sent separately.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "c0495c36eddd4ae0a7c5f0d424cc51ec",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "there must also be frames directed towards a (sender) in the transmission, so that b (receiver) sends frames back to a in a reasonable amount of time. in addition to that the amount of frames size of both parties must be similarly big, because the acknowledgement is added to frames directed at a. as a result there must be a certain balance of frames in both directions.",
        "answer_feedback": "the response correctly implies duplex operation. however, a balanced approach is difficult to achieve in real scenarios, so there are ways to overcome it, like a dedicated timer signaling a timeout in the absence of data to be sent.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "e79339cd4a2c489fa41275c9c89c16db",
        "question": "what requirement has to be met so that you can use the piggybacking extension to the sliding window protocol?",
        "reference_answer": "piggybacking only makes sense if there is a full-duplex or semi-duplex connection between sender and receiver i.e.  two-way communication or frames must contain additional field for acknowledgement.",
        "provided_answer": "a receiver of a data frame has to send data frames the acks are piggybacked onto at a rate that is high enough so that the sender doesn't have to wait for too long for the acks to arrive. otherwise a timeout might occur and the sender sends the frame again.",
        "answer_feedback": "the response states duplex communication indirectly but a dedicated timer timeout can also be on the receiver side to send acknowledgment separately when sufficient data is not present.",
        "verification_feedback": "partially correct",
        "max_score": 1.0,
        "normalized_score": 0.5
    },
    {
        "id": "00f4bbf4e7c34628bb783fb468d1e0b9",
        "question": "why can duplicate packets be a problem in a network? please state your answer in a single sentence.",
        "reference_answer": "if the receiver is not capable of differentiating between valid and duplicated packets it may act on the same information twice.",
        "provided_answer": "network has varying transit times for packets, certain loss rate and storage capabilities, as well as  packets can be manipulated, duplicated by flooding and resent by the original system after timeout.",
        "answer_feedback": "the response is not precise about the problem or consequences caused when duplicates are present.",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "685a888ecb2543beb70144ecd3c41a24",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "10.0.0.0 - 10.255.255.255172.16.0.0 - 172.31.255.255127.0.0.0 - 127.255.255.255",
        "answer_feedback": "172.x.y.z is not in class a anymore",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "0eded6d918f94287ae0a1da94abaed5b",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "10.0.0.0 bis 10.255.255.255 private netze",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "a430d8c276534b3c9732f5d7228c26af",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "network addresses:    [0-127].0.0.0\nbroadcast addresses: [0-127].255.255.255",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    },
    {
        "id": "efac355536c54fd5b24e27e6da35f850",
        "question": "write-down all addresses in class a networks that are reserved.",
        "reference_answer": "126 class a nets can be addressed in classful ip addressing (1.xx.yy.zz - 126.xx.yy.zz) 127.xx.yy.zz is reserved for loopback testing 0.xx.yy.zz can be accepted if stated accordingly (definitions defer whether this is in class a)",
        "provided_answer": "for each of the 2^7 = 128 networks the first and the last address are reserved.\n- network address (all zeros)\n- broadcast address (all ones)",
        "answer_feedback": "missing: loopback",
        "verification_feedback": "partially correct",
        "max_score": 0.5,
        "normalized_score": 0.5
    }
]